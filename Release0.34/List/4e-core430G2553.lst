###############################################################################
#                                                                             #
#     IAR Assembler V5.30.1.50284/W32  for MSP430 28/Apr/2012  03:06:22       #
#     Copyright 1996-2011 IAR Systems AB.                                     #
#                                                                             #
#           Target option =  MSP430                                           #
#           Source file   =  C:\Dokumente und Einstellungen\All Users\Dokumente\4e4th\4e-core430G2553.s43#
#           List file     =  C:\Dokumente und Einstellungen\All Users\Dokumente\4e4th\Release0.34\List\4e-core430G2553.lst#
#           Object file   =  C:\Dokumente und Einstellungen\All Users\Dokumente\4e4th\Release0.34\Obj\4e-core430G2553.r43#
#           Command line  =  C:\Dokumente und Einstellungen\All Users\Dokumente\4e4th\4e-core430G2553.s43 #
#                            -OC:\Dokumente und Einstellungen\All Users\Dokumente\4e4th\Release0.34\Obj\ #
#                            -s+ -M<> -w+                                     #
#                            -LC:\Dokumente und Einstellungen\All Users\Dokumente\4e4th\Release0.34\List\ #
#                            -i -t8 -xD -r -D__MSP430G2553__                  #
#                            -IC:\Programme\IAR Systems\Embedded Workbench 6.0 Kickstart\430\INC\ #
#                                                                             #
###############################################################################

      1    000000              ; ----------------------------------------------
                               ------------------------
      2    000000              ; 4e4th is a Forth based on CamelForth
                                
      3    000000              ; for the Texas Instruments MSP430 
      4    000000              ; 
      5    000000              ; This program is free software; you can
                                redistribute it and/or modify
      6    000000              ; it under the terms of the GNU General Public
                                License as published by
      7    000000              ; the Free Software Foundation; either version 3
                                of the License, or
      8    000000              ; (at your option) any later version.
      9    000000              ; 
     10    000000              ; This program is distributed in the hope that
                                it will be useful,
     11    000000              ; but WITHOUT ANY WARRANTY; without even the
                                implied warranty of
     12    000000              ; MERCHANTABILITY or FITNESS FOR A PARTICULAR
                                PURPOSE.  See the
     13    000000              ; GNU General Public License for more details.
     14    000000              ;
     15    000000              ; You should have received a copy of the GNU
                                General Public License
     16    000000              ; along with this program.  If not, see
                                <http://www.gnu.org/licenses/>.
     17    000000              ; 
     18    000000              ; See LICENSE TERMS in Brads file readme.txt as
                                well.
     19    000000              
     20    000000              ; ----------------------------------------------
                               ------------------------
     21    000000              ; 4e-core430.s43 - Machine Language Primitives -
                                MSP430G2553 
     22    000000              ; ----------------------------------------------
                               ------------------------
     23    000000              
     24    000000              ; Revision History
     25    000000              ;  1 mar 09 bjr - changed Flash write and erase
                                primitives to correctly
     26    000000              ;       write RAM outside Info Flash and Main
                                Flash address limits.
     27    000000              
     28    000000              #include "msp430.h"                     ;
                                #define controlled include file
      1    000000              /***********************************************
                               ********************
      2    000000              *                                               
                                                  *
      3    000000              * This file is a generic include file controlled
                                by                *
      4    000000              * compiler/assembler IDE generated defines      
                                                  *
      5    000000              *                                               
                                                  *
      6    000000              ************************************************
                               *******************/
      7    000000              
      8    000000              #ifndef __msp430
      9    000000              #define __msp430
     10    000000              
     11    000000              #ifndef _SYSTEM_BUILD
     12    000000              #pragma system_include
     13    000000              #endif
     14    000000              
     15    000000              #if defined (__MSP430C111__)
     16    000000              #include "msp430c111.h"
     18    000000              #elif defined (__MSP430C1111__)
     19    000000              #include "msp430c1111.h"
     21    000000              #elif defined (__MSP430C112__)
     22    000000              #include "msp430c112.h"
     24    000000              #elif defined (__MSP430C1121__)
     25    000000              #include "msp430c1121.h"
     27    000000              #elif defined (__MSP430C1331__)
     28    000000              #include "msp430c1331.h"
     30    000000              #elif defined (__MSP430C1351__)
     31    000000              #include "msp430c1351.h"
     33    000000              #elif defined (__MSP430C311S__)
     34    000000              #include "msp430c311s.h"
     36    000000              #elif defined (__MSP430C312__)
     37    000000              #include "msp430c312.h"
     39    000000              #elif defined (__MSP430C313__)
     40    000000              #include "msp430c313.h"
     42    000000              #elif defined (__MSP430C314__)
     43    000000              #include "msp430c314.h"
     45    000000              #elif defined (__MSP430C315__)
     46    000000              #include "msp430c315.h"
     48    000000              #elif defined (__MSP430C323__)
     49    000000              #include "msp430c323.h"
     51    000000              #elif defined (__MSP430C325__)
     52    000000              #include "msp430c325.h"
     54    000000              #elif defined (__MSP430C336__)
     55    000000              #include "msp430c336.h"
     57    000000              #elif defined (__MSP430C337__)
     58    000000              #include "msp430c337.h"
     60    000000              #elif defined (__MSP430C412__)
     61    000000              #include "msp430c412.h"
     63    000000              #elif defined (__MSP430C413__)
     64    000000              #include "msp430c413.h"
     66    000000              #elif defined (__MSP430CG4616__)
     67    000000              #include "msp430cg4616.h"
     69    000000              #elif defined (__MSP430CG4617__)
     70    000000              #include "msp430cg4617.h"
     72    000000              #elif defined (__MSP430CG4618__)
     73    000000              #include "msp430cg4618.h"
     75    000000              #elif defined (__MSP430CG4619__)
     76    000000              #include "msp430cg4619.h"
     78    000000              #elif defined (__MSP430E112__)
     79    000000              #include "msp430e112.h"
     81    000000              #elif defined (__MSP430E313__)
     82    000000              #include "msp430e313.h"
     84    000000              #elif defined (__MSP430E315__)
     85    000000              #include "msp430e315.h"
     87    000000              #elif defined (__MSP430E325__)
     88    000000              #include "msp430e325.h"
     90    000000              #elif defined (__MSP430E337__)
     91    000000              #include "msp430e337.h"
     93    000000              #elif defined (__MSP430F110__)
     94    000000              #include "msp430f110.h"
     96    000000              #elif defined (__MSP430F1101__)
     97    000000              #include "msp430f1101.h"
     99    000000              #elif defined (__MSP430F1101A__)
    100    000000              #include "msp430f1101a.h"
    102    000000              #elif defined (__MSP430F1111__)
    103    000000              #include "msp430f1111.h"
    105    000000              #elif defined (__MSP430F1111A__)
    106    000000              #include "msp430f1111a.h"
    108    000000              #elif defined (__MSP430F112__)
    109    000000              #include "msp430f112.h"
    111    000000              #elif defined (__MSP430F1121__)
    112    000000              #include "msp430f1121.h"
    114    000000              #elif defined (__MSP430F1121A__)
    115    000000              #include "msp430f1121a.h"
    117    000000              #elif defined (__MSP430F1122__)
    118    000000              #include "msp430f1122.h"
    120    000000              #elif defined (__MSP430F1132__)
    121    000000              #include "msp430f1132.h"
    123    000000              #elif defined (__MSP430F122__)
    124    000000              #include "msp430f122.h"
    126    000000              #elif defined (__MSP430F1222__)
    127    000000              #include "msp430f1222.h"
    129    000000              #elif defined (__MSP430F123__)
    130    000000              #include "msp430f123.h"
    132    000000              #elif defined (__MSP430F1232__)
    133    000000              #include "msp430f1232.h"
    135    000000              #elif defined (__MSP430F133__)
    136    000000              #include "msp430f133.h"
    138    000000              #elif defined (__MSP430F135__)
    139    000000              #include "msp430f135.h"
    141    000000              #elif defined (__MSP430F147__)
    142    000000              #include "msp430f147.h"
    144    000000              #elif defined (__MSP430F148__)
    145    000000              #include "msp430f148.h"
    147    000000              #elif defined (__MSP430F149__)
    148    000000              #include "msp430f149.h"
    150    000000              #elif defined (__MSP430F1471__)
    151    000000              #include "msp430f1471.h"
    153    000000              #elif defined (__MSP430F1481__)
    154    000000              #include "msp430f1481.h"
    156    000000              #elif defined (__MSP430F1491__)
    157    000000              #include "msp430f1491.h"
    159    000000              #elif defined (__MSP430F155__)
    160    000000              #include "msp430f155.h"
    162    000000              #elif defined (__MSP430F156__)
    163    000000              #include "msp430f156.h"
    165    000000              #elif defined (__MSP430F157__)
    166    000000              #include "msp430f157.h"
    168    000000              #elif defined (__MSP430F167__)
    169    000000              #include "msp430f167.h"
    171    000000              #elif defined (__MSP430F168__)
    172    000000              #include "msp430f168.h"
    174    000000              #elif defined (__MSP430F169__)
    175    000000              #include "msp430f169.h"
    177    000000              #elif defined (__MSP430F1610__)
    178    000000              #include "msp430f1610.h"
    180    000000              #elif defined (__MSP430F1611__)
    181    000000              #include "msp430f1611.h"
    183    000000              #elif defined (__MSP430F1612__)
    184    000000              #include "msp430f1612.h"
    186    000000              #elif defined (__MSP430F2001__)
    187    000000              #include "msp430f2001.h"
    189    000000              #elif defined (__MSP430F2011__)
    190    000000              #include "msp430f2011.h"
    192    000000              #elif defined (__MSP430F2002__)
    193    000000              #include "msp430f2002.h"
    195    000000              #elif defined (__MSP430F2012__)
    196    000000              #include "msp430f2012.h"
    198    000000              #elif defined (__MSP430F2003__)
    199    000000              #include "msp430f2003.h"
    201    000000              #elif defined (__MSP430F2013__)
    202    000000              #include "msp430f2013.h"
    204    000000              #elif defined (__MSP430F2101__)
    205    000000              #include "msp430f2101.h"
    207    000000              #elif defined (__MSP430F2111__)
    208    000000              #include "msp430f2111.h"
    210    000000              #elif defined (__MSP430F2121__)
    211    000000              #include "msp430f2121.h"
    213    000000              #elif defined (__MSP430F2131__)
    214    000000              #include "msp430f2131.h"
    216    000000              #elif defined (__MSP430F2112__)
    217    000000              #include "msp430f2112.h"
    219    000000              #elif defined (__MSP430F2122__)
    220    000000              #include "msp430f2122.h"
    222    000000              #elif defined (__MSP430F2132__)
    223    000000              #include "msp430f2132.h"
    225    000000              #elif defined (__MSP430F2232__)
    226    000000              #include "msp430f2232.h"
    228    000000              #elif defined (__MSP430F2252__)
    229    000000              #include "msp430f2252.h"
    231    000000              #elif defined (__MSP430F2272__)
    232    000000              #include "msp430f2272.h"
    234    000000              #elif defined (__MSP430F2234__)
    235    000000              #include "msp430f2234.h"
    237    000000              #elif defined (__MSP430F2254__)
    238    000000              #include "msp430f2254.h"
    240    000000              #elif defined (__MSP430F2274__)
    241    000000              #include "msp430f2274.h"
    243    000000              #elif defined (__MSP430F2330__)
    244    000000              #include "msp430f2330.h"
    246    000000              #elif defined (__MSP430F2350__)
    247    000000              #include "msp430f2350.h"
    249    000000              #elif defined (__MSP430F2370__)
    250    000000              #include "msp430f2370.h"
    252    000000              #elif defined (__MSP430F233__)
    253    000000              #include "msp430f233.h"
    255    000000              #elif defined (__MSP430F235__)
    256    000000              #include "msp430f235.h"
    258    000000              #elif defined (__MSP430F247__)
    259    000000              #include "msp430f247.h"
    261    000000              #elif defined (__MSP430F248__)
    262    000000              #include "msp430f248.h"
    264    000000              #elif defined (__MSP430F249__)
    265    000000              #include "msp430f249.h"
    267    000000              #elif defined (__MSP430F2410__)
    268    000000              #include "msp430f2410.h"
    270    000000              #elif defined (__MSP430F2471__)
    271    000000              #include "msp430f2471.h"
    273    000000              #elif defined (__MSP430F2481__)
    274    000000              #include "msp430f2481.h"
    276    000000              #elif defined (__MSP430F2491__)
    277    000000              #include "msp430f2491.h"
    279    000000              #elif defined (__MSP430F2416__)
    280    000000              #include "msp430f2416.h"
    282    000000              #elif defined (__MSP430F2417__)
    283    000000              #include "msp430f2417.h"
    285    000000              #elif defined (__MSP430F2418__)
    286    000000              #include "msp430f2418.h"
    288    000000              #elif defined (__MSP430F2419__)
    289    000000              #include "msp430f2419.h"
    291    000000              #elif defined (__MSP430F2616__)
    292    000000              #include "msp430f2616.h"
    294    000000              #elif defined (__MSP430F2617__)
    295    000000              #include "msp430f2617.h"
    297    000000              #elif defined (__MSP430F2618__)
    298    000000              #include "msp430f2618.h"
    300    000000              #elif defined (__MSP430F2619__)
    301    000000              #include "msp430f2619.h"
    303    000000              #elif defined (__MSP430F412__)
    304    000000              #include "msp430f412.h"
    306    000000              #elif defined (__MSP430F413__)
    307    000000              #include "msp430f413.h"
    309    000000              #elif defined (__MSP430F415__)
    310    000000              #include "msp430f415.h"
    312    000000              #elif defined (__MSP430F417__)
    313    000000              #include "msp430f417.h"
    315    000000              #elif defined (__MSP430F4132__)
    316    000000              #include "msp430f4132.h"
    318    000000              #elif defined (__MSP430F4152__)
    319    000000              #include "msp430f4152.h"
    321    000000              #elif defined (__MSP430F423__)
    322    000000              #include "msp430f423.h"
    324    000000              #elif defined (__MSP430F425__)
    325    000000              #include "msp430f425.h"
    327    000000              #elif defined (__MSP430F427__)
    328    000000              #include "msp430f427.h"
    330    000000              #elif defined (__MSP430F423A__)
    331    000000              #include "msp430f423a.h"
    333    000000              #elif defined (__MSP430F425A__)
    334    000000              #include "msp430f425a.h"
    336    000000              #elif defined (__MSP430F427A__)
    337    000000              #include "msp430f427a.h"
    339    000000              #elif defined (__MSP430F435__)
    340    000000              #include "msp430f435.h"
    342    000000              #elif defined (__MSP430F436__)
    343    000000              #include "msp430f436.h"
    345    000000              #elif defined (__MSP430F437__)
    346    000000              #include "msp430f437.h"
    348    000000              #elif defined (__MSP430F4351__)
    349    000000              #include "msp430f4351.h"
    351    000000              #elif defined (__MSP430F4361__)
    352    000000              #include "msp430f4361.h"
    354    000000              #elif defined (__MSP430F4371__)
    355    000000              #include "msp430f4371.h"
    357    000000              #elif defined (__MSP430F4481__)
    358    000000              #include "msp430f4481.h"
    360    000000              #elif defined (__MSP430F4491__)
    361    000000              #include "msp430f4491.h"
    363    000000              #elif defined (__MSP430F447__)
    364    000000              #include "msp430f447.h"
    366    000000              #elif defined (__MSP430F448__)
    367    000000              #include "msp430f448.h"
    369    000000              #elif defined (__MSP430F449__)
    370    000000              #include "msp430f449.h"
    372    000000              #elif defined (__MSP430FE423__)
    373    000000              #include "msp430fe423.h"
    375    000000              #elif defined (__MSP430FE425__)
    376    000000              #include "msp430fe425.h"
    378    000000              #elif defined (__MSP430FE427__)
    379    000000              #include "msp430fe427.h"
    381    000000              #elif defined (__MSP430FE423A__)
    382    000000              #include "msp430fe423a.h"
    384    000000              #elif defined (__MSP430FE425A__)
    385    000000              #include "msp430fe425a.h"
    387    000000              #elif defined (__MSP430FE427A__)
    388    000000              #include "msp430fe427a.h"
    390    000000              #elif defined (__MSP430FE4232__)
    391    000000              #include "msp430fe4232.h"
    393    000000              #elif defined (__MSP430FE4242__)
    394    000000              #include "msp430fe4242.h"
    396    000000              #elif defined (__MSP430FE4252__)
    397    000000              #include "msp430fe4252.h"
    399    000000              #elif defined (__MSP430FE4272__)
    400    000000              #include "msp430fe4272.h"
    402    000000              #elif defined (__MSP430F4783__)
    403    000000              #include "msp430f4783.h"
    405    000000              #elif defined (__MSP430F4793__)
    406    000000              #include "msp430f4793.h"
    408    000000              #elif defined (__MSP430F4784__)
    409    000000              #include "msp430f4784.h"
    411    000000              #elif defined (__MSP430F4794__)
    412    000000              #include "msp430f4794.h"
    414    000000              #elif defined (__MSP430F47126__)
    415    000000              #include "msp430f47126.h"
    417    000000              #elif defined (__MSP430F47127__)
    418    000000              #include "msp430f47127.h"
    420    000000              #elif defined (__MSP430F47163__)
    421    000000              #include "msp430f47163.h"
    423    000000              #elif defined (__MSP430F47173__)
    424    000000              #include "msp430f47173.h"
    426    000000              #elif defined (__MSP430F47183__)
    427    000000              #include "msp430f47183.h"
    429    000000              #elif defined (__MSP430F47193__)
    430    000000              #include "msp430f47193.h"
    432    000000              #elif defined (__MSP430F47166__)
    433    000000              #include "msp430f47166.h"
    435    000000              #elif defined (__MSP430F47176__)
    436    000000              #include "msp430f47176.h"
    438    000000              #elif defined (__MSP430F47186__)
    439    000000              #include "msp430f47186.h"
    441    000000              #elif defined (__MSP430F47196__)
    442    000000              #include "msp430f47196.h"
    444    000000              #elif defined (__MSP430F47167__)
    445    000000              #include "msp430f47167.h"
    447    000000              #elif defined (__MSP430F47177__)
    448    000000              #include "msp430f47177.h"
    450    000000              #elif defined (__MSP430F47187__)
    451    000000              #include "msp430f47187.h"
    453    000000              #elif defined (__MSP430F47197__)
    454    000000              #include "msp430f47197.h"
    456    000000              #elif defined (__MSP430F4250__)
    457    000000              #include "msp430f4250.h"
    459    000000              #elif defined (__MSP430F4260__)
    460    000000              #include "msp430f4260.h"
    462    000000              #elif defined (__MSP430F4270__)
    463    000000              #include "msp430f4270.h"
    465    000000              #elif defined (__MSP430FG4250__)
    466    000000              #include "msp430fg4250.h"
    468    000000              #elif defined (__MSP430FG4260__)
    469    000000              #include "msp430fg4260.h"
    471    000000              #elif defined (__MSP430FG4270__)
    472    000000              #include "msp430fg4270.h"
    474    000000              #elif defined (__MSP430FW423__)
    475    000000              #include "msp430fw423.h"
    477    000000              #elif defined (__MSP430FW425__)
    478    000000              #include "msp430fw425.h"
    480    000000              #elif defined (__MSP430FW427__)
    481    000000              #include "msp430fw427.h"
    483    000000              #elif defined (__MSP430FW428__)
    484    000000              #include "msp430fw428.h"
    486    000000              #elif defined (__MSP430FW429__)
    487    000000              #include "msp430fw429.h"
    489    000000              #elif defined (__MSP430FG437__)
    490    000000              #include "msp430fg437.h"
    492    000000              #elif defined (__MSP430FG438__)
    493    000000              #include "msp430fg438.h"
    495    000000              #elif defined (__MSP430FG439__)
    496    000000              #include "msp430fg439.h"
    498    000000              #elif defined (__MSP430F438__)
    499    000000              #include "msp430f438.h"
    501    000000              #elif defined (__MSP430F439__)
    502    000000              #include "msp430f439.h"
    504    000000              #elif defined (__MSP430F477__)
    505    000000              #include "msp430f477.h"
    507    000000              #elif defined (__MSP430F478__)
    508    000000              #include "msp430f478.h"
    510    000000              #elif defined (__MSP430F479__)
    511    000000              #include "msp430f479.h"
    513    000000              #elif defined (__MSP430FG477__)
    514    000000              #include "msp430fg477.h"
    516    000000              #elif defined (__MSP430FG478__)
    517    000000              #include "msp430fg478.h"
    519    000000              #elif defined (__MSP430FG479__)
    520    000000              #include "msp430fg479.h"
    522    000000              #elif defined (__MSP430F46161__)
    523    000000              #include "msp430f46161.h"
    525    000000              #elif defined (__MSP430F46171__)
    526    000000              #include "msp430f46171.h"
    528    000000              #elif defined (__MSP430F46181__)
    529    000000              #include "msp430f46181.h"
    531    000000              #elif defined (__MSP430F46191__)
    532    000000              #include "msp430f46191.h"
    534    000000              #elif defined (__MSP430F4616__)
    535    000000              #include "msp430f4616.h"
    537    000000              #elif defined (__MSP430F4617__)
    538    000000              #include "msp430f4617.h"
    540    000000              #elif defined (__MSP430F4618__)
    541    000000              #include "msp430f4618.h"
    543    000000              #elif defined (__MSP430F4619__)
    544    000000              #include "msp430f4619.h"
    546    000000              #elif defined (__MSP430FG4616__)
    547    000000              #include "msp430fg4616.h"
    549    000000              #elif defined (__MSP430FG4617__)
    550    000000              #include "msp430fg4617.h"
    552    000000              #elif defined (__MSP430FG4618__)
    553    000000              #include "msp430fg4618.h"
    555    000000              #elif defined (__MSP430FG4619__)
    556    000000              #include "msp430fg4619.h"
    558    000000              #elif defined (__MSP430F5418__)
    559    000000              #include "msp430f5418.h"
    561    000000              #elif defined (__MSP430F5419__)
    562    000000              #include "msp430f5419.h"
    564    000000              #elif defined (__MSP430F5435__)
    565    000000              #include "msp430f5435.h"
    567    000000              #elif defined (__MSP430F5436__)
    568    000000              #include "msp430f5436.h"
    570    000000              #elif defined (__MSP430F5437__)
    571    000000              #include "msp430f5437.h"
    573    000000              #elif defined (__MSP430F5438__)
    574    000000              #include "msp430f5438.h"
    576    000000              #elif defined (__XMS430F5438__)
    577    000000              #include "xms430f5438.h"
    579    000000              #elif defined (__MSP430F5418A__)
    580    000000              #include "msp430f5418a.h"
    582    000000              #elif defined (__MSP430F5419A__)
    583    000000              #include "msp430f5419a.h"
    585    000000              #elif defined (__MSP430F5435A__)
    586    000000              #include "msp430f5435a.h"
    588    000000              #elif defined (__MSP430F5436A__)
    589    000000              #include "msp430f5436a.h"
    591    000000              #elif defined (__MSP430F5437A__)
    592    000000              #include "msp430f5437a.h"
    594    000000              #elif defined (__MSP430F5438A__)
    595    000000              #include "msp430f5438a.h"
    597    000000              #elif defined (__MSP430F5304__)
    598    000000              #include "msp430f5304.h"
    600    000000              #elif defined (__MSP430F5308__)
    601    000000              #include "msp430f5308.h"
    603    000000              #elif defined (__MSP430F5309__)
    604    000000              #include "msp430f5309.h"
    606    000000              #elif defined (__MSP430F5310__)
    607    000000              #include "msp430f5310.h"
    609    000000              #elif defined (__MSP430F5340__)
    610    000000              #include "msp430f5340.h"
    612    000000              #elif defined (__MSP430F5341__)
    613    000000              #include "msp430f5341.h"
    615    000000              #elif defined (__MSP430F5342__)
    616    000000              #include "msp430f5342.h"
    618    000000              #elif defined (__MSP430F5324__)
    619    000000              #include "msp430f5324.h"
    621    000000              #elif defined (__MSP430F5325__)
    622    000000              #include "msp430f5325.h"
    624    000000              #elif defined (__MSP430F5326__)
    625    000000              #include "msp430f5326.h"
    627    000000              #elif defined (__MSP430F5327__)
    628    000000              #include "msp430f5327.h"
    630    000000              #elif defined (__MSP430F5328__)
    631    000000              #include "msp430f5328.h"
    633    000000              #elif defined (__MSP430F5329__)
    634    000000              #include "msp430f5329.h"
    636    000000              #elif defined (__MSP430F5500__)
    637    000000              #include "msp430f5500.h"
    639    000000              #elif defined (__MSP430F5501__)
    640    000000              #include "msp430f5501.h"
    642    000000              #elif defined (__MSP430F5502__)
    643    000000              #include "msp430f5502.h"
    645    000000              #elif defined (__MSP430F5503__)
    646    000000              #include "msp430f5503.h"
    648    000000              #elif defined (__MSP430F5504__)
    649    000000              #include "msp430f5504.h"
    651    000000              #elif defined (__MSP430F5505__)
    652    000000              #include "msp430f5505.h"
    654    000000              #elif defined (__MSP430F5506__)
    655    000000              #include "msp430f5506.h"
    657    000000              #elif defined (__MSP430F5507__)
    658    000000              #include "msp430f5507.h"
    660    000000              #elif defined (__MSP430F5508__)
    661    000000              #include "msp430f5508.h"
    663    000000              #elif defined (__MSP430F5509__)
    664    000000              #include "msp430f5509.h"
    666    000000              #elif defined (__MSP430F5510__)
    667    000000              #include "msp430f5510.h"
    669    000000              #elif defined (__MSP430F5513__)
    670    000000              #include "msp430f5513.h"
    672    000000              #elif defined (__MSP430F5514__)
    673    000000              #include "msp430f5514.h"
    675    000000              #elif defined (__MSP430F5515__)
    676    000000              #include "msp430f5515.h"
    678    000000              #elif defined (__MSP430F5517__)
    679    000000              #include "msp430f5517.h"
    681    000000              #elif defined (__MSP430F5519__)
    682    000000              #include "msp430f5519.h"
    684    000000              #elif defined (__MSP430F5521__)
    685    000000              #include "msp430f5521.h"
    687    000000              #elif defined (__MSP430F5522__)
    688    000000              #include "msp430f5522.h"
    690    000000              #elif defined (__MSP430F5524__)
    691    000000              #include "msp430f5524.h"
    693    000000              #elif defined (__MSP430F5525__)
    694    000000              #include "msp430f5525.h"
    696    000000              #elif defined (__MSP430F5526__)
    697    000000              #include "msp430f5526.h"
    699    000000              #elif defined (__MSP430F5527__)
    700    000000              #include "msp430f5527.h"
    702    000000              #elif defined (__MSP430F5528__)
    703    000000              #include "msp430f5528.h"
    705    000000              #elif defined (__MSP430F5529__)
    706    000000              #include "msp430f5529.h"
    708    000000              #elif defined (__MSP430P112__)
    709    000000              #include "msp430p112.h"
    711    000000              #elif defined (__MSP430P313__)
    712    000000              #include "msp430p313.h"
    714    000000              #elif defined (__MSP430P315__)
    715    000000              #include "msp430p315.h"
    717    000000              #elif defined (__MSP430P315S__)
    718    000000              #include "msp430p315s.h"
    720    000000              #elif defined (__MSP430P325__)
    721    000000              #include "msp430p325.h"
    723    000000              #elif defined (__MSP430P337__)
    724    000000              #include "msp430p337.h"
    726    000000              #elif defined (__CC430F5133__)
    727    000000              #include "cc430f5133.h"
    729    000000              #elif defined (__CC430F5135__)
    730    000000              #include "cc430f5135.h"
    732    000000              #elif defined (__CC430F5137__)
    733    000000              #include "cc430f5137.h"
    735    000000              #elif defined (__CC430F6125__)
    736    000000              #include "cc430f6125.h"
    738    000000              #elif defined (__CC430F6126__)
    739    000000              #include "cc430f6126.h"
    741    000000              #elif defined (__CC430F6127__)
    742    000000              #include "cc430f6127.h"
    744    000000              #elif defined (__CC430F6135__)
    745    000000              #include "cc430f6135.h"
    747    000000              #elif defined (__CC430F6137__)
    748    000000              #include "cc430f6137.h"
    750    000000              #elif defined (__MSP430F5630__)
    751    000000              #include "msp430f5630.h"
    753    000000              #elif defined (__MSP430F5631__)
    754    000000              #include "msp430f5631.h"
    756    000000              #elif defined (__MSP430F5632__)
    757    000000              #include "msp430f5632.h"
    759    000000              #elif defined (__MSP430F5633__)
    760    000000              #include "msp430f5633.h"
    762    000000              #elif defined (__MSP430F5634__)
    763    000000              #include "msp430f5634.h"
    765    000000              #elif defined (__MSP430F5635__)
    766    000000              #include "msp430f5635.h"
    768    000000              #elif defined (__MSP430F5636__)
    769    000000              #include "msp430f5636.h"
    771    000000              #elif defined (__MSP430F5637__)
    772    000000              #include "msp430f5637.h"
    774    000000              #elif defined (__MSP430F5638__)
    775    000000              #include "msp430f5638.h"
    777    000000              #elif defined (__MSP430F6630__)
    778    000000              #include "msp430f6630.h"
    780    000000              #elif defined (__MSP430F6631__)
    781    000000              #include "msp430f6631.h"
    783    000000              #elif defined (__MSP430F6632__)
    784    000000              #include "msp430f6632.h"
    786    000000              #elif defined (__MSP430F6633__)
    787    000000              #include "msp430f6633.h"
    789    000000              #elif defined (__MSP430F6634__)
    790    000000              #include "msp430f6634.h"
    792    000000              #elif defined (__MSP430F6635__)
    793    000000              #include "msp430f6635.h"
    795    000000              #elif defined (__MSP430F6636__)
    796    000000              #include "msp430f6636.h"
    798    000000              #elif defined (__MSP430F6637__)
    799    000000              #include "msp430f6637.h"
    801    000000              #elif defined (__MSP430F6638__)
    802    000000              #include "msp430f6638.h"
    804    000000              #elif defined (__MSP430L092__)
    805    000000              #include "msp430l092.h"
    807    000000              #elif defined (__MSP430C091__)
    808    000000              #include "msp430c091.h"
    810    000000              #elif defined (__MSP430C092__)
    811    000000              #include "msp430c092.h"
    813    000000              #elif defined (__MSP430F5131__)
    814    000000              #include "msp430f5131.h"
    816    000000              #elif defined (__MSP430F5151__)
    817    000000              #include "msp430f5151.h"
    819    000000              #elif defined (__MSP430F5171__)
    820    000000              #include "msp430f5171.h"
    822    000000              #elif defined (__MSP430F5132__)
    823    000000              #include "msp430f5132.h"
    825    000000              #elif defined (__MSP430F5152__)
    826    000000              #include "msp430f5152.h"
    828    000000              #elif defined (__MSP430F5172__)
    829    000000              #include "msp430f5172.h"
    831    000000              #elif defined (__MSP430FR5720__)
    832    000000              #include "msp430fr5720.h"
    834    000000              #elif defined (__MSP430FR5725__)
    835    000000              #include "msp430fr5725.h"
    837    000000              #elif defined (__MSP430FR5728__)
    838    000000              #include "msp430fr5728.h"
    840    000000              #elif defined (__MSP430FR5729__)
    841    000000              #include "msp430fr5729.h"
    843    000000              #elif defined (__MSP430FR5730__)
    844    000000              #include "msp430fr5730.h"
    846    000000              #elif defined (__MSP430FR5735__)
    847    000000              #include "msp430fr5735.h"
    849    000000              #elif defined (__MSP430FR5738__)
    850    000000              #include "msp430fr5738.h"
    852    000000              #elif defined (__MSP430FR5739__)
    853    000000              #include "msp430fr5739.h"
    855    000000              #elif defined (__MSP430G2211__)
    856    000000              #include "msp430g2211.h"
    858    000000              #elif defined (__MSP430G2201__)
    859    000000              #include "msp430g2201.h"
    861    000000              #elif defined (__MSP430G2111__)
    862    000000              #include "msp430g2111.h"
    864    000000              #elif defined (__MSP430G2101__)
    865    000000              #include "msp430g2101.h"
    867    000000              #elif defined (__MSP430G2001__)
    868    000000              #include "msp430g2001.h"
    870    000000              #elif defined (__MSP430G2231__)
    871    000000              #include "msp430g2231.h"
    873    000000              #elif defined (__MSP430G2221__)
    874    000000              #include "msp430g2221.h"
    876    000000              #elif defined (__MSP430G2131__)
    877    000000              #include "msp430g2131.h"
    879    000000              #elif defined (__MSP430G2121__)
    880    000000              #include "msp430g2121.h"
    882    000000              #elif defined (__MSP430AFE221__)
    883    000000              #include "msp430afe221.h"
    885    000000              #elif defined (__MSP430AFE231__)
    886    000000              #include "msp430afe231.h"
    888    000000              #elif defined (__MSP430AFE251__)
    889    000000              #include "msp430afe251.h"
    891    000000              #elif defined (__MSP430AFE222__)
    892    000000              #include "msp430afe222.h"
    894    000000              #elif defined (__MSP430AFE232__)
    895    000000              #include "msp430afe232.h"
    897    000000              #elif defined (__MSP430AFE252__)
    898    000000              #include "msp430afe252.h"
    900    000000              #elif defined (__MSP430AFE223__)
    901    000000              #include "msp430afe223.h"
    903    000000              #elif defined (__MSP430AFE233__)
    904    000000              #include "msp430afe233.h"
    906    000000              #elif defined (__MSP430AFE253__)
    907    000000              #include "msp430afe253.h"
    909    000000              #elif defined (__MSP430G2102__)
    910    000000              #include "msp430g2102.h"
    912    000000              #elif defined (__MSP430G2202__)
    913    000000              #include "msp430g2202.h"
    915    000000              #elif defined (__MSP430G2302__)
    916    000000              #include "msp430g2302.h"
    918    000000              #elif defined (__MSP430G2402__)
    919    000000              #include "msp430g2402.h"
    921    000000              #elif defined (__MSP430G2132__)
    922    000000              #include "msp430g2132.h"
    924    000000              #elif defined (__MSP430G2232__)
    925    000000              #include "msp430g2232.h"
    927    000000              #elif defined (__MSP430G2332__)
    928    000000              #include "msp430g2332.h"
    930    000000              #elif defined (__MSP430G2432__)
    931    000000              #include "msp430g2432.h"
    933    000000              #elif defined (__MSP430G2112__)
    934    000000              #include "msp430g2112.h"
    936    000000              #elif defined (__MSP430G2212__)
    937    000000              #include "msp430g2212.h"
    939    000000              #elif defined (__MSP430G2312__)
    940    000000              #include "msp430g2312.h"
    942    000000              #elif defined (__MSP430G2412__)
    943    000000              #include "msp430g2412.h"
    945    000000              #elif defined (__MSP430G2152__)
    946    000000              #include "msp430g2152.h"
    948    000000              #elif defined (__MSP430G2252__)
    949    000000              #include "msp430g2252.h"
    951    000000              #elif defined (__MSP430G2352__)
    952    000000              #include "msp430g2352.h"
    954    000000              #elif defined (__MSP430G2452__)
    955    000000              #include "msp430g2452.h"
    957    000000              #elif defined (__MSP430G2113__)
    958    000000              #include "msp430g2113.h"
    960    000000              #elif defined (__MSP430G2213__)
    961    000000              #include "msp430g2213.h"
    963    000000              #elif defined (__MSP430G2313__)
    964    000000              #include "msp430g2313.h"
    966    000000              #elif defined (__MSP430G2413__)
    967    000000              #include "msp430g2413.h"
    969    000000              #elif defined (__MSP430G2513__)
    970    000000              #include "msp430g2513.h"
    972    000000              #elif defined (__MSP430G2153__)
    973    000000              #include "msp430g2153.h"
    975    000000              #elif defined (__MSP430G2253__)
    976    000000              #include "msp430g2253.h"
    978    000000              #elif defined (__MSP430G2353__)
    979    000000              #include "msp430g2353.h"
    981    000000              #elif defined (__MSP430G2453__)
    982    000000              #include "msp430g2453.h"
    984    000000              #elif defined (__MSP430G2553__)
    985    000000              #include "msp430g2553.h"
      1    000000              /***********************************************
                               *********************
      2    000000              *
      3    000000              * Standard register and bit definitions for the
                                Texas Instruments
      4    000000              * MSP430 microcontroller.
      5    000000              *
      6    000000              * This file supports assembler and C development
                                for
      7    000000              * MSP430G2553 devices.
      8    000000              *
      9    000000              * Texas Instruments, Version 1.0
     10    000000              *
     11    000000              * Rev. 1.0, Setup
     12    000000              *
     13    000000              ************************************************
                               ********************/
     14    000000              
     15    000000              #ifndef __MSP430G2553
     16    000000              #define __MSP430G2553
     17    000000              
     18    000000              #ifdef  __IAR_SYSTEMS_ICC__
     19    000000              #ifndef _SYSTEM_BUILD
     20    000000              #pragma system_include
     21    000000              #endif
     22    000000              #endif
     23    000000              
     24    000000              #if (((__TID__ >> 8) & 0x7F) != 0x2b)     /*
                                0x2b = 43 dec */
     25    000000              #error msp430g2553.h file for use with
                                ICC430/A430 only
     26    000000              #endif
     27    000000              
     28    000000              
     29    000000              #ifdef __IAR_SYSTEMS_ICC__
     30    000000              #include "in430.h"
     31    000000              #pragma language=extended
     33    000000              #define DEFC(name, address) __no_init volatile
                                unsigned char name @ address;
     34    000000              #define DEFW(name, address) __no_init volatile
                                unsigned short name @ address;
     35    000000              #define DEFXC  volatile unsigned char
     36    000000              #define DEFXW  volatile unsigned short
     38    000000              #endif  /* __IAR_SYSTEMS_ICC__  */
     39    000000              
     40    000000              
     41    000000              #ifdef __IAR_SYSTEMS_ASM__
     42    000000              #define DEFC(name, address) sfrb name =
                                address;
     43    000000              #define DEFW(name, address) sfrw name =
                                address;
     44    000000              
     45    000000              #endif /* __IAR_SYSTEMS_ASM__*/
     46    000000              
     47    000000              #ifdef __cplusplus
     48    000000              #define READ_ONLY
     49    000000              #else
     50    000000              #define READ_ONLY const
     51    000000              #endif
     52    000000              
     53    000000              /***********************************************
                               *************
     54    000000              * STANDARD BITS
     55    000000              ************************************************
                               ************/
     56    000000              
     57    000000              #define BIT0                (0x0001u)
     58    000000              #define BIT1                (0x0002u)
     59    000000              #define BIT2                (0x0004u)
     60    000000              #define BIT3                (0x0008u)
     61    000000              #define BIT4                (0x0010u)
     62    000000              #define BIT5                (0x0020u)
     63    000000              #define BIT6                (0x0040u)
     64    000000              #define BIT7                (0x0080u)
     65    000000              #define BIT8                (0x0100u)
     66    000000              #define BIT9                (0x0200u)
     67    000000              #define BITA                (0x0400u)
     68    000000              #define BITB                (0x0800u)
     69    000000              #define BITC                (0x1000u)
     70    000000              #define BITD                (0x2000u)
     71    000000              #define BITE                (0x4000u)
     72    000000              #define BITF                (0x8000u)
     73    000000              
     74    000000              /***********************************************
                               *************
     75    000000              * STATUS REGISTER BITS
     76    000000              ************************************************
                               ************/
     77    000000              
     78    000000              #define C                   (0x0001u)
     79    000000              #define Z                   (0x0002u)
     80    000000              #define N                   (0x0004u)
     81    000000              #define V                   (0x0100u)
     82    000000              #define GIE                 (0x0008u)
     83    000000              #define CPUOFF              (0x0010u)
     84    000000              #define OSCOFF              (0x0020u)
     85    000000              #define SCG0                (0x0040u)
     86    000000              #define SCG1                (0x0080u)
     87    000000              
     88    000000              /* Low Power Modes coded with Bits 4-7 in SR
                                */
     89    000000              
     90    000000              #ifndef __IAR_SYSTEMS_ICC__ /* Begin #defines
                                for assembler */
     91    000000              #define LPM0                (CPUOFF)
     92    000000              #define LPM1                (SCG0+CPUOFF)
     93    000000              #define LPM2                (SCG1+CPUOFF)
     94    000000              #define LPM3                (SCG1+SCG0+CPUOFF)
     95    000000              #define LPM4                (SCG1+SCG0+OSCOFF+CP
                               UOFF)
     96    000000              /* End #defines for assembler */
     97    000000              
     98    000000              #else /* Begin #defines for C */
     99    000000              #define LPM0_bits           (CPUOFF)
    100    000000              #define LPM1_bits           (SCG0+CPUOFF)
    101    000000              #define LPM2_bits           (SCG1+CPUOFF)
    102    000000              #define LPM3_bits           (SCG1+SCG0+CPUOFF)
    103    000000              #define LPM4_bits           (SCG1+SCG0+OSCOFF+CP
                               UOFF)
    105    000000              #include "in430.h"
    107    000000              #define LPM0      _BIS_SR(LPM0_bits)     /*
                                Enter Low Power Mode 0 */
    108    000000              #define LPM0_EXIT _BIC_SR_IRQ(LPM0_bits) /* Exit
                                Low Power Mode 0 */
    109    000000              #define LPM1      _BIS_SR(LPM1_bits)     /*
                                Enter Low Power Mode 1 */
    110    000000              #define LPM1_EXIT _BIC_SR_IRQ(LPM1_bits) /* Exit
                                Low Power Mode 1 */
    111    000000              #define LPM2      _BIS_SR(LPM2_bits)     /*
                                Enter Low Power Mode 2 */
    112    000000              #define LPM2_EXIT _BIC_SR_IRQ(LPM2_bits) /* Exit
                                Low Power Mode 2 */
    113    000000              #define LPM3      _BIS_SR(LPM3_bits)     /*
                                Enter Low Power Mode 3 */
    114    000000              #define LPM3_EXIT _BIC_SR_IRQ(LPM3_bits) /* Exit
                                Low Power Mode 3 */
    115    000000              #define LPM4      _BIS_SR(LPM4_bits)     /*
                                Enter Low Power Mode 4 */
    116    000000              #define LPM4_EXIT _BIC_SR_IRQ(LPM4_bits) /* Exit
                                Low Power Mode 4 */
    117    000000              #endif /* End #defines for C */
    118    000000              
    119    000000              /***********************************************
                               *************
    120    000000              * PERIPHERAL FILE MAP
    121    000000              ************************************************
                               ************/
    122    000000              
    123    000000              /***********************************************
                               *************
    124    000000              * SPECIAL FUNCTION REGISTER ADDRESSES + CONTROL
                                BITS
    125    000000              ************************************************
                               ************/
    126    000000              
    127    000000              #define IE1_                (0x0000u)  /*
                                Interrupt Enable 1 */
    128    000000              DEFC(   IE1               , IE1_)
    129    000000              #define WDTIE               (0x01)    /*
                                Watchdog Interrupt Enable */
    130    000000              #define OFIE                (0x02)    /* Osc.
                                Fault  Interrupt Enable */
    131    000000              #define NMIIE               (0x10)    /* NMI
                                Interrupt Enable */
    132    000000              #define ACCVIE              (0x20)    /* Flash
                                Access Violation Interrupt Enable */
    133    000000              
    134    000000              #define IFG1_               (0x0002u)  /*
                                Interrupt Flag 1 */
    135    000000              DEFC(   IFG1              , IFG1_)
    136    000000              #define WDTIFG              (0x01)    /*
                                Watchdog Interrupt Flag */
    137    000000              #define OFIFG               (0x02)    /* Osc.
                                Fault Interrupt Flag */
    138    000000              #define PORIFG              (0x04)    /* Power
                                On Interrupt Flag */
    139    000000              #define RSTIFG              (0x08)    /* Reset
                                Interrupt Flag */
    140    000000              #define NMIIFG              (0x10)    /* NMI
                                Interrupt Flag */
    141    000000              
    142    000000              #define IE2_                (0x0001u)  /*
                                Interrupt Enable 2 */
    143    000000              DEFC(   IE2               , IE2_)
    144    000000              #define UC0IE               IE2
    145    000000              #define UCA0RXIE            (0x01)
    146    000000              #define UCA0TXIE            (0x02)
    147    000000              #define UCB0RXIE            (0x04)
    148    000000              #define UCB0TXIE            (0x08)
    149    000000              
    150    000000              #define IFG2_               (0x0003u)  /*
                                Interrupt Flag 2 */
    151    000000              DEFC(   IFG2              , IFG2_)
    152    000000              #define UC0IFG              IFG2
    153    000000              #define UCA0RXIFG           (0x01)
    154    000000              #define UCA0TXIFG           (0x02)
    155    000000              #define UCB0RXIFG           (0x04)
    156    000000              #define UCB0TXIFG           (0x08)
    157    000000              
    158    000000              /***********************************************
                               *************
    159    000000              * ADC10
    160    000000              ************************************************
                               ************/
    161    000000              #define __MSP430_HAS_ADC10__            /*
                                Definition to show that Module is available
                                */
    162    000000              
    163    000000              #define ADC10DTC0_          (0x0048u)    /*
                                ADC10 Data Transfer Control 0 */
    164    000000              DEFC(   ADC10DTC0         , ADC10DTC0_)
    165    000000              #define ADC10DTC1_          (0x0049u)    /*
                                ADC10 Data Transfer Control 1 */
    166    000000              DEFC(   ADC10DTC1         , ADC10DTC1_)
    167    000000              #define ADC10AE0_           (0x004Au)    /*
                                ADC10 Analog Enable 0 */
    168    000000              DEFC(   ADC10AE0          , ADC10AE0_)
    169    000000              
    170    000000              #define ADC10CTL0_          (0x01B0u)    /*
                                ADC10 Control 0 */
    171    000000              DEFW(   ADC10CTL0         , ADC10CTL0_)
    172    000000              #define ADC10CTL1_          (0x01B2u)    /*
                                ADC10 Control 1 */
    173    000000              DEFW(   ADC10CTL1         , ADC10CTL1_)
    174    000000              #define ADC10MEM_           (0x01B4u)    /*
                                ADC10 Memory */
    175    000000              DEFW(   ADC10MEM          , ADC10MEM_)
    176    000000              #define ADC10SA_            (0x01BCu)    /*
                                ADC10 Data Transfer Start Address */
    177    000000              DEFW(   ADC10SA           , ADC10SA_)
    178    000000              
    179    000000              /* ADC10CTL0 */
    180    000000              #define ADC10SC             (0x001)     /* ADC10
                                Start Conversion */
    181    000000              #define ENC                 (0x002)     /* ADC10
                                Enable Conversion */
    182    000000              #define ADC10IFG            (0x004)     /* ADC10
                                Interrupt Flag */
    183    000000              #define ADC10IE             (0x008)     /* ADC10
                                Interrupt Enalbe */
    184    000000              #define ADC10ON             (0x010)     /* ADC10
                                On/Enable */
    185    000000              #define REFON               (0x020)     /* ADC10
                                Reference on */
    186    000000              #define REF2_5V             (0x040)     /* ADC10
                                Ref 0:1.5V / 1:2.5V */
    187    000000              #define MSC                 (0x080)     /* ADC10
                                Multiple SampleConversion */
    188    000000              #define REFBURST            (0x100)     /* ADC10
                                Reference Burst Mode */
    189    000000              #define REFOUT              (0x200)     /* ADC10
                                Enalbe output of Ref. */
    190    000000              #define ADC10SR             (0x400)     /* ADC10
                                Sampling Rate 0:200ksps / 1:50ksps */
    191    000000              #define ADC10SHT0           (0x800)     /* ADC10
                                Sample Hold Select Bit: 0 */
    192    000000              #define ADC10SHT1           (0x1000u)    /*
                                ADC10 Sample Hold Select Bit: 1 */
    193    000000              #define SREF0               (0x2000u)    /*
                                ADC10 Reference Select Bit: 0 */
    194    000000              #define SREF1               (0x4000u)    /*
                                ADC10 Reference Select Bit: 1 */
    195    000000              #define SREF2               (0x8000u)    /*
                                ADC10 Reference Select Bit: 2 */
    196    000000              #define ADC10SHT_0          (0*0x800u)   /* 4 x
                                ADC10CLKs */
    197    000000              #define ADC10SHT_1          (1*0x800u)   /* 8 x
                                ADC10CLKs */
    198    000000              #define ADC10SHT_2          (2*0x800u)   /* 16 x
                                ADC10CLKs */
    199    000000              #define ADC10SHT_3          (3*0x800u)   /* 64 x
                                ADC10CLKs */
    200    000000              
    201    000000              #define SREF_0              (0*0x2000u)  /* VR+
                                = AVCC and VR- = AVSS */
    202    000000              #define SREF_1              (1*0x2000u)  /* VR+
                                = VREF+ and VR- = AVSS */
    203    000000              #define SREF_2              (2*0x2000u)  /* VR+
                                = VEREF+ and VR- = AVSS */
    204    000000              #define SREF_3              (3*0x2000u)  /* VR+
                                = VEREF+ and VR- = AVSS */
    205    000000              #define SREF_4              (4*0x2000u)  /* VR+
                                = AVCC and VR- = VREF-/VEREF- */
    206    000000              #define SREF_5              (5*0x2000u)  /* VR+
                                = VREF+ and VR- = VREF-/VEREF- */
    207    000000              #define SREF_6              (6*0x2000u)  /* VR+
                                = VEREF+ and VR- = VREF-/VEREF- */
    208    000000              #define SREF_7              (7*0x2000u)  /* VR+
                                = VEREF+ and VR- = VREF-/VEREF- */
    209    000000              
    210    000000              /* ADC10CTL1 */
    211    000000              #define ADC10BUSY           (0x0001u)    /*
                                ADC10 BUSY */
    212    000000              #define CONSEQ0             (0x0002u)    /*
                                ADC10 Conversion Sequence Select 0 */
    213    000000              #define CONSEQ1             (0x0004u)    /*
                                ADC10 Conversion Sequence Select 1 */
    214    000000              #define ADC10SSEL0          (0x0008u)    /*
                                ADC10 Clock Source Select Bit: 0 */
    215    000000              #define ADC10SSEL1          (0x0010u)    /*
                                ADC10 Clock Source Select Bit: 1 */
    216    000000              #define ADC10DIV0           (0x0020u)    /*
                                ADC10 Clock Divider Select Bit: 0 */
    217    000000              #define ADC10DIV1           (0x0040u)    /*
                                ADC10 Clock Divider Select Bit: 1 */
    218    000000              #define ADC10DIV2           (0x0080u)    /*
                                ADC10 Clock Divider Select Bit: 2 */
    219    000000              #define ISSH                (0x0100u)    /*
                                ADC10 Invert Sample Hold Signal */
    220    000000              #define ADC10DF             (0x0200u)    /*
                                ADC10 Data Format 0:binary 1:2's complement
                                */
    221    000000              #define SHS0                (0x0400u)    /*
                                ADC10 Sample/Hold Source Bit: 0 */
    222    000000              #define SHS1                (0x0800u)    /*
                                ADC10 Sample/Hold Source Bit: 1 */
    223    000000              #define INCH0               (0x1000u)    /*
                                ADC10 Input Channel Select Bit: 0 */
    224    000000              #define INCH1               (0x2000u)    /*
                                ADC10 Input Channel Select Bit: 1 */
    225    000000              #define INCH2               (0x4000u)    /*
                                ADC10 Input Channel Select Bit: 2 */
    226    000000              #define INCH3               (0x8000u)    /*
                                ADC10 Input Channel Select Bit: 3 */
    227    000000              
    228    000000              #define CONSEQ_0            (0*2u)       /*
                                Single channel single conversion */
    229    000000              #define CONSEQ_1            (1*2u)       /*
                                Sequence of channels */
    230    000000              #define CONSEQ_2            (2*2u)       /*
                                Repeat single channel */
    231    000000              #define CONSEQ_3            (3*2u)       /*
                                Repeat sequence of channels */
    232    000000              
    233    000000              #define ADC10SSEL_0         (0*8u)       /*
                                ADC10OSC */
    234    000000              #define ADC10SSEL_1         (1*8u)       /* ACLK
                                */
    235    000000              #define ADC10SSEL_2         (2*8u)       /* MCLK
                                */
    236    000000              #define ADC10SSEL_3         (3*8u)       /*
                                SMCLK */
    237    000000              
    238    000000              #define ADC10DIV_0          (0*0x20u)    /*
                                ADC10 Clock Divider Select 0 */
    239    000000              #define ADC10DIV_1          (1*0x20u)    /*
                                ADC10 Clock Divider Select 1 */
    240    000000              #define ADC10DIV_2          (2*0x20u)    /*
                                ADC10 Clock Divider Select 2 */
    241    000000              #define ADC10DIV_3          (3*0x20u)    /*
                                ADC10 Clock Divider Select 3 */
    242    000000              #define ADC10DIV_4          (4*0x20u)    /*
                                ADC10 Clock Divider Select 4 */
    243    000000              #define ADC10DIV_5          (5*0x20u)    /*
                                ADC10 Clock Divider Select 5 */
    244    000000              #define ADC10DIV_6          (6*0x20u)    /*
                                ADC10 Clock Divider Select 6 */
    245    000000              #define ADC10DIV_7          (7*0x20u)    /*
                                ADC10 Clock Divider Select 7 */
    246    000000              
    247    000000              #define SHS_0               (0*0x400u)   /*
                                ADC10SC */
    248    000000              #define SHS_1               (1*0x400u)   /* TA3
                                OUT1 */
    249    000000              #define SHS_2               (2*0x400u)   /* TA3
                                OUT0 */
    250    000000              #define SHS_3               (3*0x400u)   /* TA3
                                OUT2 */
    251    000000              
    252    000000              #define INCH_0              (0*0x1000u)  /*
                                Selects Channel 0 */
    253    000000              #define INCH_1              (1*0x1000u)  /*
                                Selects Channel 1 */
    254    000000              #define INCH_2              (2*0x1000u)  /*
                                Selects Channel 2 */
    255    000000              #define INCH_3              (3*0x1000u)  /*
                                Selects Channel 3 */
    256    000000              #define INCH_4              (4*0x1000u)  /*
                                Selects Channel 4 */
    257    000000              #define INCH_5              (5*0x1000u)  /*
                                Selects Channel 5 */
    258    000000              #define INCH_6              (6*0x1000u)  /*
                                Selects Channel 6 */
    259    000000              #define INCH_7              (7*0x1000u)  /*
                                Selects Channel 7 */
    260    000000              #define INCH_8              (8*0x1000u)  /*
                                Selects Channel 8 */
    261    000000              #define INCH_9              (9*0x1000u)  /*
                                Selects Channel 9 */
    262    000000              #define INCH_10             (10*0x1000u) /*
                                Selects Channel 10 */
    263    000000              #define INCH_11             (11*0x1000u) /*
                                Selects Channel 11 */
    264    000000              #define INCH_12             (12*0x1000u) /*
                                Selects Channel 12 */
    265    000000              #define INCH_13             (13*0x1000u) /*
                                Selects Channel 13 */
    266    000000              #define INCH_14             (14*0x1000u) /*
                                Selects Channel 14 */
    267    000000              #define INCH_15             (15*0x1000u) /*
                                Selects Channel 15 */
    268    000000              
    269    000000              /* ADC10DTC0 */
    270    000000              #define ADC10FETCH          (0x001)     /* This
                                bit should normally be reset */
    271    000000              #define ADC10B1             (0x002)     /* ADC10
                                block one */
    272    000000              #define ADC10CT             (0x004)     /* ADC10
                                continuous transfer */
    273    000000              #define ADC10TB             (0x008)     /* ADC10
                                two-block mode */
    274    000000              #define ADC10DISABLE        (0x000)     /*
                                ADC10DTC1 */
    275    000000              
    276    000000              /***********************************************
                               *************
    277    000000              * Basic Clock Module
    278    000000              ************************************************
                               ************/
    279    000000              #define __MSP430_HAS_BC2__            /*
                                Definition to show that Module is available
                                */
    280    000000              
    281    000000              #define DCOCTL_             (0x0056u)  /* DCO
                                Clock Frequency Control */
    282    000000              DEFC(   DCOCTL            , DCOCTL_)
    283    000000              #define BCSCTL1_            (0x0057u)  /* Basic
                                Clock System Control 1 */
    284    000000              DEFC(   BCSCTL1           , BCSCTL1_)
    285    000000              #define BCSCTL2_            (0x0058u)  /* Basic
                                Clock System Control 2 */
    286    000000              DEFC(   BCSCTL2           , BCSCTL2_)
    287    000000              #define BCSCTL3_            (0x0053u)  /* Basic
                                Clock System Control 3 */
    288    000000              DEFC(   BCSCTL3           , BCSCTL3_)
    289    000000              
    290    000000              #define MOD0                (0x01)   /*
                                Modulation Bit 0 */
    291    000000              #define MOD1                (0x02)   /*
                                Modulation Bit 1 */
    292    000000              #define MOD2                (0x04)   /*
                                Modulation Bit 2 */
    293    000000              #define MOD3                (0x08)   /*
                                Modulation Bit 3 */
    294    000000              #define MOD4                (0x10)   /*
                                Modulation Bit 4 */
    295    000000              #define DCO0                (0x20)   /* DCO
                                Select Bit 0 */
    296    000000              #define DCO1                (0x40)   /* DCO
                                Select Bit 1 */
    297    000000              #define DCO2                (0x80)   /* DCO
                                Select Bit 2 */
    298    000000              
    299    000000              #define RSEL0               (0x01)   /* Range
                                Select Bit 0 */
    300    000000              #define RSEL1               (0x02)   /* Range
                                Select Bit 1 */
    301    000000              #define RSEL2               (0x04)   /* Range
                                Select Bit 2 */
    302    000000              #define RSEL3               (0x08)   /* Range
                                Select Bit 3 */
    303    000000              #define DIVA0               (0x10)   /* ACLK
                                Divider 0 */
    304    000000              #define DIVA1               (0x20)   /* ACLK
                                Divider 1 */
    305    000000              #define XTS                 (0x40)   /* LFXTCLK
                                0:Low Freq. / 1: High Freq. */
    306    000000              #define XT2OFF              (0x80)   /* Enable
                                XT2CLK */
    307    000000              
    308    000000              #define DIVA_0              (0x00)   /* ACLK
                                Divider 0: /1 */
    309    000000              #define DIVA_1              (0x10)   /* ACLK
                                Divider 1: /2 */
    310    000000              #define DIVA_2              (0x20)   /* ACLK
                                Divider 2: /4 */
    311    000000              #define DIVA_3              (0x30)   /* ACLK
                                Divider 3: /8 */
    312    000000              
    313    000000              #define DIVS0               (0x02)   /* SMCLK
                                Divider 0 */
    314    000000              #define DIVS1               (0x04)   /* SMCLK
                                Divider 1 */
    315    000000              #define SELS                (0x08)   /* SMCLK
                                Source Select 0:DCOCLK / 1:XT2CLK/LFXTCLK
                                */
    316    000000              #define DIVM0               (0x10)   /* MCLK
                                Divider 0 */
    317    000000              #define DIVM1               (0x20)   /* MCLK
                                Divider 1 */
    318    000000              #define SELM0               (0x40)   /* MCLK
                                Source Select 0 */
    319    000000              #define SELM1               (0x80)   /* MCLK
                                Source Select 1 */
    320    000000              
    321    000000              #define DIVS_0              (0x00)   /* SMCLK
                                Divider 0: /1 */
    322    000000              #define DIVS_1              (0x02)   /* SMCLK
                                Divider 1: /2 */
    323    000000              #define DIVS_2              (0x04)   /* SMCLK
                                Divider 2: /4 */
    324    000000              #define DIVS_3              (0x06)   /* SMCLK
                                Divider 3: /8 */
    325    000000              
    326    000000              #define DIVM_0              (0x00)   /* MCLK
                                Divider 0: /1 */
    327    000000              #define DIVM_1              (0x10)   /* MCLK
                                Divider 1: /2 */
    328    000000              #define DIVM_2              (0x20)   /* MCLK
                                Divider 2: /4 */
    329    000000              #define DIVM_3              (0x30)   /* MCLK
                                Divider 3: /8 */
    330    000000              
    331    000000              #define SELM_0              (0x00)   /* MCLK
                                Source Select 0: DCOCLK */
    332    000000              #define SELM_1              (0x40)   /* MCLK
                                Source Select 1: DCOCLK */
    333    000000              #define SELM_2              (0x80)   /* MCLK
                                Source Select 2: XT2CLK/LFXTCLK */
    334    000000              #define SELM_3              (0xC0)   /* MCLK
                                Source Select 3: LFXTCLK */
    335    000000              
    336    000000              #define LFXT1OF             (0x01)   /* Low/high
                                Frequency Oscillator Fault Flag */
    337    000000              #define XT2OF               (0x02)   /* High
                                frequency oscillator 2 fault flag */
    338    000000              #define XCAP0               (0x04)   /* XIN/XOUT
                                Cap 0 */
    339    000000              #define XCAP1               (0x08)   /* XIN/XOUT
                                Cap 1 */
    340    000000              #define LFXT1S0             (0x10)   /* Mode 0
                                for LFXT1 (XTS = 0) */
    341    000000              #define LFXT1S1             (0x20)   /* Mode 1
                                for LFXT1 (XTS = 0) */
    342    000000              #define XT2S0               (0x40)   /* Mode 0
                                for XT2 */
    343    000000              #define XT2S1               (0x80)   /* Mode 1
                                for XT2 */
    344    000000              
    345    000000              #define XCAP_0              (0x00)   /* XIN/XOUT
                                Cap : 0 pF */
    346    000000              #define XCAP_1              (0x04)   /* XIN/XOUT
                                Cap : 6 pF */
    347    000000              #define XCAP_2              (0x08)   /* XIN/XOUT
                                Cap : 10 pF */
    348    000000              #define XCAP_3              (0x0C)   /* XIN/XOUT
                                Cap : 12.5 pF */
    349    000000              
    350    000000              #define LFXT1S_0            (0x00)   /* Mode 0
                                for LFXT1 : Normal operation */
    351    000000              #define LFXT1S_1            (0x10)   /* Mode 1
                                for LFXT1 : Reserved */
    352    000000              #define LFXT1S_2            (0x20)   /* Mode 2
                                for LFXT1 : VLO */
    353    000000              #define LFXT1S_3            (0x30)   /* Mode 3
                                for LFXT1 : Digital input signal */
    354    000000              
    355    000000              #define XT2S_0              (0x00)   /* Mode 0
                                for XT2 : 0.4 - 1 MHz */
    356    000000              #define XT2S_1              (0x40)   /* Mode 1
                                for XT2 : 1 - 4 MHz */
    357    000000              #define XT2S_2              (0x80)   /* Mode 2
                                for XT2 : 2 - 16 MHz */
    358    000000              #define XT2S_3              (0xC0)   /* Mode 3
                                for XT2 : Digital input signal */
    359    000000              
    360    000000              /***********************************************
                               *************
    361    000000              * Comparator A
    362    000000              ************************************************
                               ************/
    363    000000              #define __MSP430_HAS_CAPLUS__         /*
                                Definition to show that Module is available
                                */
    364    000000              
    365    000000              #define CACTL1_             (0x0059u)  /*
                                Comparator A Control 1 */
    366    000000              DEFC(   CACTL1            , CACTL1_)
    367    000000              #define CACTL2_             (0x005Au)  /*
                                Comparator A Control 2 */
    368    000000              DEFC(   CACTL2            , CACTL2_)
    369    000000              #define CAPD_               (0x005Bu)  /*
                                Comparator A Port Disable */
    370    000000              DEFC(   CAPD              , CAPD_)
    371    000000              
    372    000000              #define CAIFG               (0x01)    /* Comp. A
                                Interrupt Flag */
    373    000000              #define CAIE                (0x02)    /* Comp. A
                                Interrupt Enable */
    374    000000              #define CAIES               (0x04)    /* Comp. A
                                Int. Edge Select: 0:rising / 1:falling
                                */
    375    000000              #define CAON                (0x08)    /* Comp. A
                                enable */
    376    000000              #define CAREF0              (0x10)    /* Comp. A
                                Internal Reference Select 0 */
    377    000000              #define CAREF1              (0x20)    /* Comp. A
                                Internal Reference Select 1 */
    378    000000              #define CARSEL              (0x40)    /* Comp. A
                                Internal Reference Enable */
    379    000000              #define CAEX                (0x80)    /* Comp. A
                                Exchange Inputs */
    380    000000              
    381    000000              #define CAREF_0             (0x00)    /* Comp. A
                                Int. Ref. Select 0 : Off */
    382    000000              #define CAREF_1             (0x10)    /* Comp. A
                                Int. Ref. Select 1 : 0.25*Vcc */
    383    000000              #define CAREF_2             (0x20)    /* Comp. A
                                Int. Ref. Select 2 : 0.5*Vcc */
    384    000000              #define CAREF_3             (0x30)    /* Comp. A
                                Int. Ref. Select 3 : Vt*/
    385    000000              
    386    000000              #define CAOUT               (0x01)    /* Comp. A
                                Output */
    387    000000              #define CAF                 (0x02)    /* Comp. A
                                Enable Output Filter */
    388    000000              #define P2CA0               (0x04)    /* Comp. A
                                +Terminal Multiplexer */
    389    000000              #define P2CA1               (0x08)    /* Comp. A
                                -Terminal Multiplexer */
    390    000000              #define P2CA2               (0x10)    /* Comp. A
                                -Terminal Multiplexer */
    391    000000              #define P2CA3               (0x20)    /* Comp. A
                                -Terminal Multiplexer */
    392    000000              #define P2CA4               (0x40)    /* Comp. A
                                +Terminal Multiplexer */
    393    000000              #define CASHORT             (0x80)    /* Comp. A
                                Short + and - Terminals */
    394    000000              
    395    000000              #define CAPD0               (0x01)    /* Comp. A
                                Disable Input Buffer of Port Register .0
                                */
    396    000000              #define CAPD1               (0x02)    /* Comp. A
                                Disable Input Buffer of Port Register .1
                                */
    397    000000              #define CAPD2               (0x04)    /* Comp. A
                                Disable Input Buffer of Port Register .2
                                */
    398    000000              #define CAPD3               (0x08)    /* Comp. A
                                Disable Input Buffer of Port Register .3
                                */
    399    000000              #define CAPD4               (0x10)    /* Comp. A
                                Disable Input Buffer of Port Register .4
                                */
    400    000000              #define CAPD5               (0x20)    /* Comp. A
                                Disable Input Buffer of Port Register .5
                                */
    401    000000              #define CAPD6               (0x40)    /* Comp. A
                                Disable Input Buffer of Port Register .6
                                */
    402    000000              #define CAPD7               (0x80)    /* Comp. A
                                Disable Input Buffer of Port Register .7
                                */
    403    000000              
    404    000000              /***********************************************
                               **************
    405    000000              * Flash Memory
    406    000000              ************************************************
                               *************/
    407    000000              #define __MSP430_HAS_FLASH2__         /*
                                Definition to show that Module is available
                                */
    408    000000              
    409    000000              #define FCTL1_              (0x0128u)  /* FLASH
                                Control 1 */
    410    000000              DEFW(   FCTL1             , FCTL1_)
    411    000000              #define FCTL2_              (0x012Au)  /* FLASH
                                Control 2 */
    412    000000              DEFW(   FCTL2             , FCTL2_)
    413    000000              #define FCTL3_              (0x012Cu)  /* FLASH
                                Control 3 */
    414    000000              DEFW(   FCTL3             , FCTL3_)
    415    000000              
    416    000000              #define FRKEY               (0x9600u)  /* Flash
                                key returned by read */
    417    000000              #define FWKEY               (0xA500u)  /* Flash
                                key for write */
    418    000000              #define FXKEY               (0x3300u)  /* for
                                use with XOR instruction */
    419    000000              
    420    000000              #define ERASE               (0x0002u)  /* Enable
                                bit for Flash segment erase */
    421    000000              #define MERAS               (0x0004u)  /* Enable
                                bit for Flash mass erase */
    422    000000              #define WRT                 (0x0040u)  /* Enable
                                bit for Flash write */
    423    000000              #define BLKWRT              (0x0080u)  /* Enable
                                bit for Flash segment write */
    424    000000              #define SEGWRT              (0x0080u)  /* old
                                definition */ /* Enable bit for Flash segment
                                write */
    425    000000              
    426    000000              #define FN0                 (0x0001u)  /* Divide
                                Flash clock by 1 to 64 using FN0 to FN5
                                according to: */
    427    000000              #define FN1                 (0x0002u)  /* 
                                32*FN5 + 16*FN4 + 8*FN3 + 4*FN2 + 2*FN1 + FN0 +
                                1 */
    428    000000              #ifndef FN2
    429    000000              #define FN2                 (0x0004u)
    430    000000              #endif
    431    000000              #ifndef FN3
    432    000000              #define FN3                 (0x0008u)
    433    000000              #endif
    434    000000              #ifndef FN4
    435    000000              #define FN4                 (0x0010u)
    436    000000              #endif
    437    000000              #define FN5                 (0x0020u)
    438    000000              #define FSSEL0              (0x0040u)  /* Flash
                                clock select 0 */        /* to distinguish from
                                USART SSELx */
    439    000000              #define FSSEL1              (0x0080u)  /* Flash
                                clock select 1 */
    440    000000              
    441    000000              #define FSSEL_0             (0x0000u)  /* Flash
                                clock select: 0 - ACLK */
    442    000000              #define FSSEL_1             (0x0040u)  /* Flash
                                clock select: 1 - MCLK */
    443    000000              #define FSSEL_2             (0x0080u)  /* Flash
                                clock select: 2 - SMCLK */
    444    000000              #define FSSEL_3             (0x00C0u)  /* Flash
                                clock select: 3 - SMCLK */
    445    000000              
    446    000000              #define BUSY                (0x0001u)  /* Flash
                                busy: 1 */
    447    000000              #define KEYV                (0x0002u)  /* Flash
                                Key violation flag */
    448    000000              #define ACCVIFG             (0x0004u)  /* Flash
                                Access violation flag */
    449    000000              #define WAIT                (0x0008u)  /* Wait
                                flag for segment write */
    450    000000              #define LOCK                (0x0010u)  /* Lock
                                bit: 1 - Flash is locked (read only) */
    451    000000              #define EMEX                (0x0020u)  /* Flash
                                Emergency Exit */
    452    000000              #define LOCKA               (0x0040u)  /*
                                Segment A Lock bit: read = 1 - Segment is
                                locked (read only) */
    453    000000              #define FAIL                (0x0080u)  /* Last
                                Program or Erase failed */
    454    000000              
    455    000000              /***********************************************
                               *************
    456    000000              * DIGITAL I/O Port1/2 Pull up / Pull down
                                Resistors
    457    000000              ************************************************
                               ************/
    458    000000              #define __MSP430_HAS_PORT1_R__        /*
                                Definition to show that Module is available
                                */
    459    000000              #define __MSP430_HAS_PORT2_R__        /*
                                Definition to show that Module is available
                                */
    460    000000              
    461    000000              #define P1IN_               (0x0020u)  /* Port 1
                                Input */
    462    000000              READ_ONLY DEFC( P1IN           , P1IN_)
    463    000000              #define P1OUT_              (0x0021u)  /* Port 1
                                Output */
    464    000000              DEFC(   P1OUT             , P1OUT_)
    465    000000              #define P1DIR_              (0x0022u)  /* Port 1
                                Direction */
    466    000000              DEFC(   P1DIR             , P1DIR_)
    467    000000              #define P1IFG_              (0x0023u)  /* Port 1
                                Interrupt Flag */
    468    000000              DEFC(   P1IFG             , P1IFG_)
    469    000000              #define P1IES_              (0x0024u)  /* Port 1
                                Interrupt Edge Select */
    470    000000              DEFC(   P1IES             , P1IES_)
    471    000000              #define P1IE_               (0x0025u)  /* Port 1
                                Interrupt Enable */
    472    000000              DEFC(   P1IE              , P1IE_)
    473    000000              #define P1SEL_              (0x0026u)  /* Port 1
                                Selection */
    474    000000              DEFC(   P1SEL             , P1SEL_)
    475    000000              #define P1SEL2_             (0x0041u)  /* Port 1
                                Selection 2 */
    476    000000              DEFC(   P1SEL2            , P1SEL2_)
    477    000000              #define P1REN_              (0x0027u)  /* Port 1
                                Resistor Enable */
    478    000000              DEFC(   P1REN             , P1REN_)
    479    000000              
    480    000000              #define P2IN_               (0x0028u)  /* Port 2
                                Input */
    481    000000              READ_ONLY DEFC( P2IN           , P2IN_)
    482    000000              #define P2OUT_              (0x0029u)  /* Port 2
                                Output */
    483    000000              DEFC(   P2OUT             , P2OUT_)
    484    000000              #define P2DIR_              (0x002Au)  /* Port 2
                                Direction */
    485    000000              DEFC(   P2DIR             , P2DIR_)
    486    000000              #define P2IFG_              (0x002Bu)  /* Port 2
                                Interrupt Flag */
    487    000000              DEFC(   P2IFG             , P2IFG_)
    488    000000              #define P2IES_              (0x002Cu)  /* Port 2
                                Interrupt Edge Select */
    489    000000              DEFC(   P2IES             , P2IES_)
    490    000000              #define P2IE_               (0x002Du)  /* Port 2
                                Interrupt Enable */
    491    000000              DEFC(   P2IE              , P2IE_)
    492    000000              #define P2SEL_              (0x002Eu)  /* Port 2
                                Selection */
    493    000000              DEFC(   P2SEL             , P2SEL_)
    494    000000              #define P2SEL2_             (0x0042u)  /* Port 2
                                Selection 2 */
    495    000000              DEFC(   P2SEL2            , P2SEL2_)
    496    000000              #define P2REN_              (0x002Fu)  /* Port 2
                                Resistor Enable */
    497    000000              DEFC(   P2REN             , P2REN_)
    498    000000              
    499    000000              /***********************************************
                               *************
    500    000000              * DIGITAL I/O Port3 Pull up / Pull down
                                Resistors
    501    000000              ************************************************
                               ************/
    502    000000              #define __MSP430_HAS_PORT3_R__          /*
                                Definition to show that Module is available
                                */
    503    000000              
    504    000000              #define P3IN_               (0x0018u)  /* Port 3
                                Input */
    505    000000              READ_ONLY DEFC( P3IN           , P3IN_)
    506    000000              #define P3OUT_              (0x0019u)  /* Port 3
                                Output */
    507    000000              DEFC(   P3OUT             , P3OUT_)
    508    000000              #define P3DIR_              (0x001Au)  /* Port 3
                                Direction */
    509    000000              DEFC(   P3DIR             , P3DIR_)
    510    000000              #define P3SEL_              (0x001Bu)  /* Port 3
                                Selection */
    511    000000              DEFC(   P3SEL             , P3SEL_)
    512    000000              #define P3SEL2_             (0x0043u)  /* Port 3
                                Selection 2 */
    513    000000              DEFC(   P3SEL2            , P3SEL2_)
    514    000000              #define P3REN_              (0x0010u)  /* Port 3
                                Resistor Enable */
    515    000000              DEFC(   P3REN             , P3REN_)
    516    000000              
    517    000000              /***********************************************
                               *************
    518    000000              * Timer0_A3
    519    000000              ************************************************
                               ************/
    520    000000              #define __MSP430_HAS_TA3__            /*
                                Definition to show that Module is available
                                */
    521    000000              
    522    000000              #define TA0IV_              (0x012Eu)  /*
                                Timer0_A3 Interrupt Vector Word */
    523    000000              READ_ONLY DEFW( TA0IV          , TA0IV_)
    524    000000              #define TA0CTL_             (0x0160u)  /*
                                Timer0_A3 Control */
    525    000000              DEFW(   TA0CTL            , TA0CTL_)
    526    000000              #define TA0CCTL0_           (0x0162u)  /*
                                Timer0_A3 Capture/Compare Control 0 */
    527    000000              DEFW(   TA0CCTL0          , TA0CCTL0_)
    528    000000              #define TA0CCTL1_           (0x0164u)  /*
                                Timer0_A3 Capture/Compare Control 1 */
    529    000000              DEFW(   TA0CCTL1          , TA0CCTL1_)
    530    000000              #define TA0CCTL2_           (0x0166u)  /*
                                Timer0_A3 Capture/Compare Control 2 */
    531    000000              DEFW(   TA0CCTL2          , TA0CCTL2_)
    532    000000              #define TA0R_               (0x0170u)  /*
                                Timer0_A3 */
    533    000000              DEFW(   TA0R              , TA0R_)
    534    000000              #define TA0CCR0_            (0x0172u)  /*
                                Timer0_A3 Capture/Compare 0 */
    535    000000              DEFW(   TA0CCR0           , TA0CCR0_)
    536    000000              #define TA0CCR1_            (0x0174u)  /*
                                Timer0_A3 Capture/Compare 1 */
    537    000000              DEFW(   TA0CCR1           , TA0CCR1_)
    538    000000              #define TA0CCR2_            (0x0176u)  /*
                                Timer0_A3 Capture/Compare 2 */
    539    000000              DEFW(   TA0CCR2           , TA0CCR2_)
    540    000000              
    541    000000              /* Alternate register names */
    542    000000              #define TAIV                TA0IV     /* Timer A
                                Interrupt Vector Word */
    543    000000              #define TACTL               TA0CTL    /* Timer A
                                Control */
    544    000000              #define TACCTL0             TA0CCTL0  /* Timer A
                                Capture/Compare Control 0 */
    545    000000              #define TACCTL1             TA0CCTL1  /* Timer A
                                Capture/Compare Control 1 */
    546    000000              #define TACCTL2             TA0CCTL2  /* Timer A
                                Capture/Compare Control 2 */
    547    000000              #define TAR                 TA0R      /* Timer A
                                */
    548    000000              #define TACCR0              TA0CCR0   /* Timer A
                                Capture/Compare 0 */
    549    000000              #define TACCR1              TA0CCR1   /* Timer A
                                Capture/Compare 1 */
    550    000000              #define TACCR2              TA0CCR2   /* Timer A
                                Capture/Compare 2 */
    551    000000              #define TAIV_               TA0IV_    /* Timer A
                                Interrupt Vector Word */
    552    000000              #define TACTL_              TA0CTL_   /* Timer A
                                Control */
    553    000000              #define TACCTL0_            TA0CCTL0_ /* Timer A
                                Capture/Compare Control 0 */
    554    000000              #define TACCTL1_            TA0CCTL1_ /* Timer A
                                Capture/Compare Control 1 */
    555    000000              #define TACCTL2_            TA0CCTL2_ /* Timer A
                                Capture/Compare Control 2 */
    556    000000              #define TAR_                TA0R_     /* Timer A
                                */
    557    000000              #define TACCR0_             TA0CCR0_  /* Timer A
                                Capture/Compare 0 */
    558    000000              #define TACCR1_             TA0CCR1_  /* Timer A
                                Capture/Compare 1 */
    559    000000              #define TACCR2_             TA0CCR2_  /* Timer A
                                Capture/Compare 2 */
    560    000000              
    561    000000              /* Alternate register names 2 */
    562    000000              #define CCTL0               TACCTL0   /* Timer A
                                Capture/Compare Control 0 */
    563    000000              #define CCTL1               TACCTL1   /* Timer A
                                Capture/Compare Control 1 */
    564    000000              #define CCTL2               TACCTL2   /* Timer A
                                Capture/Compare Control 2 */
    565    000000              #define CCR0                TACCR0    /* Timer A
                                Capture/Compare 0 */
    566    000000              #define CCR1                TACCR1    /* Timer A
                                Capture/Compare 1 */
    567    000000              #define CCR2                TACCR2    /* Timer A
                                Capture/Compare 2 */
    568    000000              #define CCTL0_              TACCTL0_  /* Timer A
                                Capture/Compare Control 0 */
    569    000000              #define CCTL1_              TACCTL1_  /* Timer A
                                Capture/Compare Control 1 */
    570    000000              #define CCTL2_              TACCTL2_  /* Timer A
                                Capture/Compare Control 2 */
    571    000000              #define CCR0_               TACCR0_   /* Timer A
                                Capture/Compare 0 */
    572    000000              #define CCR1_               TACCR1_   /* Timer A
                                Capture/Compare 1 */
    573    000000              #define CCR2_               TACCR2_   /* Timer A
                                Capture/Compare 2 */
    574    000000              
    575    000000              #define TASSEL1             (0x0200u)  /* Timer
                                A clock source select 0 */
    576    000000              #define TASSEL0             (0x0100u)  /* Timer
                                A clock source select 1 */
    577    000000              #define ID1                 (0x0080u)  /* Timer
                                A clock input divider 1 */
    578    000000              #define ID0                 (0x0040u)  /* Timer
                                A clock input divider 0 */
    579    000000              #define MC1                 (0x0020u)  /* Timer
                                A mode control 1 */
    580    000000              #define MC0                 (0x0010u)  /* Timer
                                A mode control 0 */
    581    000000              #define TACLR               (0x0004u)  /* Timer
                                A counter clear */
    582    000000              #define TAIE                (0x0002u)  /* Timer
                                A counter interrupt enable */
    583    000000              #define TAIFG               (0x0001u)  /* Timer
                                A counter interrupt flag */
    584    000000              
    585    000000              #define MC_0                (0*0x10u)  /* Timer
                                A mode control: 0 - Stop */
    586    000000              #define MC_1                (1*0x10u)  /* Timer
                                A mode control: 1 - Up to CCR0 */
    587    000000              #define MC_2                (2*0x10u)  /* Timer
                                A mode control: 2 - Continous up */
    588    000000              #define MC_3                (3*0x10u)  /* Timer
                                A mode control: 3 - Up/Down */
    589    000000              #define ID_0                (0*0x40u)  /* Timer
                                A input divider: 0 - /1 */
    590    000000              #define ID_1                (1*0x40u)  /* Timer
                                A input divider: 1 - /2 */
    591    000000              #define ID_2                (2*0x40u)  /* Timer
                                A input divider: 2 - /4 */
    592    000000              #define ID_3                (3*0x40u)  /* Timer
                                A input divider: 3 - /8 */
    593    000000              #define TASSEL_0            (0*0x100u) /* Timer
                                A clock source select: 0 - TACLK */
    594    000000              #define TASSEL_1            (1*0x100u) /* Timer
                                A clock source select: 1 - ACLK  */
    595    000000              #define TASSEL_2            (2*0x100u) /* Timer
                                A clock source select: 2 - SMCLK */
    596    000000              #define TASSEL_3            (3*0x100u) /* Timer
                                A clock source select: 3 - INCLK */
    597    000000              
    598    000000              #define CM1                 (0x8000u)  /*
                                Capture mode 1 */
    599    000000              #define CM0                 (0x4000u)  /*
                                Capture mode 0 */
    600    000000              #define CCIS1               (0x2000u)  /*
                                Capture input select 1 */
    601    000000              #define CCIS0               (0x1000u)  /*
                                Capture input select 0 */
    602    000000              #define SCS                 (0x0800u)  /*
                                Capture sychronize */
    603    000000              #define SCCI                (0x0400u)  /*
                                Latched capture signal (read) */
    604    000000              #define CAP                 (0x0100u)  /*
                                Capture mode: 1 /Compare mode : 0 */
    605    000000              #define OUTMOD2             (0x0080u)  /* Output
                                mode 2 */
    606    000000              #define OUTMOD1             (0x0040u)  /* Output
                                mode 1 */
    607    000000              #define OUTMOD0             (0x0020u)  /* Output
                                mode 0 */
    608    000000              #define CCIE                (0x0010u)  /*
                                Capture/compare interrupt enable */
    609    000000              #define CCI                 (0x0008u)  /*
                                Capture input signal (read) */
    610    000000              #define OUT                 (0x0004u)  /* PWM
                                Output signal if output mode 0 */
    611    000000              #define COV                 (0x0002u)  /*
                                Capture/compare overflow flag */
    612    000000              #define CCIFG               (0x0001u)  /*
                                Capture/compare interrupt flag */
    613    000000              
    614    000000              #define OUTMOD_0            (0*0x20u)  /* PWM
                                output mode: 0 - output only */
    615    000000              #define OUTMOD_1            (1*0x20u)  /* PWM
                                output mode: 1 - set */
    616    000000              #define OUTMOD_2            (2*0x20u)  /* PWM
                                output mode: 2 - PWM toggle/reset */
    617    000000              #define OUTMOD_3            (3*0x20u)  /* PWM
                                output mode: 3 - PWM set/reset */
    618    000000              #define OUTMOD_4            (4*0x20u)  /* PWM
                                output mode: 4 - toggle */
    619    000000              #define OUTMOD_5            (5*0x20u)  /* PWM
                                output mode: 5 - Reset */
    620    000000              #define OUTMOD_6            (6*0x20u)  /* PWM
                                output mode: 6 - PWM toggle/set */
    621    000000              #define OUTMOD_7            (7*0x20u)  /* PWM
                                output mode: 7 - PWM reset/set */
    622    000000              #define CCIS_0              (0*0x1000u) /*
                                Capture input select: 0 - CCIxA */
    623    000000              #define CCIS_1              (1*0x1000u) /*
                                Capture input select: 1 - CCIxB */
    624    000000              #define CCIS_2              (2*0x1000u) /*
                                Capture input select: 2 - GND */
    625    000000              #define CCIS_3              (3*0x1000u) /*
                                Capture input select: 3 - Vcc */
    626    000000              #define CM_0                (0*0x4000u) /*
                                Capture mode: 0 - disabled */
    627    000000              #define CM_1                (1*0x4000u) /*
                                Capture mode: 1 - pos. edge */
    628    000000              #define CM_2                (2*0x4000u) /*
                                Capture mode: 1 - neg. edge */
    629    000000              #define CM_3                (3*0x4000u) /*
                                Capture mode: 1 - both edges */
    630    000000              
    631    000000              /* T0_A3IV Definitions */
    632    000000              #define TA0IV_NONE          (0x0000u)    /* No
                                Interrupt pending */
    633    000000              #define TA0IV_TACCR1        (0x0002u)    /*
                                TA0CCR1_CCIFG */
    634    000000              #define TA0IV_TACCR2        (0x0004u)    /*
                                TA0CCR2_CCIFG */
    635    000000              #define TA0IV_6             (0x0006u)    /*
                                Reserved */
    636    000000              #define TA0IV_8             (0x0008u)    /*
                                Reserved */
    637    000000              #define TA0IV_TAIFG         (0x000Au)    /*
                                TA0IFG */
    638    000000              
    639    000000              /***********************************************
                               *************
    640    000000              * Timer1_A3
    641    000000              ************************************************
                               ************/
    642    000000              #define __MSP430_HAS_T1A3__           /*
                                Definition to show that Module is available
                                */
    643    000000              
    644    000000              #define TA1IV_              (0x011Eu)  /*
                                Timer1_A3 Interrupt Vector Word */
    645    000000              READ_ONLY DEFW( TA1IV          , TA1IV_)
    646    000000              #define TA1CTL_             (0x0180u)  /*
                                Timer1_A3 Control */
    647    000000              DEFW(   TA1CTL            , TA1CTL_)
    648    000000              #define TA1CCTL0_           (0x0182u)  /*
                                Timer1_A3 Capture/Compare Control 0 */
    649    000000              DEFW(   TA1CCTL0          , TA1CCTL0_)
    650    000000              #define TA1CCTL1_           (0x0184u)  /*
                                Timer1_A3 Capture/Compare Control 1 */
    651    000000              DEFW(   TA1CCTL1          , TA1CCTL1_)
    652    000000              #define TA1CCTL2_           (0x0186u)  /*
                                Timer1_A3 Capture/Compare Control 2 */
    653    000000              DEFW(   TA1CCTL2          , TA1CCTL2_)
    654    000000              #define TA1R_               (0x0190u)  /*
                                Timer1_A3 */
    655    000000              DEFW(   TA1R              , TA1R_)
    656    000000              #define TA1CCR0_            (0x0192u)  /*
                                Timer1_A3 Capture/Compare 0 */
    657    000000              DEFW(   TA1CCR0           , TA1CCR0_)
    658    000000              #define TA1CCR1_            (0x0194u)  /*
                                Timer1_A3 Capture/Compare 1 */
    659    000000              DEFW(   TA1CCR1           , TA1CCR1_)
    660    000000              #define TA1CCR2_            (0x0196u)  /*
                                Timer1_A3 Capture/Compare 2 */
    661    000000              DEFW(   TA1CCR2           , TA1CCR2_)
    662    000000              
    663    000000              /* Bits are already defined within the Timer0_Ax
                                */
    664    000000              
    665    000000              /* T1_A3IV Definitions */
    666    000000              #define TA1IV_NONE          (0x0000u)    /* No
                                Interrupt pending */
    667    000000              #define TA1IV_TACCR1        (0x0002u)    /*
                                TA1CCR1_CCIFG */
    668    000000              #define TA1IV_TACCR2        (0x0004u)    /*
                                TA1CCR2_CCIFG */
    669    000000              #define TA1IV_TAIFG         (0x000Au)    /*
                                TA1IFG */
    670    000000              
    671    000000              /***********************************************
                               *************
    672    000000              * USCI
    673    000000              ************************************************
                               ************/
    674    000000              #define __MSP430_HAS_USCI__           /*
                                Definition to show that Module is available
                                */
    675    000000              
    676    000000              #define UCA0CTL0_           (0x0060u)  /* USCI
                                A0 Control Register 0 */
    677    000000              DEFC(   UCA0CTL0          , UCA0CTL0_)
    678    000000              #define UCA0CTL1_           (0x0061u)  /* USCI
                                A0 Control Register 1 */
    679    000000              DEFC(   UCA0CTL1          , UCA0CTL1_)
    680    000000              #define UCA0BR0_            (0x0062u)  /* USCI
                                A0 Baud Rate 0 */
    681    000000              DEFC(   UCA0BR0           , UCA0BR0_)
    682    000000              #define UCA0BR1_            (0x0063u)  /* USCI
                                A0 Baud Rate 1 */
    683    000000              DEFC(   UCA0BR1           , UCA0BR1_)
    684    000000              #define UCA0MCTL_           (0x0064u)  /* USCI
                                A0 Modulation Control */
    685    000000              DEFC(   UCA0MCTL          , UCA0MCTL_)
    686    000000              #define UCA0STAT_           (0x0065u)  /* USCI
                                A0 Status Register */
    687    000000              DEFC(   UCA0STAT          , UCA0STAT_)
    688    000000              #define UCA0RXBUF_          (0x0066u)  /* USCI
                                A0 Receive Buffer */
    689    000000              READ_ONLY DEFC( UCA0RXBUF      , UCA0RXBUF_)
    690    000000              #define UCA0TXBUF_          (0x0067u)  /* USCI
                                A0 Transmit Buffer */
    691    000000              DEFC(   UCA0TXBUF         , UCA0TXBUF_)
    692    000000              #define UCA0ABCTL_          (0x005Du)  /* USCI
                                A0 LIN Control */
    693    000000              DEFC(   UCA0ABCTL         , UCA0ABCTL_)
    694    000000              #define UCA0IRTCTL_         (0x005Eu)  /* USCI
                                A0 IrDA Transmit Control */
    695    000000              DEFC(   UCA0IRTCTL        , UCA0IRTCTL_)
    696    000000              #define UCA0IRRCTL_         (0x005Fu)  /* USCI
                                A0 IrDA Receive Control */
    697    000000              DEFC(   UCA0IRRCTL        , UCA0IRRCTL_)
    698    000000              
    699    000000              
    700    000000              
    701    000000              #define UCB0CTL0_           (0x0068u)  /* USCI
                                B0 Control Register 0 */
    702    000000              DEFC(   UCB0CTL0          , UCB0CTL0_)
    703    000000              #define UCB0CTL1_           (0x0069u)  /* USCI
                                B0 Control Register 1 */
    704    000000              DEFC(   UCB0CTL1          , UCB0CTL1_)
    705    000000              #define UCB0BR0_            (0x006Au)  /* USCI
                                B0 Baud Rate 0 */
    706    000000              DEFC(   UCB0BR0           , UCB0BR0_)
    707    000000              #define UCB0BR1_            (0x006Bu)  /* USCI
                                B0 Baud Rate 1 */
    708    000000              DEFC(   UCB0BR1           , UCB0BR1_)
    709    000000              #define UCB0I2CIE_          (0x006Cu)  /* USCI
                                B0 I2C Interrupt Enable Register */
    710    000000              DEFC(   UCB0I2CIE         , UCB0I2CIE_)
    711    000000              #define UCB0STAT_           (0x006Du)  /* USCI
                                B0 Status Register */
    712    000000              DEFC(   UCB0STAT          , UCB0STAT_)
    713    000000              #define UCB0RXBUF_          (0x006Eu)  /* USCI
                                B0 Receive Buffer */
    714    000000              READ_ONLY DEFC( UCB0RXBUF      , UCB0RXBUF_)
    715    000000              #define UCB0TXBUF_          (0x006Fu)  /* USCI
                                B0 Transmit Buffer */
    716    000000              DEFC(   UCB0TXBUF         , UCB0TXBUF_)
    717    000000              #define UCB0I2COA_          (0x0118u)  /* USCI
                                B0 I2C Own Address */
    718    000000              DEFW(   UCB0I2COA         , UCB0I2COA_)
    719    000000              #define UCB0I2CSA_          (0x011Au)  /* USCI
                                B0 I2C Slave Address */
    720    000000              DEFW(   UCB0I2CSA         , UCB0I2CSA_)
    721    000000              
    722    000000              // UART-Mode Bits
    723    000000              #define UCPEN               (0x80)    /* Async.
                                Mode: Parity enable */
    724    000000              #define UCPAR               (0x40)    /* Async.
                                Mode: Parity     0:odd / 1:even */
    725    000000              #define UCMSB               (0x20)    /* Async.
                                Mode: MSB first  0:LSB / 1:MSB */
    726    000000              #define UC7BIT              (0x10)    /* Async.
                                Mode: Data Bits  0:8-bits / 1:7-bits */
    727    000000              #define UCSPB               (0x08)    /* Async.
                                Mode: Stop Bits  0:one / 1: two */
    728    000000              #define UCMODE1             (0x04)    /* Async.
                                Mode: USCI Mode 1 */
    729    000000              #define UCMODE0             (0x02)    /* Async.
                                Mode: USCI Mode 0 */
    730    000000              #define UCSYNC              (0x01)    /*
                                Sync-Mode  0:UART-Mode / 1:SPI-Mode */
    731    000000              
    732    000000              // SPI-Mode Bits
    733    000000              #define UCCKPH              (0x80)    /* Sync.
                                Mode: Clock Phase */
    734    000000              #define UCCKPL              (0x40)    /* Sync.
                                Mode: Clock Polarity */
    735    000000              #define UCMST               (0x08)    /* Sync.
                                Mode: Master Select */
    736    000000              
    737    000000              // I2C-Mode Bits
    738    000000              #define UCA10               (0x80)    /* 10-bit
                                Address Mode */
    739    000000              #define UCSLA10             (0x40)    /* 10-bit
                                Slave Address Mode */
    740    000000              #define UCMM                (0x20)    /*
                                Multi-Master Environment */
    741    000000              //#define res               (0x10)    /*
                                reserved */
    742    000000              #define UCMODE_0            (0x00)    /* Sync.
                                Mode: USCI Mode: 0 */
    743    000000              #define UCMODE_1            (0x02)    /* Sync.
                                Mode: USCI Mode: 1 */
    744    000000              #define UCMODE_2            (0x04)    /* Sync.
                                Mode: USCI Mode: 2 */
    745    000000              #define UCMODE_3            (0x06)    /* Sync.
                                Mode: USCI Mode: 3 */
    746    000000              
    747    000000              // UART-Mode Bits
    748    000000              #define UCSSEL1             (0x80)    /* USCI 0
                                Clock Source Select 1 */
    749    000000              #define UCSSEL0             (0x40)    /* USCI 0
                                Clock Source Select 0 */
    750    000000              #define UCRXEIE             (0x20)    /* RX
                                Error interrupt enable */
    751    000000              #define UCBRKIE             (0x10)    /* Break
                                interrupt enable */
    752    000000              #define UCDORM              (0x08)    /* Dormant
                                (Sleep) Mode */
    753    000000              #define UCTXADDR            (0x04)    /* Send
                                next Data as Address */
    754    000000              #define UCTXBRK             (0x02)    /* Send
                                next Data as Break */
    755    000000              #define UCSWRST             (0x01)    /* USCI
                                Software Reset */
    756    000000              
    757    000000              // SPI-Mode Bits
    758    000000              //#define res               (0x20)    /*
                                reserved */
    759    000000              //#define res               (0x10)    /*
                                reserved */
    760    000000              //#define res               (0x08)    /*
                                reserved */
    761    000000              //#define res               (0x04)    /*
                                reserved */
    762    000000              //#define res               (0x02)    /*
                                reserved */
    763    000000              
    764    000000              // I2C-Mode Bits
    765    000000              //#define res               (0x20)    /*
                                reserved */
    766    000000              #define UCTR                (0x10)    /*
                                Transmit/Receive Select/Flag */
    767    000000              #define UCTXNACK            (0x08)    /*
                                Transmit NACK */
    768    000000              #define UCTXSTP             (0x04)    /*
                                Transmit STOP */
    769    000000              #define UCTXSTT             (0x02)    /*
                                Transmit START */
    770    000000              #define UCSSEL_0            (0x00)    /* USCI 0
                                Clock Source: 0 */
    771    000000              #define UCSSEL_1            (0x40)    /* USCI 0
                                Clock Source: 1 */
    772    000000              #define UCSSEL_2            (0x80)    /* USCI 0
                                Clock Source: 2 */
    773    000000              #define UCSSEL_3            (0xC0)    /* USCI 0
                                Clock Source: 3 */
    774    000000              
    775    000000              #define UCBRF3              (0x80)    /* USCI
                                First Stage Modulation Select 3 */
    776    000000              #define UCBRF2              (0x40)    /* USCI
                                First Stage Modulation Select 2 */
    777    000000              #define UCBRF1              (0x20)    /* USCI
                                First Stage Modulation Select 1 */
    778    000000              #define UCBRF0              (0x10)    /* USCI
                                First Stage Modulation Select 0 */
    779    000000              #define UCBRS2              (0x08)    /* USCI
                                Second Stage Modulation Select 2 */
    780    000000              #define UCBRS1              (0x04)    /* USCI
                                Second Stage Modulation Select 1 */
    781    000000              #define UCBRS0              (0x02)    /* USCI
                                Second Stage Modulation Select 0 */
    782    000000              #define UCOS16              (0x01)    /* USCI
                                16-times Oversampling enable */
    783    000000              
    784    000000              #define UCBRF_0             (0x00)    /* USCI
                                First Stage Modulation: 0 */
    785    000000              #define UCBRF_1             (0x10)    /* USCI
                                First Stage Modulation: 1 */
    786    000000              #define UCBRF_2             (0x20)    /* USCI
                                First Stage Modulation: 2 */
    787    000000              #define UCBRF_3             (0x30)    /* USCI
                                First Stage Modulation: 3 */
    788    000000              #define UCBRF_4             (0x40)    /* USCI
                                First Stage Modulation: 4 */
    789    000000              #define UCBRF_5             (0x50)    /* USCI
                                First Stage Modulation: 5 */
    790    000000              #define UCBRF_6             (0x60)    /* USCI
                                First Stage Modulation: 6 */
    791    000000              #define UCBRF_7             (0x70)    /* USCI
                                First Stage Modulation: 7 */
    792    000000              #define UCBRF_8             (0x80)    /* USCI
                                First Stage Modulation: 8 */
    793    000000              #define UCBRF_9             (0x90)    /* USCI
                                First Stage Modulation: 9 */
    794    000000              #define UCBRF_10            (0xA0)    /* USCI
                                First Stage Modulation: A */
    795    000000              #define UCBRF_11            (0xB0)    /* USCI
                                First Stage Modulation: B */
    796    000000              #define UCBRF_12            (0xC0)    /* USCI
                                First Stage Modulation: C */
    797    000000              #define UCBRF_13            (0xD0)    /* USCI
                                First Stage Modulation: D */
    798    000000              #define UCBRF_14            (0xE0)    /* USCI
                                First Stage Modulation: E */
    799    000000              #define UCBRF_15            (0xF0)    /* USCI
                                First Stage Modulation: F */
    800    000000              
    801    000000              #define UCBRS_0             (0x00)    /* USCI
                                Second Stage Modulation: 0 */
    802    000000              #define UCBRS_1             (0x02)    /* USCI
                                Second Stage Modulation: 1 */
    803    000000              #define UCBRS_2             (0x04)    /* USCI
                                Second Stage Modulation: 2 */
    804    000000              #define UCBRS_3             (0x06)    /* USCI
                                Second Stage Modulation: 3 */
    805    000000              #define UCBRS_4             (0x08)    /* USCI
                                Second Stage Modulation: 4 */
    806    000000              #define UCBRS_5             (0x0A)    /* USCI
                                Second Stage Modulation: 5 */
    807    000000              #define UCBRS_6             (0x0C)    /* USCI
                                Second Stage Modulation: 6 */
    808    000000              #define UCBRS_7             (0x0E)    /* USCI
                                Second Stage Modulation: 7 */
    809    000000              
    810    000000              #define UCLISTEN            (0x80)    /* USCI
                                Listen mode */
    811    000000              #define UCFE                (0x40)    /* USCI
                                Frame Error Flag */
    812    000000              #define UCOE                (0x20)    /* USCI
                                Overrun Error Flag */
    813    000000              #define UCPE                (0x10)    /* USCI
                                Parity Error Flag */
    814    000000              #define UCBRK               (0x08)    /* USCI
                                Break received */
    815    000000              #define UCRXERR             (0x04)    /* USCI RX
                                Error Flag */
    816    000000              #define UCADDR              (0x02)    /* USCI
                                Address received Flag */
    817    000000              #define UCBUSY              (0x01)    /* USCI
                                Busy Flag */
    818    000000              #define UCIDLE              (0x02)    /* USCI
                                Idle line detected Flag */
    819    000000              
    820    000000              //#define res               (0x80)    /*
                                reserved */
    821    000000              //#define res               (0x40)    /*
                                reserved */
    822    000000              //#define res               (0x20)    /*
                                reserved */
    823    000000              //#define res               (0x10)    /*
                                reserved */
    824    000000              #define UCNACKIE            (0x08)    /* NACK
                                Condition interrupt enable */
    825    000000              #define UCSTPIE             (0x04)    /* STOP
                                Condition interrupt enable */
    826    000000              #define UCSTTIE             (0x02)    /* START
                                Condition interrupt enable */
    827    000000              #define UCALIE              (0x01)    /*
                                Arbitration Lost interrupt enable */
    828    000000              
    829    000000              #define UCSCLLOW            (0x40)    /* SCL low
                                */
    830    000000              #define UCGC                (0x20)    /* General
                                Call address received Flag */
    831    000000              #define UCBBUSY             (0x10)    /* Bus
                                Busy Flag */
    832    000000              #define UCNACKIFG           (0x08)    /* NAK
                                Condition interrupt Flag */
    833    000000              #define UCSTPIFG            (0x04)    /* STOP
                                Condition interrupt Flag */
    834    000000              #define UCSTTIFG            (0x02)    /* START
                                Condition interrupt Flag */
    835    000000              #define UCALIFG             (0x01)    /*
                                Arbitration Lost interrupt Flag */
    836    000000              
    837    000000              #define UCIRTXPL5           (0x80)    /* IRDA
                                Transmit Pulse Length 5 */
    838    000000              #define UCIRTXPL4           (0x40)    /* IRDA
                                Transmit Pulse Length 4 */
    839    000000              #define UCIRTXPL3           (0x20)    /* IRDA
                                Transmit Pulse Length 3 */
    840    000000              #define UCIRTXPL2           (0x10)    /* IRDA
                                Transmit Pulse Length 2 */
    841    000000              #define UCIRTXPL1           (0x08)    /* IRDA
                                Transmit Pulse Length 1 */
    842    000000              #define UCIRTXPL0           (0x04)    /* IRDA
                                Transmit Pulse Length 0 */
    843    000000              #define UCIRTXCLK           (0x02)    /* IRDA
                                Transmit Pulse Clock Select */
    844    000000              #define UCIREN              (0x01)    /* IRDA
                                Encoder/Decoder enable */
    845    000000              
    846    000000              #define UCIRRXFL5           (0x80)    /* IRDA
                                Receive Filter Length 5 */
    847    000000              #define UCIRRXFL4           (0x40)    /* IRDA
                                Receive Filter Length 4 */
    848    000000              #define UCIRRXFL3           (0x20)    /* IRDA
                                Receive Filter Length 3 */
    849    000000              #define UCIRRXFL2           (0x10)    /* IRDA
                                Receive Filter Length 2 */
    850    000000              #define UCIRRXFL1           (0x08)    /* IRDA
                                Receive Filter Length 1 */
    851    000000              #define UCIRRXFL0           (0x04)    /* IRDA
                                Receive Filter Length 0 */
    852    000000              #define UCIRRXPL            (0x02)    /* IRDA
                                Receive Input Polarity */
    853    000000              #define UCIRRXFE            (0x01)    /* IRDA
                                Receive Filter enable */
    854    000000              
    855    000000              //#define res               (0x80)    /*
                                reserved */
    856    000000              //#define res               (0x40)    /*
                                reserved */
    857    000000              #define UCDELIM1            (0x20)    /* Break
                                Sync Delimiter 1 */
    858    000000              #define UCDELIM0            (0x10)    /* Break
                                Sync Delimiter 0 */
    859    000000              #define UCSTOE              (0x08)    /*
                                Sync-Field Timeout error */
    860    000000              #define UCBTOE              (0x04)    /* Break
                                Timeout error */
    861    000000              //#define res               (0x02)    /*
                                reserved */
    862    000000              #define UCABDEN             (0x01)    /* Auto
                                Baud Rate detect enable */
    863    000000              
    864    000000              #define UCGCEN              (0x8000u)  /* I2C
                                General Call enable */
    865    000000              #define UCOA9               (0x0200u)  /* I2C
                                Own Address 9 */
    866    000000              #define UCOA8               (0x0100u)  /* I2C
                                Own Address 8 */
    867    000000              #define UCOA7               (0x0080u)  /* I2C
                                Own Address 7 */
    868    000000              #define UCOA6               (0x0040u)  /* I2C
                                Own Address 6 */
    869    000000              #define UCOA5               (0x0020u)  /* I2C
                                Own Address 5 */
    870    000000              #define UCOA4               (0x0010u)  /* I2C
                                Own Address 4 */
    871    000000              #define UCOA3               (0x0008u)  /* I2C
                                Own Address 3 */
    872    000000              #define UCOA2               (0x0004u)  /* I2C
                                Own Address 2 */
    873    000000              #define UCOA1               (0x0002u)  /* I2C
                                Own Address 1 */
    874    000000              #define UCOA0               (0x0001u)  /* I2C
                                Own Address 0 */
    875    000000              
    876    000000              #define UCSA9               (0x0200u)  /* I2C
                                Slave Address 9 */
    877    000000              #define UCSA8               (0x0100u)  /* I2C
                                Slave Address 8 */
    878    000000              #define UCSA7               (0x0080u)  /* I2C
                                Slave Address 7 */
    879    000000              #define UCSA6               (0x0040u)  /* I2C
                                Slave Address 6 */
    880    000000              #define UCSA5               (0x0020u)  /* I2C
                                Slave Address 5 */
    881    000000              #define UCSA4               (0x0010u)  /* I2C
                                Slave Address 4 */
    882    000000              #define UCSA3               (0x0008u)  /* I2C
                                Slave Address 3 */
    883    000000              #define UCSA2               (0x0004u)  /* I2C
                                Slave Address 2 */
    884    000000              #define UCSA1               (0x0002u)  /* I2C
                                Slave Address 1 */
    885    000000              #define UCSA0               (0x0001u)  /* I2C
                                Slave Address 0 */
    886    000000              
    887    000000              /***********************************************
                               *************
    888    000000              * WATCHDOG TIMER
    889    000000              ************************************************
                               ************/
    890    000000              #define __MSP430_HAS_WDT__            /*
                                Definition to show that Module is available
                                */
    891    000000              
    892    000000              #define WDTCTL_             (0x0120u)  /*
                                Watchdog Timer Control */
    893    000000              DEFW(   WDTCTL            , WDTCTL_)
    894    000000              /* The bit names have been prefixed with "WDT"
                                */
    895    000000              #define WDTIS0              (0x0001u)
    896    000000              #define WDTIS1              (0x0002u)
    897    000000              #define WDTSSEL             (0x0004u)
    898    000000              #define WDTCNTCL            (0x0008u)
    899    000000              #define WDTTMSEL            (0x0010u)
    900    000000              #define WDTNMI              (0x0020u)
    901    000000              #define WDTNMIES            (0x0040u)
    902    000000              #define WDTHOLD             (0x0080u)
    903    000000              
    904    000000              #define WDTPW               (0x5A00u)
    905    000000              
    906    000000              /* WDT-interval times [1ms] coded with Bits 0-2
                                */
    907    000000              /* WDT is clocked by fSMCLK (assumed 1MHz)
                                */
    908    000000              #define WDT_MDLY_32         (WDTPW+WDTTMSEL+WDTC
                               NTCL)                         /* 32ms interval
                                (default) */
    909    000000              #define WDT_MDLY_8          (WDTPW+WDTTMSEL+WDTC
                               NTCL+WDTIS0)                  /* 8ms     "
                                */
    910    000000              #define WDT_MDLY_0_5        (WDTPW+WDTTMSEL+WDTC
                               NTCL+WDTIS1)                  /* 0.5ms   "
                                */
    911    000000              #define WDT_MDLY_0_064      (WDTPW+WDTTMSEL+WDTC
                               NTCL+WDTIS1+WDTIS0)           /* 0.064ms "
                                */
    912    000000              /* WDT is clocked by fACLK (assumed 32KHz)
                                */
    913    000000              #define WDT_ADLY_1000       (WDTPW+WDTTMSEL+WDTC
                               NTCL+WDTSSEL)                 /* 1000ms  "
                                */
    914    000000              #define WDT_ADLY_250        (WDTPW+WDTTMSEL+WDTC
                               NTCL+WDTSSEL+WDTIS0)          /* 250ms   "
                                */
    915    000000              #define WDT_ADLY_16         (WDTPW+WDTTMSEL+WDTC
                               NTCL+WDTSSEL+WDTIS1)          /* 16ms    "
                                */
    916    000000              #define WDT_ADLY_1_9        (WDTPW+WDTTMSEL+WDTC
                               NTCL+WDTSSEL+WDTIS1+WDTIS0)   /* 1.9ms   "
                                */
    917    000000              /* Watchdog mode -> reset after expired time
                                */
    918    000000              /* WDT is clocked by fSMCLK (assumed 1MHz)
                                */
    919    000000              #define WDT_MRST_32         (WDTPW+WDTCNTCL)    
                                                             /* 32ms interval
                                (default) */
    920    000000              #define WDT_MRST_8          (WDTPW+WDTCNTCL+WDTI
                               S0)                           /* 8ms     "
                                */
    921    000000              #define WDT_MRST_0_5        (WDTPW+WDTCNTCL+WDTI
                               S1)                           /* 0.5ms   "
                                */
    922    000000              #define WDT_MRST_0_064      (WDTPW+WDTCNTCL+WDTI
                               S1+WDTIS0)                    /* 0.064ms "
                                */
    923    000000              /* WDT is clocked by fACLK (assumed 32KHz)
                                */
    924    000000              #define WDT_ARST_1000       (WDTPW+WDTCNTCL+WDTS
                               SEL)                          /* 1000ms  "
                                */
    925    000000              #define WDT_ARST_250        (WDTPW+WDTCNTCL+WDTS
                               SEL+WDTIS0)                   /* 250ms   "
                                */
    926    000000              #define WDT_ARST_16         (WDTPW+WDTCNTCL+WDTS
                               SEL+WDTIS1)                   /* 16ms    "
                                */
    927    000000              #define WDT_ARST_1_9        (WDTPW+WDTCNTCL+WDTS
                               SEL+WDTIS1+WDTIS0)            /* 1.9ms   "
                                */
    928    000000              
    929    000000              /* INTERRUPT CONTROL */
    930    000000              /* These two bits are defined in the Special
                                Function Registers */
    931    000000              /* #define WDTIE               0x01 */
    932    000000              /* #define WDTIFG              0x01 */
    933    000000              
    934    000000              /***********************************************
                               *************
    935    000000              * Calibration Data in Info Mem
    936    000000              ************************************************
                               ************/
    937    000000              
    938    000000              #ifndef __DisableCalData
    939    000000              
    940    000000              #define CALDCO_16MHZ_         (0x10F8u)  /*
                                DCOCTL  Calibration Data for 16MHz */
    941    000000              READ_ONLY DEFC( CALDCO_16MHZ     , CALDCO_16MHZ_
                               )
    942    000000              #define CALBC1_16MHZ_         (0x10F9u)  /*
                                BCSCTL1 Calibration Data for 16MHz */
    943    000000              READ_ONLY DEFC( CALBC1_16MHZ     , CALBC1_16MHZ_
                               )
    944    000000              #define CALDCO_12MHZ_         (0x10FAu)  /*
                                DCOCTL  Calibration Data for 12MHz */
    945    000000              READ_ONLY DEFC( CALDCO_12MHZ     , CALDCO_12MHZ_
                               )
    946    000000              #define CALBC1_12MHZ_         (0x10FBu)  /*
                                BCSCTL1 Calibration Data for 12MHz */
    947    000000              READ_ONLY DEFC( CALBC1_12MHZ     , CALBC1_12MHZ_
                               )
    948    000000              #define CALDCO_8MHZ_          (0x10FCu)  /*
                                DCOCTL  Calibration Data for 8MHz */
    949    000000              READ_ONLY DEFC( CALDCO_8MHZ      , CALDCO_8MHZ_)
    950    000000              #define CALBC1_8MHZ_          (0x10FDu)  /*
                                BCSCTL1 Calibration Data for 8MHz */
    951    000000              READ_ONLY DEFC( CALBC1_8MHZ      , CALBC1_8MHZ_)
    952    000000              #define CALDCO_1MHZ_          (0x10FEu)  /*
                                DCOCTL  Calibration Data for 1MHz */
    953    000000              READ_ONLY DEFC( CALDCO_1MHZ      , CALDCO_1MHZ_)
    954    000000              #define CALBC1_1MHZ_          (0x10FFu)  /*
                                BCSCTL1 Calibration Data for 1MHz */
    955    000000              READ_ONLY DEFC( CALBC1_1MHZ      , CALBC1_1MHZ_)
    956    000000              
    957    000000              #endif /* #ifndef __DisableCalData */
    958    000000              
    959    000000              /***********************************************
                               *************
    960    000000              * Interrupt Vectors (offset from 0xFFE0)
    961    000000              ************************************************
                               ************/
    962    000000              
    963    000000              #define PORT1_VECTOR        (2 * 2u)  /* 0xFFE4
                                Port 1 */
    964    000000              #define PORT2_VECTOR        (3 * 2u)  /* 0xFFE6
                                Port 2 */
    965    000000              #define ADC10_VECTOR        (5 * 2u)  /* 0xFFEA
                                ADC10 */
    966    000000              #define USCIAB0TX_VECTOR    (6 * 2u)  /* 0xFFEC
                                USCI A0/B0 Transmit */
    967    000000              #define USCIAB0RX_VECTOR    (7 * 2u)  /* 0xFFEE
                                USCI A0/B0 Receive */
    968    000000              #define TIMER0_A1_VECTOR    (8 * 2u)  /* 0xFFF0
                                Timer0)A CC1, TA0 */
    969    000000              #define TIMER0_A0_VECTOR    (9 * 2u)  /* 0xFFF2
                                Timer0_A CC0 */
    970    000000              #define WDT_VECTOR          (10 * 2u) /* 0xFFF4
                                Watchdog Timer */
    971    000000              #define COMPARATORA_VECTOR  (11 * 2u) /* 0xFFF6
                                Comparator A */
    972    000000              #define TIMER1_A1_VECTOR    (12 * 2u) /* 0xFFF8
                                Timer1_A CC1-4, TA1 */
    973    000000              #define TIMER1_A0_VECTOR    (13 * 2u) /* 0xFFFA
                                Timer1_A CC0 */
    974    000000              #define NMI_VECTOR          (14 * 2u) /* 0xFFFC
                                Non-maskable */
    975    000000              #define RESET_VECTOR        (15 * 2u) /* 0xFFFE
                                Reset [Highest Priority] */
    976    000000              
    977    000000              /***********************************************
                               *************
    978    000000              * End of Modules
    979    000000              ************************************************
                               ************/
    980    000000              #pragma language=default
    981    000000              
    982    000000              #endif /* #ifndef __MSP430G2553 */
    983    000000              
    986    000000              
    987    000000              #elif defined (__MSP430G2203__)
    988    000000              #include "msp430g2203.h"
    990    000000              #elif defined (__MSP430G2303__)
    991    000000              #include "msp430g2303.h"
    993    000000              #elif defined (__MSP430G2403__)
    994    000000              #include "msp430g2403.h"
    996    000000              #elif defined (__MSP430G2233__)
    997    000000              #include "msp430g2233.h"
    999    000000              #elif defined (__MSP430G2333__)
   1000    000000              #include "msp430g2333.h"
   1002    000000              #elif defined (__MSP430G2433__)
   1003    000000              #include "msp430g2433.h"
   1005    000000              #elif defined (__MSP430G2533__)
   1006    000000              #include "msp430g2533.h"
   1008    000000              #elif defined (__MSP430BT5190__)
   1009    000000              #include "msp430bt5190.h"
   1014    000000              #elif defined (__MSP430GENERIC__)
   1015    000000              #error "msp430 generic device does not have a
                                default include file"
   1017    000000              #elif defined (__MSP430XGENERIC__)
   1018    000000              #error "msp430X generic device does not have a
                                default include file"
   1024    000000              #else
   1025    000000              #error "Failed to match a default include
                                file"
   1026    000000              #endif
   1027    000000              
   1028    000000              #endif /* #ifndef __msp430 */
   1029    000000              
     29    000000              #include "4e-CF430G2553forth.h"         ; header
                                macros and register defs
      1    000000              ; ----------------------------------------------
                               ------------------------
      2    000000              ; 4e4th is a Forth based on CamelForth
                                
      3    000000              ; for the Texas Instruments MSP430 
      4    000000              ; 
      5    000000              ; This program is free software; you can
                                redistribute it and/or modify
      6    000000              ; it under the terms of the GNU General Public
                                License as published by
      7    000000              ; the Free Software Foundation; either version 3
                                of the License, or
      8    000000              ; (at your option) any later version.
      9    000000              ; 
     10    000000              ; This program is distributed in the hope that
                                it will be useful,
     11    000000              ; but WITHOUT ANY WARRANTY; without even the
                                implied warranty of
     12    000000              ; MERCHANTABILITY or FITNESS FOR A PARTICULAR
                                PURPOSE.  See the
     13    000000              ; GNU General Public License for more details.
     14    000000              ;
     15    000000              ; You should have received a copy of the GNU
                                General Public License
     16    000000              ; along with this program.  If not, see
                                <http://www.gnu.org/licenses/>.
     17    000000              ; 
     18    000000              ; See LICENSE TERMS in Brads file readme.txt as
                                well.
     19    000000              
     20    000000              ; ----------------------------------------------
                               ------------------------
     21    000000              ; 4e-CF430G2553forth.h: - Register, Model, Macro
                                declarations - MSP430G2553
     22    000000              ; ----------------------------------------------
                               ------------------------
     23    000000              
     24    000000              // ; FORTH MEMORY USAGE
     25    000000              // ; for Flash memory operations - this includes
                                information and main
     26    000000              // ; ROM, but not the main ROM used by the
                                kernel (above E000h)
     27    000000              #define INFOSTART   (0x1000) // ok mk
     28    000000              #define INFOEND     (0x10FF) // ok mk
     29    000000              #define RAMSTART    (0x0200) // ok mk
     30    000000              #define RAMEND      (0x03FF) // ok mk
     31    000000              #define FLASHSTART  (0xC000) // ok mk 
     32    000000              #define FLASHEND    (0xDFFF) // ok mk
     33    000000              #define MAINSEG     (512) // wozu ?? mk
     34    000000              #define INFOSEG     (128) // ?? mk
     35    000000              
     36    000000              // ; FORTH REGISTER USAGE
     37    000000              
     38    000000              // ; Forth virtual machine
     39    000000              #define RSP SP
     40    000000              #define PSP R4
     41    000000              #define IP  R5
     42    000000              #define W   R6
     43    000000              #define TOS R7
     44    000000              
     45    000000              // ; Loop parameters in registers
     46    000000              #define INDEX R8
     47    000000              #define LIMIT R9
     48    000000              
     49    000000              // ; Scratch registers
     50    000000              #define X  R10
     51    000000              #define Y  R11
     52    000000              #define Q  R12
     53    000000              #define T  R13
     54    000000              
     55    000000              // ; T.I. Integer Subroutines Definitions
     56    000000              #define IROP1   TOS
     57    000000              #define IROP2L  R10
     58    000000              #define IROP2M  R11
     59    000000              #define IRACL   R12
     60    000000              #define IRACM   R13
     61    000000              #define IRBT    W  
     62    000000              
     63    000000              // ; INDIRECT-THREADED NEXT
     64    000000              
     69    000000              
     70    000000              // ; BRANCH DESTINATION (RELATIVE BRANCH)
     71    000000              // ; For relative branch addresses, i.e., a
                                branch is ADD @IP,IP
     72    000000              
     76    000000              
     77    000000              // ; HEADER CONSTRUCTION MACROS
     78    000000              
     93    000000              
    102    000000              
    117    000000              
     30    000000              
     31    000000                      EXTERN  UP,UAREA,PADAREA,LSTACK,PSTACK,R
 STACK
     32    000000                      EXTERN  TIBAREA,RAMDICT,ROMDICT
     33    000000                      EXTERN  TIB_SIZE,UAREA_SIZE,nullirq
     34    000000              
     35    000000                      RSEG    CODE                    ; place
  program in 'CODE' segment
     36    000000              
     37    000000              link    SET 0           ; initial dictionary
                                link
     38    000000              
     39    000000              version:
     40    000000 19                   DB (verend-ver0)
     41    000001 344534746820*ver0:   DB '4E4th R0.34 ',__date__,'|' ; R =
                                            Release Version
     42    00001A                      EVEN
     43    00001A              verend: 
     44    00001A              
     45    00001A              ; ----------------------------------------------
                               ------------------------
     46    00001A              ; INTERPRETER LOGIC
     47    00001A              ; ITC NEXT is defined as
     48    00001A              ;        MOV @IP+,W      ; 2 fetch word address
                                into W
     49    00001A              ;        MOV @W+,PC      ; 2 fetch code address
                                into PC, W=PFA
     50    00001A              
     51    00001A              ;C EXECUTE   i*x xt -- j*x   execute Forth word
                                at 'xt'
     52    00001A                      HEADER  EXECUTE,7,'EXECUTE',DOCODE
     52.1  000000                      PUBLIC  EXECUTE
     52.2  00001A 0000                 DW      link
     52.3  00001C FF                   DB      0FFh       ; not immediate
     52.4  00001D              link    SET     $
     52.5  00001D 07                   DB      7
     52.6  00001E 455845435554*        DB      'EXECUTE'
     52.7  000025 00                   EVEN
     52.8  000026                      IF      'DOCODE'='DOCODE'
     52.9  000026 ....         EXECUTE: DW     $+2
     52.10 000028                      ELSE
     52.11 000028              EXECUTE: DW      DOCODE
     52.12 000028                      ENDIF
     52.13 000028                      ENDM
     53    000028 0647                 MOV TOS,W       ; 1 put word address
                                                        into W
     54    00002A 3744                 MOV @PSP+,TOS   ; 2 fetch new TOS
     55    00002C 3046                 MOV @W+,PC      ; 2 fetch code address
                                                        into PC, W=PFA
     56    00002E              
     57    00002E              ;Z lit      -- x    fetch inline literal to
                                stack
     58    00002E              ; This is the primtive compiled by LITERAL.
     59    00002E                      HEADER  lit,3,'lit',DOCODE
     59.1  000000                      PUBLIC  lit
     59.2  00002E ....                 DW      link
     59.3  000030 FF                   DB      0FFh       ; not immediate
     59.4  000031              link    SET     $
     59.5  000031 03                   DB      3
     59.6  000032 6C6974               DB      'lit'
     59.7  000035 00                   EVEN
     59.8  000036                      IF      'DOCODE'='DOCODE'
     59.9  000036 ....         lit: DW     $+2
     59.10 000038                      ELSE
     59.11 000038              lit: DW      DOCODE
     59.12 000038                      ENDIF
     59.13 000038                      ENDM
     60    000038 2483                 SUB #2,PSP      ; 1  push old TOS..
     61    00003A 84470000             MOV TOS,0(PSP)  ; 4  ..onto stack
     62    00003E 3745                 MOV @IP+,TOS    ; 2  fetch new TOS
                                                        value
     63    000040                      NEXT            ; 4
     63.1  000040 3645                 MOV @IP+,W     // ; fetch word address
                                                            into W
     63.2  000042 3046                 MOV @W+,PC     // ; fetch code address
                                                            into PC, W=PFA
     63.3  000044                      ENDM
     64    000044              
     65    000044              ;C EXIT     --            exit a colon
                                definition
     66    000044                      HEADER  EXIT,4,'EXIT',DOCODE
     66.1  000000                      PUBLIC  EXIT
     66.2  000044 ....                 DW      link
     66.3  000046 FF                   DB      0FFh       ; not immediate
     66.4  000047              link    SET     $
     66.5  000047 04                   DB      4
     66.6  000048 45584954             DB      'EXIT'
     66.7  00004C                      EVEN
     66.8  00004C                      IF      'DOCODE'='DOCODE'
     66.9  00004C ....         EXIT: DW     $+2
     66.10 00004E                      ELSE
     66.11 00004E              EXIT: DW      DOCODE
     66.12 00004E                      ENDIF
     66.13 00004E                      ENDM
     67    00004E 3541                 MOV @RSP+,IP    ; 2 pop old IP from
                                                        return stack
     68    000050                      NEXT            ; 4
     68.1  000050 3645                 MOV @IP+,W     // ; fetch word address
                                                            into W
     68.2  000052 3046                 MOV @W+,PC     // ; fetch code address
                                                            into PC, W=PFA
     68.3  000054                      ENDM
     69    000054              
     70    000054              ; ----------------------------------------------
                               ------------------------
     71    000054              ; DEFINING WORDS - ROMable ITC model 
     72    000054              
     73    000054              ; DOCOLON enters a new high-level thread (colon
                                definition.)
     74    000054              ; (internal code fragment, not a Forth
                                word)
     75    000000                      PUBLIC DOCOLON
     76    000054              DOCOLON: 
     77    000054 0512                 PUSH IP         ; 3 save old IP on
                                                        return stack
     78    000056 0546                 MOV W,IP        ; 1 set new IP to
                                                        PFA
     79    000058                      NEXT            ; 4
     79.1  000058 3645                 MOV @IP+,W     // ; fetch word address
                                                            into W
     79.2  00005A 3046                 MOV @W+,PC     // ; fetch code address
                                                            into PC, W=PFA
     79.3  00005C                      ENDM
     80    00005C              
     81    00005C              ;C VARIABLE   --            define a Forth
                                VARIABLE
     82    00005C              ;   CREATE CELL ALLOT ;
     83    00005C              ; Action of ROMable variable is the same as
                                CREATE; it builds a
     84    00005C              ; constant holding the RAM address.  See CREATE
                                in hilvl430.s43.
     85    00005C                      HEADER VARIABLE,8,'VARIABLE',DOCOLON
     85.1  000000                      PUBLIC  VARIABLE
     85.2  00005C ....                 DW      link
     85.3  00005E FF                   DB      0FFh       ; not immediate
     85.4  00005F              link    SET     $
     85.5  00005F 08                   DB      8
     85.6  000060 564152494142*        DB      'VARIABLE'
     85.7  000068                      EVEN
     85.8  000068                      IF      'DOCOLON'='DOCODE'
     85.9  000068              VARIABLE: DW     $+2
     85.10 000068                      ELSE
     85.11 000068 ....         VARIABLE: DW      DOCOLON
     85.12 00006A                      ENDIF
     85.13 00006A                      ENDM
     86    00006A ............*        DW CREATE,CELL,ALLOT,EXIT
     87    000072              
     88    000072              ;C CONSTANT   --            define a Forth
                                constant
     89    000072              ;   <BUILDS  I,   Flashable Harvard model
     90    000072              ;   DOES> (machine code fragment)
     91    000072              ; Note that the constant is stored in Code
                                space.
     92    000072                      HEADER CONSTANT,8,'CONSTANT',DOCOLON
     92.1  000000                      PUBLIC  CONSTANT
     92.2  000072 ....                 DW      link
     92.3  000074 FF                   DB      0FFh       ; not immediate
     92.4  000075              link    SET     $
     92.5  000075 08                   DB      8
     92.6  000076 434F4E535441*        DB      'CONSTANT'
     92.7  00007E                      EVEN
     92.8  00007E                      IF      'DOCOLON'='DOCODE'
     92.9  00007E              CONSTANT: DW     $+2
     92.10 00007E                      ELSE
     92.11 00007E ....         CONSTANT: DW      DOCOLON
     92.12 000080                      ENDIF
     92.13 000080                      ENDM
     93    000080 ............         DW BUILDS,ICOMMA,XDOES
     94    000086              ; DOCON, code action of CONSTANT,
     95    000086              ; entered with W=Parameter Field Adrs
     96    000086              ; This is also the action of VARIABLE (Harvard
                                model)
     97    000086              ; This is also the action of CREATE (Harvard
                                model)
     98    000000                      PUBLIC DOCON
     99    000000                      PUBLIC docreate
    100    000000                      PUBLIC DOVAR
    101    000086              docreate: ; -- a-addr   ; ROMable CREATE fetches
                                address from PFA
    102    000086              DOVAR:  ; -- a-addr     ; ROMable VARIABLE
                                fetches address from PFA
    103    000086              DOCON:  ; -- x          ; CONSTANT fetches cell
                                from PFA to TOS
    104    000086 2483                 SUB #2,PSP      ; make room on
                                                        stack
    105    000088 84470000             MOV TOS,0(PSP)
    106    00008C 2746                 MOV @W,TOS      ; fetch from parameter
                                                        field to TOS
    107    00008E                      NEXT
    107.1  00008E 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
    107.2  000090 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
    107.3  000092                      ENDM
    108    000092              
    109    000092              ; DOCREATE's action is for a table in RAM.
    110    000092              ; DOROM is the code action for a table in
                                ROM;
    111    000092              ; it returns the address of the parameter
                                field.
    112    000000                      PUBLIC DOROM
    113    000092              DOROM:  ; -- a-addr     ; Table in ROM: get PFA
                                into TOS
    114    000092 2483                 SUB #2,PSP 
    115    000094 84470000             MOV TOS,0(PSP)
    116    000098 0746                 MOV W,TOS
    117    00009A                      NEXT
    117.1  00009A 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
    117.2  00009C 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
    117.3  00009E                      ENDM
    118    00009E              
    119    00009E              ;Z USER     n --        define user variable
                                'n'
    120    00009E              ;   <BUILDS I, DOES> (machine code fragment)   
                                Flashable model
    121    00009E                      HEADER USER,4,'USER',DOCOLON
    121.1  000000                      PUBLIC  USER
    121.2  00009E ....                 DW      link
    121.3  0000A0 FF                   DB      0FFh       ; not immediate
    121.4  0000A1              link    SET     $
    121.5  0000A1 04                   DB      4
    121.6  0000A2 55534552             DB      'USER'
    121.7  0000A6                      EVEN
    121.8  0000A6                      IF      'DOCOLON'='DOCODE'
    121.9  0000A6              USER: DW     $+2
    121.10 0000A6                      ELSE
    121.11 0000A6 ....         USER: DW      DOCOLON
    121.12 0000A8                      ENDIF
    121.13 0000A8                      ENDM
    122    0000A8 ............         DW BUILDS,ICOMMA,XDOES
    123    000000                      PUBLIC DOUSER
    124    0000AE              DOUSER: ; -- a-addr     ; add constant to User
                                Pointer, result in TOS
    125    0000AE 2483                 SUB #2,PSP
    126    0000B0 84470000             MOV TOS,0(PSP)
    127    0000B4 2746                 MOV @W,TOS
    128    0000B6 1752....             ADD &UP,TOS
    129    0000BA                      NEXT
    129.1  0000BA 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
    129.2  0000BC 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
    129.3  0000BE                      ENDM
    130    0000BE              
    131    0000BE              ; DOALIAS  used to build a word which performs
                                the action of
    132    0000BE              ; another word.  Its action is to fetch the
                                "alias" CFA from
    133    0000BE              ; the parameter field, and execute that, e.g.
                                DOES> I@ EXECUTE ;
    134    0000BE              ; This is currently used only within the Forth
                                kernel.
    135    000000                      PUBLIC DOALIAS
    136    0000BE              DOALIAS:  ; --          ; fetch CFA of word to
                                execute
    137    0000BE 2646                 MOV @W,W        ; 2 fetch from parameter
                                                        field to W
    138    0000C0 3046                 MOV @W+,PC      ; 2 fetch code address
                                                        into PC, W=PFA
    139    0000C2              
    140    0000C2              ; DODOES is the code action of a DOES> clause. 
                                For ITC Forth:
    141    0000C2              ; defined word:  CFA: doescode
    142    0000C2              ;                PFA: parameter field
    143    0000C2              ;
    144    0000C2              ; doescode: MOV #DODOES,PC      ; 16-bit direct
                                jump, in two cells
    145    0000C2              ;           high-level thread
    146    0000C2              ;
    147    0000C2              ; Note that we use JMP DODOES instead of CALL
                                #DODOES because we can 
    148    0000C2              ; efficiently obtain the thread address.  DODOES
                                is entered with W=PFA.
    149    0000C2              ; It enters the high-level thread with the
                                address of the parameter
    150    0000C2              ; field on top of stack.
    151    0000C2              
    152    000000                      PUBLIC dodoes
    153    0000C2              dodoes: ; -- a-addr     ; 3 for MOV #DODOES,PC
    154    0000C2 2483                 SUB #2,PSP      ; 1 make room on
                                                        stack
    155    0000C4 84470000             MOV TOS,0(PSP)  ; 4
    156    0000C8 0746                 MOV W,TOS       ; 1 put defined word's
                                                        PFA in TOS
    157    0000CA 0512                 PUSH IP         ; 3 save old IP on
                                                        return stack
    158    0000CC 1546FEFF             MOV -2(W),IP    ; 3 fetch adrs of
                                                        doescode from defined
                                                        word
    159    0000D0 2552                 ADD #4,IP       ; 1 skip MOV instruction
                                                        to get thread
                                                        adrs
    160    0000D2                      NEXT            ; 4
    160.1  0000D2 3645                 MOV @IP+,W     // ; fetch word address
                                                            into W
    160.2  0000D4 3046                 MOV @W+,PC     // ; fetch code address
                                                            into PC, W=PFA
    160.3  0000D6                      ENDM
    161    0000D6              
    162    0000D6              ; OPTION 1              ; OPTION 2
    163    0000D6              ;  MOV #DODOES,PC   3   ;  CALL #DODOES     
                                5
    164    0000D6              ;   ...                 ;   ...
    165    0000D6              ;  PUSH IP          3   ;  POP W           
                                2
    166    0000D6              ;  MOVE -2(W),IP    3   ;  PUSH IP         
                                3
    167    0000D6              ;  ADD #4,IP        1   ;  MOV W,IP        
                                1
    168    0000D6              
    169    0000D6              
    170    0000D6              ; ----------------------------------------------
                               ------------------------
    171    0000D6              ; STACK OPERATIONS
    172    0000D6              
    173    0000D6              ;C DUP      x -- x x      duplicate top of
                                stack
    174    0000D6                      HEADER  DUP,3,'DUP',DOCODE 
    174.1  000000                      PUBLIC  DUP
    174.2  0000D6 ....                 DW      link
    174.3  0000D8 FF                   DB      0FFh       ; not immediate
    174.4  0000D9              link    SET     $
    174.5  0000D9 03                   DB      3
    174.6  0000DA 445550               DB      'DUP'
    174.7  0000DD 00                   EVEN
    174.8  0000DE                      IF      'DOCODE'='DOCODE'
    174.9  0000DE ....         DUP: DW     $+2
    174.10 0000E0                      ELSE
    174.11 0000E0              DUP: DW      DOCODE
    174.12 0000E0                      ENDIF
    174.13 0000E0                      ENDM
    175    0000E0 2483         PUSHTOS: SUB    #2,PSP          ; 1  push old
                                                                TOS..
    176    0000E2 84470000             MOV     TOS,0(PSP)      ; 4  ..onto
                                                                stack
    177    0000E6                      NEXT                    ; 4
    177.1  0000E6 3645                 MOV @IP+,W     // ; fetch word address
                                                                    into
                                                                    W
    177.2  0000E8 3046                 MOV @W+,PC     // ; fetch code address
                                                                    into PC,
                                                                    W=PFA
    177.3  0000EA                      ENDM
    178    0000EA              
    179    0000EA              ;C ?DUP     x -- 0 | x x    DUP if nonzero
    180    0000EA                      HEADER  QDUP,4,'?DUP',DOCODE
    180.1  000000                      PUBLIC  QDUP
    180.2  0000EA ....                 DW      link
    180.3  0000EC FF                   DB      0FFh       ; not immediate
    180.4  0000ED              link    SET     $
    180.5  0000ED 04                   DB      4
    180.6  0000EE 3F445550             DB      '?DUP'
    180.7  0000F2                      EVEN
    180.8  0000F2                      IF      'DOCODE'='DOCODE'
    180.9  0000F2 ....         QDUP: DW     $+2
    180.10 0000F4                      ELSE
    180.11 0000F4              QDUP: DW      DOCODE
    180.12 0000F4                      ENDIF
    180.13 0000F4                      ENDM
    181    0000F4 0793                 CMP     #0,TOS          ; 1  test for
                                                                TOS nonzero
    182    0000F6 F423                 JNZ     PUSHTOS         ; 2
    183    0000F8              NODUP:  NEXT                    ; 4
    183.1  0000F8 3645                 MOV @IP+,W     // ; fetch word address
                                                                    into
                                                                    W
    183.2  0000FA 3046                 MOV @W+,PC     // ; fetch code address
                                                                    into PC,
                                                                    W=PFA
    183.3  0000FC                      ENDM
    184    0000FC              
    185    0000FC              ;C DROP     x --          drop top of stack
    186    0000FC                      HEADER  DROP,4,'DROP',DOCODE
    186.1  000000                      PUBLIC  DROP
    186.2  0000FC ....                 DW      link
    186.3  0000FE FF                   DB      0FFh       ; not immediate
    186.4  0000FF              link    SET     $
    186.5  0000FF 04                   DB      4
    186.6  000100 44524F50             DB      'DROP'
    186.7  000104                      EVEN
    186.8  000104                      IF      'DOCODE'='DOCODE'
    186.9  000104 ....         DROP: DW     $+2
    186.10 000106                      ELSE
    186.11 000106              DROP: DW      DOCODE
    186.12 000106                      ENDIF
    186.13 000106                      ENDM
    187    000106 3744                 MOV     @PSP+,TOS       ; 2
    188    000108                      NEXT                    ; 4
    188.1  000108 3645                 MOV @IP+,W     // ; fetch word address
                                                                    into
                                                                    W
    188.2  00010A 3046                 MOV @W+,PC     // ; fetch code address
                                                                    into PC,
                                                                    W=PFA
    188.3  00010C                      ENDM
    189    00010C              
    190    00010C              ;C SWAP     x1 x2 -- x2 x1    swap top two
                                items
    191    00010C                      HEADER  SWAP,4,'SWAP',DOCODE
    191.1  000000                      PUBLIC  SWAP
    191.2  00010C ....                 DW      link
    191.3  00010E FF                   DB      0FFh       ; not immediate
    191.4  00010F              link    SET     $
    191.5  00010F 04                   DB      4
    191.6  000110 53574150             DB      'SWAP'
    191.7  000114                      EVEN
    191.8  000114                      IF      'DOCODE'='DOCODE'
    191.9  000114 ....         SWAP: DW     $+2
    191.10 000116                      ELSE
    191.11 000116              SWAP: DW      DOCODE
    191.12 000116                      ENDIF
    191.13 000116                      ENDM
    192    000116 2644                 MOV     @PSP,W          ; 2
    193    000118 84470000             MOV     TOS,0(PSP)      ; 4
    194    00011C 0746                 MOV     W,TOS           ; 1
    195    00011E                      NEXT                    ; 4
    195.1  00011E 3645                 MOV @IP+,W     // ; fetch word address
                                                                    into
                                                                    W
    195.2  000120 3046                 MOV @W+,PC     // ; fetch code address
                                                                    into PC,
                                                                    W=PFA
    195.3  000122                      ENDM
    196    000122              
    197    000122              ;C OVER    x1 x2 -- x1 x2 x1   per stack
                                diagram
    198    000122                      HEADER  OVER,4,'OVER',DOCODE
    198.1  000000                      PUBLIC  OVER
    198.2  000122 ....                 DW      link
    198.3  000124 FF                   DB      0FFh       ; not immediate
    198.4  000125              link    SET     $
    198.5  000125 04                   DB      4
    198.6  000126 4F564552             DB      'OVER'
    198.7  00012A                      EVEN
    198.8  00012A                      IF      'DOCODE'='DOCODE'
    198.9  00012A ....         OVER: DW     $+2
    198.10 00012C                      ELSE
    198.11 00012C              OVER: DW      DOCODE
    198.12 00012C                      ENDIF
    198.13 00012C                      ENDM
    199    00012C 2644                 MOV     @PSP,W          ; 2
    200    00012E 2483                 SUB     #2,PSP          ; 2
    201    000130 84470000             MOV     TOS,0(PSP)      ; 4
    202    000134 0746                 MOV     W,TOS           ; 1
    203    000136                      NEXT                    ; 4
    203.1  000136 3645                 MOV @IP+,W     // ; fetch word address
                                                                    into
                                                                    W
    203.2  000138 3046                 MOV @W+,PC     // ; fetch code address
                                                                    into PC,
                                                                    W=PFA
    203.3  00013A                      ENDM
    204    00013A              
    205    00013A              ;C ROT    x1 x2 x3 -- x2 x3 x1  per stack
                                diagram
    206    00013A                      HEADER  ROT,3,'ROT',DOCODE
    206.1  000000                      PUBLIC  ROT
    206.2  00013A ....                 DW      link
    206.3  00013C FF                   DB      0FFh       ; not immediate
    206.4  00013D              link    SET     $
    206.5  00013D 03                   DB      3
    206.6  00013E 524F54               DB      'ROT'
    206.7  000141 00                   EVEN
    206.8  000142                      IF      'DOCODE'='DOCODE'
    206.9  000142 ....         ROT: DW     $+2
    206.10 000144                      ELSE
    206.11 000144              ROT: DW      DOCODE
    206.12 000144                      ENDIF
    206.13 000144                      ENDM
    207    000144 2644                 MOV     @PSP,W          ; 2 fetch
                                                                x2
    208    000146 84470000             MOV     TOS,0(PSP)      ; 4 store
                                                                x3
    209    00014A 17440200             MOV     2(PSP),TOS      ; 3 fetch
                                                                x1
    210    00014E 84460200             MOV     W,2(PSP)        ; 4 store
                                                                x2
    211    000152                      NEXT                    ; 4
    211.1  000152 3645                 MOV @IP+,W     // ; fetch word address
                                                                    into
                                                                    W
    211.2  000154 3046                 MOV @W+,PC     // ; fetch code address
                                                                    into PC,
                                                                    W=PFA
    211.3  000156                      ENDM
    212    000156              
    213    000156              ;X NIP    x1 x2 -- x2           per stack
                                diagram
    214    000156                      HEADER  NIP,3,'NIP',DOCODE
    214.1  000000                      PUBLIC  NIP
    214.2  000156 ....                 DW      link
    214.3  000158 FF                   DB      0FFh       ; not immediate
    214.4  000159              link    SET     $
    214.5  000159 03                   DB      3
    214.6  00015A 4E4950               DB      'NIP'
    214.7  00015D 00                   EVEN
    214.8  00015E                      IF      'DOCODE'='DOCODE'
    214.9  00015E ....         NIP: DW     $+2
    214.10 000160                      ELSE
    214.11 000160              NIP: DW      DOCODE
    214.12 000160                      ENDIF
    214.13 000160                      ENDM
    215    000160 2453                 ADD     #2,PSP          ; 1
    216    000162                      NEXT                    ; 4
    216.1  000162 3645                 MOV @IP+,W     // ; fetch word address
                                                                    into
                                                                    W
    216.2  000164 3046                 MOV @W+,PC     // ; fetch code address
                                                                    into PC,
                                                                    W=PFA
    216.3  000166                      ENDM
    217    000166              
    218    000166              ;C >R    x -- R: -- x      push to return
                                stack
    219    000166                      HEADER  TOR,2,'>R',DOCODE
    219.1  000000                      PUBLIC  TOR
    219.2  000166 ....                 DW      link
    219.3  000168 FF                   DB      0FFh       ; not immediate
    219.4  000169              link    SET     $
    219.5  000169 02                   DB      2
    219.6  00016A 3E52                 DB      '>R'
    219.7  00016C                      EVEN
    219.8  00016C                      IF      'DOCODE'='DOCODE'
    219.9  00016C ....         TOR: DW     $+2
    219.10 00016E                      ELSE
    219.11 00016E              TOR: DW      DOCODE
    219.12 00016E                      ENDIF
    219.13 00016E                      ENDM
    220    00016E 0712                 PUSH TOS
    221    000170 3744                 MOV @PSP+,TOS
    222    000172                      NEXT
    222.1  000172 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
    222.2  000174 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
    222.3  000176                      ENDM
    223    000176              
    224    000176              ;C R>    -- x R: x --     pop from return
                                stack
    225    000176                      HEADER  RFROM,2,'R>',DOCODE
    225.1  000000                      PUBLIC  RFROM
    225.2  000176 ....                 DW      link
    225.3  000178 FF                   DB      0FFh       ; not immediate
    225.4  000179              link    SET     $
    225.5  000179 02                   DB      2
    225.6  00017A 523E                 DB      'R>'
    225.7  00017C                      EVEN
    225.8  00017C                      IF      'DOCODE'='DOCODE'
    225.9  00017C ....         RFROM: DW     $+2
    225.10 00017E                      ELSE
    225.11 00017E              RFROM: DW      DOCODE
    225.12 00017E                      ENDIF
    225.13 00017E                      ENDM
    226    00017E 2483                 SUB #2,PSP      ; 2
    227    000180 84470000             MOV TOS,0(PSP)    ; 4
    228    000184 3741                 MOV @RSP+,TOS
    229    000186                      NEXT
    229.1  000186 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
    229.2  000188 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
    229.3  00018A                      ENDM
    230    00018A              
    231    00018A              ;C R@    -- x R: x -- x     fetch from rtn
                                stk
    232    00018A                      HEADER  RFETCH,2,'R@',DOCODE
    232.1  000000                      PUBLIC  RFETCH
    232.2  00018A ....                 DW      link
    232.3  00018C FF                   DB      0FFh       ; not immediate
    232.4  00018D              link    SET     $
    232.5  00018D 02                   DB      2
    232.6  00018E 5240                 DB      'R@'
    232.7  000190                      EVEN
    232.8  000190                      IF      'DOCODE'='DOCODE'
    232.9  000190 ....         RFETCH: DW     $+2
    232.10 000192                      ELSE
    232.11 000192              RFETCH: DW      DOCODE
    232.12 000192                      ENDIF
    232.13 000192                      ENDM
    233    000192 2483                 SUB #2,PSP
    234    000194 84470000             MOV TOS,0(PSP)
    235    000198 2741                 MOV @RSP,TOS
    236    00019A                      NEXT
    236.1  00019A 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
    236.2  00019C 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
    236.3  00019E                      ENDM
    237    00019E              
    238    00019E              ;Z SP@  -- a-addr       get data stack
                                pointer
    239    00019E                      HEADER  SPFETCH,3,'SP@',DOCODE
    239.1  000000                      PUBLIC  SPFETCH
    239.2  00019E ....                 DW      link
    239.3  0001A0 FF                   DB      0FFh       ; not immediate
    239.4  0001A1              link    SET     $
    239.5  0001A1 03                   DB      3
    239.6  0001A2 535040               DB      'SP@'
    239.7  0001A5 00                   EVEN
    239.8  0001A6                      IF      'DOCODE'='DOCODE'
    239.9  0001A6 ....         SPFETCH: DW     $+2
    239.10 0001A8                      ELSE
    239.11 0001A8              SPFETCH: DW      DOCODE
    239.12 0001A8                      ENDIF
    239.13 0001A8                      ENDM
    240    0001A8 2483                 SUB #2,PSP
    241    0001AA 84470000             MOV TOS,0(PSP)
    242    0001AE 0744                 MOV PSP,TOS
    243    0001B0                      NEXT
    243.1  0001B0 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
    243.2  0001B2 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
    243.3  0001B4                      ENDM
    244    0001B4              
    245    0001B4              ;Z SP!  a-addr --       set data stack
                                pointer
    246    0001B4                      HEADER  SPSTORE,3,'SP!',DOCODE
    246.1  000000                      PUBLIC  SPSTORE
    246.2  0001B4 ....                 DW      link
    246.3  0001B6 FF                   DB      0FFh       ; not immediate
    246.4  0001B7              link    SET     $
    246.5  0001B7 03                   DB      3
    246.6  0001B8 535021               DB      'SP!'
    246.7  0001BB 00                   EVEN
    246.8  0001BC                      IF      'DOCODE'='DOCODE'
    246.9  0001BC ....         SPSTORE: DW     $+2
    246.10 0001BE                      ELSE
    246.11 0001BE              SPSTORE: DW      DOCODE
    246.12 0001BE                      ENDIF
    246.13 0001BE                      ENDM
    247    0001BE 0447                 MOV     TOS,PSP
    248    0001C0 3744                 MOV     @PSP+,TOS       ; 2
    249    0001C2                      NEXT
    249.1  0001C2 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
    249.2  0001C4 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
    249.3  0001C6                      ENDM
    250    0001C6              
    251    0001C6              ;Z RP@  -- a-addr       get return stack
                                pointer
    252    0001C6                      HEADER  RPFETCH,3,'RP@',DOCODE
    252.1  000000                      PUBLIC  RPFETCH
    252.2  0001C6 ....                 DW      link
    252.3  0001C8 FF                   DB      0FFh       ; not immediate
    252.4  0001C9              link    SET     $
    252.5  0001C9 03                   DB      3
    252.6  0001CA 525040               DB      'RP@'
    252.7  0001CD 00                   EVEN
    252.8  0001CE                      IF      'DOCODE'='DOCODE'
    252.9  0001CE ....         RPFETCH: DW     $+2
    252.10 0001D0                      ELSE
    252.11 0001D0              RPFETCH: DW      DOCODE
    252.12 0001D0                      ENDIF
    252.13 0001D0                      ENDM
    253    0001D0 2483                 SUB #2,PSP
    254    0001D2 84470000             MOV TOS,0(PSP)
    255    0001D6 0741                 MOV RSP,TOS
    256    0001D8                      NEXT
    256.1  0001D8 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
    256.2  0001DA 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
    256.3  0001DC                      ENDM
    257    0001DC              
    258    0001DC              ;Z RP!  a-addr --       set return stack
                                pointer
    259    0001DC                      HEADER  RPSTORE,3,'RP!',DOCODE
    259.1  000000                      PUBLIC  RPSTORE
    259.2  0001DC ....                 DW      link
    259.3  0001DE FF                   DB      0FFh       ; not immediate
    259.4  0001DF              link    SET     $
    259.5  0001DF 03                   DB      3
    259.6  0001E0 525021               DB      'RP!'
    259.7  0001E3 00                   EVEN
    259.8  0001E4                      IF      'DOCODE'='DOCODE'
    259.9  0001E4 ....         RPSTORE: DW     $+2
    259.10 0001E6                      ELSE
    259.11 0001E6              RPSTORE: DW      DOCODE
    259.12 0001E6                      ENDIF
    259.13 0001E6                      ENDM
    260    0001E6 0147                 MOV     TOS,RSP
    261    0001E8 3744                 MOV     @PSP+,TOS       ; 2
    262    0001EA                      NEXT
    262.1  0001EA 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
    262.2  0001EC 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
    262.3  0001EE                      ENDM
    263    0001EE              
    264    0001EE              ;X TUCK   x1 x2 -- x2 x1 x2     per stack
                                diagram
    265    0001EE                      HEADER  TUCK,4,'TUCK',DOCOLON
    265.1  000000                      PUBLIC  TUCK
    265.2  0001EE ....                 DW      link
    265.3  0001F0 FF                   DB      0FFh       ; not immediate
    265.4  0001F1              link    SET     $
    265.5  0001F1 04                   DB      4
    265.6  0001F2 5455434B             DB      'TUCK'
    265.7  0001F6                      EVEN
    265.8  0001F6                      IF      'DOCOLON'='DOCODE'
    265.9  0001F6              TUCK: DW     $+2
    265.10 0001F6                      ELSE
    265.11 0001F6 ....         TUCK: DW      DOCOLON
    265.12 0001F8                      ENDIF
    265.13 0001F8                      ENDM
    266    0001F8 ............         DC16    SWAP,OVER,EXIT
    267    0001FE              
    268    0001FE              ; ----------------------------------------------
                               ------------------------
    269    0001FE              ; MEMORY OPERATIONS
    270    0001FE              
    271    0001FE              ;C @       a-addr -- x   fetch cell from
                                memory
    272    0001FE                      HEADER  FETCH,1,'@',DOCODE
    272.1  000000                      PUBLIC  FETCH
    272.2  0001FE ....                 DW      link
    272.3  000200 FF                   DB      0FFh       ; not immediate
    272.4  000201              link    SET     $
    272.5  000201 01                   DB      1
    272.6  000202 40                   DB      '@'
    272.7  000203 00                   EVEN
    272.8  000204                      IF      'DOCODE'='DOCODE'
    272.9  000204 ....         FETCH: DW     $+2
    272.10 000206                      ELSE
    272.11 000206              FETCH: DW      DOCODE
    272.12 000206                      ENDIF
    272.13 000206                      ENDM
    273    000206 2747                 MOV     @TOS,TOS
    274    000208                      NEXT
    274.1  000208 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
    274.2  00020A 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
    274.3  00020C                      ENDM
    275    00020C              
    276    00020C              ;C !        x a-addr --   store cell in
                                memory
    277    00020C                      HEADER  STORE,1,'!',DOCODE
    277.1  000000                      PUBLIC  STORE
    277.2  00020C ....                 DW      link
    277.3  00020E FF                   DB      0FFh       ; not immediate
    277.4  00020F              link    SET     $
    277.5  00020F 01                   DB      1
    277.6  000210 21                   DB      '!'
    277.7  000211 00                   EVEN
    277.8  000212                      IF      'DOCODE'='DOCODE'
    277.9  000212 ....         STORE: DW     $+2
    277.10 000214                      ELSE
    277.11 000214              STORE: DW      DOCODE
    277.12 000214                      ENDIF
    277.13 000214                      ENDM
    278    000214 B7440000             MOV     @PSP+,0(TOS)
    279    000218 3744                 MOV     @PSP+,TOS
    280    00021A                      NEXT
    280.1  00021A 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
    280.2  00021C 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
    280.3  00021E                      ENDM
    281    00021E              
    282    00021E              ;C C@     c-addr -- char   fetch char from
                                memory
    283    00021E                      HEADER  CFETCH,2,'C@',DOCODE
    283.1  000000                      PUBLIC  CFETCH
    283.2  00021E ....                 DW      link
    283.3  000220 FF                   DB      0FFh       ; not immediate
    283.4  000221              link    SET     $
    283.5  000221 02                   DB      2
    283.6  000222 4340                 DB      'C@'
    283.7  000224                      EVEN
    283.8  000224                      IF      'DOCODE'='DOCODE'
    283.9  000224 ....         CFETCH: DW     $+2
    283.10 000226                      ELSE
    283.11 000226              CFETCH: DW      DOCODE
    283.12 000226                      ENDIF
    283.13 000226                      ENDM
    284    000226 6747                 MOV.B   @TOS,TOS
    285    000228                      NEXT
    285.1  000228 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
    285.2  00022A 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
    285.3  00022C                      ENDM
    286    00022C              
    287    00022C              ;C C!      char c-addr --    store char in
                                memory
    288    00022C                      HEADER  CSTORE,2,'C!',DOCODE
    288.1  000000                      PUBLIC  CSTORE
    288.2  00022C ....                 DW      link
    288.3  00022E FF                   DB      0FFh       ; not immediate
    288.4  00022F              link    SET     $
    288.5  00022F 02                   DB      2
    288.6  000230 4321                 DB      'C!'
    288.7  000232                      EVEN
    288.8  000232                      IF      'DOCODE'='DOCODE'
    288.9  000232 ....         CSTORE: DW     $+2
    288.10 000234                      ELSE
    288.11 000234              CSTORE: DW      DOCODE
    288.12 000234                      ENDIF
    288.13 000234                      ENDM
    289    000234 3644                 MOV     @PSP+,W
    290    000236 C7460000             MOV.B   W,0(TOS)
    291    00023A 3744                 MOV     @PSP+,TOS
    292    00023C                      NEXT
    292.1  00023C 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
    292.2  00023E 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
    292.3  000240                      ENDM
    293    000240              
    294    000240              ; FLASH MEMORY OPERATIONS
    295    000240              ; Note that an I! or IC! to a RAM address
                                >FLASHSTART will work -- it 
    296    000240              ; will enable the flash, write the RAM, and then
                                disable the flash.
    297    000240              ; An FLERASE to a RAM address will merely clear
                                that one RAM cell.
    298    000240              
    299    000240              ;Z FLERASE  a-addr n --     erase n bytes of
                                flash, full segment sizes.
    300    000240                      HEADER  FLERASE,7,'FLERASE',DOCODE
    300.1  000000                      PUBLIC  FLERASE
    300.2  000240 ....                 DW      link
    300.3  000242 FF                   DB      0FFh       ; not immediate
    300.4  000243              link    SET     $
    300.5  000243 07                   DB      7
    300.6  000244 464C45524153*        DB      'FLERASE'
    300.7  00024B 00                   EVEN
    300.8  00024C                      IF      'DOCODE'='DOCODE'
    300.9  00024C ....         FLERASE: DW     $+2
    300.10 00024E                      ELSE
    300.11 00024E              FLERASE: DW      DOCODE
    300.12 00024E                      ENDIF
    300.13 00024E                      ENDM
    301    00024E 3644                 MOV     @PSP+,W         ; get address in
                                                                W
    302    000250 0756                 ADD     W,TOS           ; TOS=end adrs
                                                                (first unerased
                                                                adrs)
    303    000252              FLE_1:
    304    000252 0697                 CMP     TOS,W           ; adr-end
    305    000254 272C                 JC      FLE_X           ; if no borrow,
                                                                adr>=end, do
                                                                not erase
    306    000256                      ; is it within Main flash?
    307    000256 369000C0             CMP     #FLASHSTART,W       ; flash
                                                                    start
    308    00025A 0328                 JNC     FLE_INFO        ; if borrow,
                                                                adr<start,
                                                                check if
                                                                Info
    309    00025C 369000E0             CMP     #FLASHEND+1,W     ; flash
                                                                  end
    310    000260 0628                 JNC     FLE_OK          ; if no borrow,
                                                                adr>end, check
                                                                if Info
    311    000262              FLE_INFO: ; is it within Info flash?
    312    000262 36900010             CMP     #INFOSTART,W
    313    000266 1E28                 JNC     FLE_X           ; if borrow,
                                                                adr<start, do
                                                                not erase
    314    000268 36900011             CMP     #INFOEND+1,W
    315    00026C 1B2C                 JC      FLE_X           ; if no borrow,
                                                                adr>end, do not
                                                                erase
    316    00026E              FLE_OK: ; Address is either in Main flash, or in
                                Info flash.
    317    00026E                      ; Segment Erase from flash. 
    318    00026E                      ; Assumes ACCVIE = NMIIE = OFIE = 0,
                                watchdog disabled.
    319    00026E                      ; Per section 5.3.2 of MSP430 Family
                                User's Guide
    320    00026E 32C2                 DINT                    ; Disable
                                                                interrupts
    321    000270 B24000A52C01         MOV #FWKEY,&FCTL3       ; Clear
                                                                LOCK
    322    000276 B24002A52801         MOV #FWKEY+ERASE,&FCTL1 ; Enable segment
                                                                erase
    323    00027C B6430000             MOV     #-1,0(W)        ; Dummy write in
                                                                segment to
                                                                erase
    324    000280 B24000A52801         MOV #FWKEY,&FCTL1       ; Done. Clear
                                                                erase
                                                                command.
    325    000286 B24010A52C01         MOV #FWKEY+LOCK,&FCTL3  ; Done, set
                                                                LOCK
    326    00028C 32D2                 EINT                    ; Enable
                                                                interrupts
    327    00028E                      ; Advance flash pointer by 512 bytes or
                                128 bytes
    328    00028E                      ; is it within Main flash?
    329    00028E 369000C0             CMP     #FLASHSTART,W
    330    000292 0528                 JNC     FL_INFO         ; if borrow,
                                                                adr<start, must
                                                                be Info
    331    000294 369000E0             CMP     #FLASHEND+1,W
    332    000298 022C                 JC      FL_INFO         ; if no borrow,
                                                                adr>end, must
                                                                be Info
    333    00029A 36508001             ADD     #(MAINSEG-INFOSEG),W
    334    00029E 36508000     FL_INFO: ADD    #INFOSEG,W
    335    0002A2 D73F                 JMP     FLE_1           ; continue till
                                                                past end or
                                                                outside
                                                                limits
    336    0002A4 3744         FLE_X:  MOV     @PSP+,TOS
    337    0002A6                      NEXT
    337.1  0002A6 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
    337.2  0002A8 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
    337.3  0002AA                      ENDM
    338    0002AA              
    339    0002AA              ; Program Space (Flash) operators 
    340    0002AA              
    341    0002AA              ;Z I!        x a-addr --   store cell in
                                Instruction memory
    342    0002AA                      HEADER  ISTORE,2,'I!',DOCODE
    342.1  000000                      PUBLIC  ISTORE
    342.2  0002AA ....                 DW      link
    342.3  0002AC FF                   DB      0FFh       ; not immediate
    342.4  0002AD              link    SET     $
    342.5  0002AD 02                   DB      2
    342.6  0002AE 4921                 DB      'I!'
    342.7  0002B0                      EVEN
    342.8  0002B0                      IF      'DOCODE'='DOCODE'
    342.9  0002B0 ....         ISTORE: DW     $+2
    342.10 0002B2                      ELSE
    342.11 0002B2              ISTORE: DW      DOCODE
    342.12 0002B2                      ENDIF
    342.13 0002B2                      ENDM
    343    0002B2 3644                 MOV     @PSP+,W         ; get data to
                                                                write
    344    0002B4 17B3                 BIT     #1,TOS
    345    0002B6 1E20                 JNZ     IST_X           ; if not even
                                                                address, do not
                                                                write
    346    0002B8 2697                 CMP     @TOS,W
    347    0002BA 1C24                 JZ      IST_X           ; if memory is
                                                                desired value,
                                                                do not
                                                                write
    348    0002BC                      ; is it within Main flash?
    349    0002BC 379000C0             CMP     #FLASHSTART,TOS
    350    0002C0 0328                 JNC     IST_INFO        ; if borrow,
                                                                adr<start,
                                                                check if
                                                                Info
    351    0002C2 379000E0             CMP     #FLASHEND+1,TOS
    352    0002C6 0628                 JNC     IST_OK          ; if no borrow,
                                                                adr>end, check
                                                                if Info
    353    0002C8              IST_INFO: ; is it within Info flash?
    354    0002C8 37900010             CMP     #INFOSTART,TOS
    355    0002CC 0A28                 JNC     IST_RAM         ; if borrow,
                                                                adr<start,
                                                                assume it's
                                                                RAM
    356    0002CE 37900011             CMP     #INFOEND+1,TOS
    357    0002D2 072C                 JC      IST_RAM         ; if no borrow,
                                                                adr>end, assume
                                                                it's RAM
    358    0002D4              IST_OK: ; Address is either in Main flash, or in
                                Info flash.
    359    0002D4                      ; Byte/word write from flash. 
    360    0002D4                      ; Assumes location to write is already
                                erased
    361    0002D4                      ; Assumes ACCVIE = NMIIE = OFIE = 0,
                                watchdog disabled.
    362    0002D4                      ; Per section 5.3.3 of MSP430 Family
                                User's Guide
    363    0002D4 32C2                 DINT                    ; Disable
                                                                interrupts
    364    0002D6 B24000A52C01         MOV #FWKEY,&FCTL3       ; Clear
                                                                LOCK
    365    0002DC B24040A52801         MOV #FWKEY+WRT,&FCTL1   ; Enable
                                                                write
    366    0002E2              IST_RAM: ; If RAM, jump here to write. 
                                FCTL1,FCTL3,EINT are superfluous
    367    0002E2 87460000             MOV     W,0(TOS)        ; Write word to
                                                                flash
                                                                location
    368    0002E6 B24000A52801         MOV #FWKEY,&FCTL1       ; Done. Clear
                                                                WRT.
    369    0002EC B24010A52C01         MOV #FWKEY+LOCK,&FCTL3  ; Set LOCK
    370    0002F2 32D2                 EINT                    ; Enable
                                                                interrupts
    371    0002F4 3744         IST_X:  MOV     @PSP+,TOS       ; pop new
                                                                TOS
    372    0002F6                      NEXT
    372.1  0002F6 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
    372.2  0002F8 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
    372.3  0002FA                      ENDM
    373    0002FA              
    374    0002FA              ;Z IC!        x a-addr --   store char in
                                Instruction memory
    375    0002FA                      HEADER  ICSTORE,3,'IC!',DOCODE
    375.1  000000                      PUBLIC  ICSTORE
    375.2  0002FA ....                 DW      link
    375.3  0002FC FF                   DB      0FFh       ; not immediate
    375.4  0002FD              link    SET     $
    375.5  0002FD 03                   DB      3
    375.6  0002FE 494321               DB      'IC!'
    375.7  000301 00                   EVEN
    375.8  000302                      IF      'DOCODE'='DOCODE'
    375.9  000302 ....         ICSTORE: DW     $+2
    375.10 000304                      ELSE
    375.11 000304              ICSTORE: DW      DOCODE
    375.12 000304                      ENDIF
    375.13 000304                      ENDM
    376    000304 3644                 MOV     @PSP+,W         ; get data to
                                                                write
    377    000306 6697                 CMP.B   @TOS,W
    378    000308 F527                 JZ      IST_X           ; if memory is
                                                                desired value,
                                                                do not
                                                                write
    379    00030A                      ; is it within Main flash?
    380    00030A 379000C0             CMP     #FLASHSTART,TOS
    381    00030E 0328                 JNC     ICST_INFO       ; if borrow,
                                                                adr<start,
                                                                check if
                                                                Info
    382    000310 379000E0             CMP     #FLASHEND+1,TOS
    383    000314 0628                 JNC     ICST_OK         ; if no borrow,
                                                                adr>end, check
                                                                if Info
    384    000316              ICST_INFO: ; is it within Info flash?
    385    000316 37900010             CMP     #INFOSTART,TOS
    386    00031A 0A28                 JNC     ICST_RAM        ; if borrow,
                                                                adr<start,
                                                                assume it's
                                                                RAM
    387    00031C 37900011             CMP     #INFOEND+1,TOS
    388    000320 072C                 JC      ICST_RAM        ; if no borrow,
                                                                adr>end, assume
                                                                it's RAM
    389    000322              ICST_OK: ; Address is either in Main flash, or
                                in Info flash.
    390    000322                      ; Byte/word write from flash. 
    391    000322                      ; Assumes location to write is already
                                erased
    392    000322                      ; Assumes ACCVIE = NMIIE = OFIE = 0,
                                watchdog disabled.
    393    000322                      ; Per section 5.3.3 of MSP430 Family
                                User's Guide
    394    000322 32C2                 DINT                    ; Disable
                                                                interrupts
    395    000324 B24000A52C01         MOV #FWKEY,&FCTL3       ; Clear
                                                                LOCK
    396    00032A B24040A52801         MOV #FWKEY+WRT,&FCTL1   ; Enable
                                                                write
    397    000330              ICST_RAM: ; If RAM, jump here to write. 
                                FCTL1,FCTL3,EINT are superfluous
    398    000330 C7460000             MOV.B   W,0(TOS)        ; Write byte to
                                                                flash
                                                                location
    399    000334 B24000A52801         MOV #FWKEY,&FCTL1       ; Done. Clear
                                                                WRT.
    400    00033A B24010A52C01         MOV #FWKEY+LOCK,&FCTL3  ; Set LOCK
    401    000340 32D2                 EINT                    ; Enable
                                                                interrupts
    402    000342 D83F                 JMP     IST_X
    403    000344              
    404    000344              /*
    405    000344              ;Z I@       a-addr -- x   fetch cell from
                                Instruction memory
    406    000344                      HEADER  IFETCH,2,'I@',FETCH+2
    407    000344              
    408    000344              ;Z IC@       a-addr -- x   fetch char from
                                Instruction memory
    409    000344                      HEADER  ICFETCH,3,'IC@',CFETCH+2
    410    000344              */
    411    000344              #define IFETCH FETCH
    412    000344              #define ICFETCH CFETCH
    413    000344              
    414    000344              
    415    000344              
    416    000344              ;Z D->I     c-addr1 c-addr2 u --  move
                                Data->Code
    417    000344              ; Block move from Data space to Code space. 
                                Flashable.
    418    000344              ; For the MSP430, this uses a "smart" algorithm
                                that uses word writes,
    419    000344              ; rather than byte writes, whenever possible. 
                                Note that byte reads
    420    000344              ; are used for the source, so it need not be
                                aligned.
    421    000344                      HEADER  DTOI,4,'D->I',DOCODE
    421.1  000000                      PUBLIC  DTOI
    421.2  000344 ....                 DW      link
    421.3  000346 FF                   DB      0FFh       ; not immediate
    421.4  000347              link    SET     $
    421.5  000347 04                   DB      4
    421.6  000348 442D3E49             DB      'D->I'
    421.7  00034C                      EVEN
    421.8  00034C                      IF      'DOCODE'='DOCODE'
    421.9  00034C ....         DTOI: DW     $+2
    421.10 00034E                      ELSE
    421.11 00034E              DTOI: DW      DOCODE
    421.12 00034E                      ENDIF
    421.13 00034E                      ENDM
    422    00034E 3644                 MOV     @PSP+,W     ; dest adrs
    423    000350 3A44                 MOV     @PSP+,X     ; src adrs
    424    000352 0793                 CMP     #0,TOS
    425    000354 2024                 JZ      DTOI_X
    426    000356              DTOI_LOOP: ; Begin flash write sequence
    427    000356 32C2                 DINT                    ; Disable
                                                                interrupts
    428    000358 B24000A52C01         MOV #FWKEY,&FCTL3       ; Clear
                                                                LOCK
    429    00035E B24040A52801         MOV #FWKEY+WRT,&FCTL1   ; Enable
                                                                write
    430    000364                      ; If length is 1, or dest. address is
                                odd, do a byte write.
    431    000364                      ; Else, do a word write.
    432    000364 1793                 CMP     #1,TOS
    433    000366 0B24                 JZ      DTOI_BYTE
    434    000368 16B3                 BIT     #1,W
    435    00036A 0920                 JNZ     DTOI_BYTE
    436    00036C 7B4A         DTOI_WORD: MOV.B @X+,Y          ; get low byte
                                                                of word
    437    00036E 7C4A                 MOV.B   @X+,Q           ; get high byte
                                                                of word
    438    000370 8C10                 SWPB    Q
    439    000372 0BDC                 BIS     Q,Y             ; merge
                                                                bytes
    440    000374 864B0000             MOV.W   Y,0(W)          ; write byte to
                                                                dest 
    441    000378 2653                 ADD     #2,W
    442    00037A 1783                 SUB     #1,TOS          ; another 1 will
                                                                be subtracted
                                                                below
    443    00037C 033C                 JMP     DTOI_END
    444    00037E F64A0000     DTOI_BYTE: MOV.B  @X+,0(W)      ; copy byte from
                                                                src to
                                                                dest
    445    000382 1653                 ADD     #1,W
    446    000384              DTOI_END: ; End flash write sequence
    447    000384 B24000A52801         MOV #FWKEY,&FCTL1       ; Done. Clear
                                                                WRT.
    448    00038A B24010A52C01         MOV #FWKEY+LOCK,&FCTL3  ; Set LOCK
    449    000390 32D2                 EINT                    ; Enable
                                                                interrupts
    450    000392 1783                 SUB     #1,TOS
    451    000394 E023                 JNZ     DTOI_LOOP
    452    000396 3744         DTOI_X: MOV     @PSP+,TOS       ; pop new
                                                                TOS
    453    000398                      NEXT
    453.1  000398 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
    453.2  00039A 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
    453.3  00039C                      ENDM
    454    00039C              
    455    00039C              ; ----------------------------------------------
                               ------------------------
    456    00039C              ; ARITHMETIC OPERATIONS
    457    00039C              
    458    00039C              ;C +       n1/u1 n2/u2 -- n3/u3     add
                                n1+n2
    459    00039C                      HEADER  PLUS,1,'+',DOCODE
    459.1  000000                      PUBLIC  PLUS
    459.2  00039C ....                 DW      link
    459.3  00039E FF                   DB      0FFh       ; not immediate
    459.4  00039F              link    SET     $
    459.5  00039F 01                   DB      1
    459.6  0003A0 2B                   DB      '+'
    459.7  0003A1 00                   EVEN
    459.8  0003A2                      IF      'DOCODE'='DOCODE'
    459.9  0003A2 ....         PLUS: DW     $+2
    459.10 0003A4                      ELSE
    459.11 0003A4              PLUS: DW      DOCODE
    459.12 0003A4                      ENDIF
    459.13 0003A4                      ENDM
    460    0003A4 3754                 ADD     @PSP+,TOS
    461    0003A6                      NEXT
    461.1  0003A6 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
    461.2  0003A8 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
    461.3  0003AA                      ENDM
    462    0003AA              
    463    0003AA              ;C +!     n/u a-addr --       add cell to
                                memory
    464    0003AA                      HEADER  PLUSSTORE,2,'+!',DOCODE
    464.1  000000                      PUBLIC  PLUSSTORE
    464.2  0003AA ....                 DW      link
    464.3  0003AC FF                   DB      0FFh       ; not immediate
    464.4  0003AD              link    SET     $
    464.5  0003AD 02                   DB      2
    464.6  0003AE 2B21                 DB      '+!'
    464.7  0003B0                      EVEN
    464.8  0003B0                      IF      'DOCODE'='DOCODE'
    464.9  0003B0 ....         PLUSSTORE: DW     $+2
    464.10 0003B2                      ELSE
    464.11 0003B2              PLUSSTORE: DW      DOCODE
    464.12 0003B2                      ENDIF
    464.13 0003B2                      ENDM
    465    0003B2 B7540000             ADD     @PSP+,0(TOS)
    466    0003B6 3744                 MOV     @PSP+,TOS
    467    0003B8                      NEXT
    467.1  0003B8 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
    467.2  0003BA 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
    467.3  0003BC                      ENDM
    468    0003BC              
    469    0003BC              ;X M+       d n -- d         add single to
                                double
    470    0003BC                      HEADER  MPLUS,2,'M+',DOCODE
    470.1  000000                      PUBLIC  MPLUS
    470.2  0003BC ....                 DW      link
    470.3  0003BE FF                   DB      0FFh       ; not immediate
    470.4  0003BF              link    SET     $
    470.5  0003BF 02                   DB      2
    470.6  0003C0 4D2B                 DB      'M+'
    470.7  0003C2                      EVEN
    470.8  0003C2                      IF      'DOCODE'='DOCODE'
    470.9  0003C2 ....         MPLUS: DW     $+2
    470.10 0003C4                      ELSE
    470.11 0003C4              MPLUS: DW      DOCODE
    470.12 0003C4                      ENDIF
    470.13 0003C4                      ENDM
    471    0003C4 84570200             ADD     TOS,2(PSP)
    472    0003C8 84630000             ADDC    #0,0(PSP)
    473    0003CC 3744                 MOV     @PSP+,TOS
    474    0003CE                      NEXT
    474.1  0003CE 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
    474.2  0003D0 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
    474.3  0003D2                      ENDM
    475    0003D2              
    476    0003D2              ;C -      n1/u1 n2/u2 -- n3/u3    subtract
                                n1-n2
    477    0003D2                      HEADER  MINUS,1,'-',DOCODE
    477.1  000000                      PUBLIC  MINUS
    477.2  0003D2 ....                 DW      link
    477.3  0003D4 FF                   DB      0FFh       ; not immediate
    477.4  0003D5              link    SET     $
    477.5  0003D5 01                   DB      1
    477.6  0003D6 2D                   DB      '-'
    477.7  0003D7 00                   EVEN
    477.8  0003D8                      IF      'DOCODE'='DOCODE'
    477.9  0003D8 ....         MINUS: DW     $+2
    477.10 0003DA                      ELSE
    477.11 0003DA              MINUS: DW      DOCODE
    477.12 0003DA                      ENDIF
    477.13 0003DA                      ENDM
    478    0003DA 3644                 MOV     @PSP+,W
    479    0003DC 0687                 SUB     TOS,W
    480    0003DE 0746                 MOV     W,TOS
    481    0003E0                      NEXT
    481.1  0003E0 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
    481.2  0003E2 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
    481.3  0003E4                      ENDM
    482    0003E4              
    483    0003E4              ;C AND    x1 x2 -- x3            logical
                                AND
    484    0003E4                      HEADER  ANDD,3,'AND',DOCODE
    484.1  000000                      PUBLIC  ANDD
    484.2  0003E4 ....                 DW      link
    484.3  0003E6 FF                   DB      0FFh       ; not immediate
    484.4  0003E7              link    SET     $
    484.5  0003E7 03                   DB      3
    484.6  0003E8 414E44               DB      'AND'
    484.7  0003EB 00                   EVEN
    484.8  0003EC                      IF      'DOCODE'='DOCODE'
    484.9  0003EC ....         ANDD: DW     $+2
    484.10 0003EE                      ELSE
    484.11 0003EE              ANDD: DW      DOCODE
    484.12 0003EE                      ENDIF
    484.13 0003EE                      ENDM
    485    0003EE 37F4                 AND     @PSP+,TOS
    486    0003F0                      NEXT
    486.1  0003F0 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
    486.2  0003F2 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
    486.3  0003F4                      ENDM
    487    0003F4              
    488    0003F4              ;C OR     x1 x2 -- x3           logical
                                OR
    489    0003F4                      HEADER  ORR,2,'OR',DOCODE
    489.1  000000                      PUBLIC  ORR
    489.2  0003F4 ....                 DW      link
    489.3  0003F6 FF                   DB      0FFh       ; not immediate
    489.4  0003F7              link    SET     $
    489.5  0003F7 02                   DB      2
    489.6  0003F8 4F52                 DB      'OR'
    489.7  0003FA                      EVEN
    489.8  0003FA                      IF      'DOCODE'='DOCODE'
    489.9  0003FA ....         ORR: DW     $+2
    489.10 0003FC                      ELSE
    489.11 0003FC              ORR: DW      DOCODE
    489.12 0003FC                      ENDIF
    489.13 0003FC                      ENDM
    490    0003FC 37D4                 BIS     @PSP+,TOS
    491    0003FE                      NEXT
    491.1  0003FE 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
    491.2  000400 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
    491.3  000402                      ENDM
    492    000402              
    493    000402              ;C XOR    x1 x2 -- x3            logical
                                XOR
    494    000402                      HEADER  XORR,3,'XOR',DOCODE
    494.1  000000                      PUBLIC  XORR
    494.2  000402 ....                 DW      link
    494.3  000404 FF                   DB      0FFh       ; not immediate
    494.4  000405              link    SET     $
    494.5  000405 03                   DB      3
    494.6  000406 584F52               DB      'XOR'
    494.7  000409 00                   EVEN
    494.8  00040A                      IF      'DOCODE'='DOCODE'
    494.9  00040A ....         XORR: DW     $+2
    494.10 00040C                      ELSE
    494.11 00040C              XORR: DW      DOCODE
    494.12 00040C                      ENDIF
    494.13 00040C                      ENDM
    495    00040C 37E4                 XOR     @PSP+,TOS
    496    00040E                      NEXT
    496.1  00040E 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
    496.2  000410 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
    496.3  000412                      ENDM
    497    000412              
    498    000412              ;C INVERT   x1 -- x2            bitwise
                                inversion
    499    000412                      HEADER  INVERT,6,'INVERT',DOCODE
    499.1  000000                      PUBLIC  INVERT
    499.2  000412 ....                 DW      link
    499.3  000414 FF                   DB      0FFh       ; not immediate
    499.4  000415              link    SET     $
    499.5  000415 06                   DB      6
    499.6  000416 494E56455254         DB      'INVERT'
    499.7  00041C                      EVEN
    499.8  00041C                      IF      'DOCODE'='DOCODE'
    499.9  00041C ....         INVERT: DW     $+2
    499.10 00041E                      ELSE
    499.11 00041E              INVERT: DW      DOCODE
    499.12 00041E                      ENDIF
    499.13 00041E                      ENDM
    500    00041E 37E3                 XOR     #-1,TOS
    501    000420                      NEXT
    501.1  000420 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
    501.2  000422 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
    501.3  000424                      ENDM
    502    000424              
    503    000424              ;C NEGATE   x1 -- x2            two's complement
    504    000424                      HEADER  NEGATE,6,'NEGATE',DOCODE
    504.1  000000                      PUBLIC  NEGATE
    504.2  000424 ....                 DW      link
    504.3  000426 FF                   DB      0FFh       ; not immediate
    504.4  000427              link    SET     $
    504.5  000427 06                   DB      6
    504.6  000428 4E4547415445         DB      'NEGATE'
    504.7  00042E                      EVEN
    504.8  00042E                      IF      'DOCODE'='DOCODE'
    504.9  00042E ....         NEGATE: DW     $+2
    504.10 000430                      ELSE
    504.11 000430              NEGATE: DW      DOCODE
    504.12 000430                      ENDIF
    504.13 000430                      ENDM
    505    000430 37E3                 XOR     #-1,TOS
    506    000432 1753                 ADD     #1,TOS
    507    000434                      NEXT
    507.1  000434 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
    507.2  000436 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
    507.3  000438                      ENDM
    508    000438              
    509    000438              ;C 1+      n1/u1 -- n2/u2       add 1 to
                                TOS
    510    000438                      HEADER  ONEPLUS,2,'1+',DOCODE
    510.1  000000                      PUBLIC  ONEPLUS
    510.2  000438 ....                 DW      link
    510.3  00043A FF                   DB      0FFh       ; not immediate
    510.4  00043B              link    SET     $
    510.5  00043B 02                   DB      2
    510.6  00043C 312B                 DB      '1+'
    510.7  00043E                      EVEN
    510.8  00043E                      IF      'DOCODE'='DOCODE'
    510.9  00043E ....         ONEPLUS: DW     $+2
    510.10 000440                      ELSE
    510.11 000440              ONEPLUS: DW      DOCODE
    510.12 000440                      ENDIF
    510.13 000440                      ENDM
    511    000440 1753                 ADD     #1,TOS
    512    000442                      NEXT
    512.1  000442 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
    512.2  000444 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
    512.3  000446                      ENDM
    513    000446              
    514    000446              ;C 1-      n1/u1 -- n2/u2     subtract 1 from
                                TOS
    515    000446                      HEADER  ONEMINUS,2,'1-',DOCODE
    515.1  000000                      PUBLIC  ONEMINUS
    515.2  000446 ....                 DW      link
    515.3  000448 FF                   DB      0FFh       ; not immediate
    515.4  000449              link    SET     $
    515.5  000449 02                   DB      2
    515.6  00044A 312D                 DB      '1-'
    515.7  00044C                      EVEN
    515.8  00044C                      IF      'DOCODE'='DOCODE'
    515.9  00044C ....         ONEMINUS: DW     $+2
    515.10 00044E                      ELSE
    515.11 00044E              ONEMINUS: DW      DOCODE
    515.12 00044E                      ENDIF
    515.13 00044E                      ENDM
    516    00044E 1783                 SUB     #1,TOS
    517    000450                      NEXT
    517.1  000450 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
    517.2  000452 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
    517.3  000454                      ENDM
    518    000454              
    519    000454              ;Z ><      x1 -- x2         swap bytes (not
                                ANSI)
    520    000454                      HEADER  SWAPBYTES,2,'><',DOCODE
    520.1  000000                      PUBLIC  SWAPBYTES
    520.2  000454 ....                 DW      link
    520.3  000456 FF                   DB      0FFh       ; not immediate
    520.4  000457              link    SET     $
    520.5  000457 02                   DB      2
    520.6  000458 3E3C                 DB      '><'
    520.7  00045A                      EVEN
    520.8  00045A                      IF      'DOCODE'='DOCODE'
    520.9  00045A ....         SWAPBYTES: DW     $+2
    520.10 00045C                      ELSE
    520.11 00045C              SWAPBYTES: DW      DOCODE
    520.12 00045C                      ENDIF
    520.13 00045C                      ENDM
    521    00045C 8710                 SWPB    TOS
    522    00045E                      NEXT
    522.1  00045E 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
    522.2  000460 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
    522.3  000462                      ENDM
    523    000462              
    524    000462              ;C 2*      x1 -- x2         arithmetic left
                                shift
    525    000462                      HEADER  TWOSTAR,2,'2*',DOCODE
    525.1  000000                      PUBLIC  TWOSTAR
    525.2  000462 ....                 DW      link
    525.3  000464 FF                   DB      0FFh       ; not immediate
    525.4  000465              link    SET     $
    525.5  000465 02                   DB      2
    525.6  000466 322A                 DB      '2*'
    525.7  000468                      EVEN
    525.8  000468                      IF      'DOCODE'='DOCODE'
    525.9  000468 ....         TWOSTAR: DW     $+2
    525.10 00046A                      ELSE
    525.11 00046A              TWOSTAR: DW      DOCODE
    525.12 00046A                      ENDIF
    525.13 00046A                      ENDM
    526    00046A 0757                 ADD     TOS,TOS
    527    00046C                      NEXT
    527.1  00046C 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
    527.2  00046E 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
    527.3  000470                      ENDM
    528    000470              
    529    000470              ;C 2/      x1 -- x2        arithmetic right
                                shift
    530    000470                      HEADER  TWOSLASH,2,'2/',DOCODE
    530.1  000000                      PUBLIC  TWOSLASH
    530.2  000470 ....                 DW      link
    530.3  000472 FF                   DB      0FFh       ; not immediate
    530.4  000473              link    SET     $
    530.5  000473 02                   DB      2
    530.6  000474 322F                 DB      '2/'
    530.7  000476                      EVEN
    530.8  000476                      IF      'DOCODE'='DOCODE'
    530.9  000476 ....         TWOSLASH: DW     $+2
    530.10 000478                      ELSE
    530.11 000478              TWOSLASH: DW      DOCODE
    530.12 000478                      ENDIF
    530.13 000478                      ENDM
    531    000478 0711                 RRA     TOS
    532    00047A                      NEXT
    532.1  00047A 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
    532.2  00047C 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
    532.3  00047E                      ENDM
    533    00047E              
    534    00047E              ;C LSHIFT  x1 u -- x2    logical L shift u
                                places
    535    00047E                      HEADER  LSHIFT,6,'LSHIFT',DOCODE
    535.1  000000                      PUBLIC  LSHIFT
    535.2  00047E ....                 DW      link
    535.3  000480 FF                   DB      0FFh       ; not immediate
    535.4  000481              link    SET     $
    535.5  000481 06                   DB      6
    535.6  000482 4C5348494654         DB      'LSHIFT'
    535.7  000488                      EVEN
    535.8  000488                      IF      'DOCODE'='DOCODE'
    535.9  000488 ....         LSHIFT: DW     $+2
    535.10 00048A                      ELSE
    535.11 00048A              LSHIFT: DW      DOCODE
    535.12 00048A                      ENDIF
    535.13 00048A                      ENDM
    536    00048A 3644                 MOV     @PSP+,W
    537    00048C 37F01F00             AND     #1Fh,TOS        ; no need to
                                                                shift more than
                                                                16
    538    000490 0324                 JZ      LSH_X
    539    000492 0656         LSH_1:  ADD     W,W
    540    000494 1783                 SUB     #1,TOS
    541    000496 FD23                 JNZ     LSH_1
    542    000498 0746         LSH_X:  MOV     W,TOS
    543    00049A                      NEXT
    543.1  00049A 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
    543.2  00049C 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
    543.3  00049E                      ENDM
    544    00049E              
    545    00049E              ;C RSHIFT  x1 u -- x2    logical R shift u
                                places
    546    00049E                      HEADER  RSHIFT,6,'RSHIFT',DOCODE
    546.1  000000                      PUBLIC  RSHIFT
    546.2  00049E ....                 DW      link
    546.3  0004A0 FF                   DB      0FFh       ; not immediate
    546.4  0004A1              link    SET     $
    546.5  0004A1 06                   DB      6
    546.6  0004A2 525348494654         DB      'RSHIFT'
    546.7  0004A8                      EVEN
    546.8  0004A8                      IF      'DOCODE'='DOCODE'
    546.9  0004A8 ....         RSHIFT: DW     $+2
    546.10 0004AA                      ELSE
    546.11 0004AA              RSHIFT: DW      DOCODE
    546.12 0004AA                      ENDIF
    546.13 0004AA                      ENDM
    547    0004AA 3644                 MOV     @PSP+,W
    548    0004AC 37F01F00             AND     #1Fh,TOS        ; no need to
                                                                shift more than
                                                                16
    549    0004B0 0424                 JZ      RSH_X
    550    0004B2 12C3         RSH_1:  CLRC
    551    0004B4 0610                 RRC     W
    552    0004B6 1783                 SUB     #1,TOS
    553    0004B8 FC23                 JNZ     RSH_1
    554    0004BA 0746         RSH_X:  MOV     W,TOS
    555    0004BC                      NEXT
    555.1  0004BC 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
    555.2  0004BE 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
    555.3  0004C0                      ENDM
    556    0004C0              
    557    0004C0              ; ----------------------------------------------
                               ------------------------
    558    0004C0              ; COMPARISON OPERATIONS 
    559    0004C0              
    560    0004C0              ;C 0=     n/u -- flag    return true if
                                TOS=0
    561    0004C0                      HEADER ZEROEQUAL,2,'0=',DOCODE
    561.1  000000                      PUBLIC  ZEROEQUAL
    561.2  0004C0 ....                 DW      link
    561.3  0004C2 FF                   DB      0FFh       ; not immediate
    561.4  0004C3              link    SET     $
    561.5  0004C3 02                   DB      2
    561.6  0004C4 303D                 DB      '0='
    561.7  0004C6                      EVEN
    561.8  0004C6                      IF      'DOCODE'='DOCODE'
    561.9  0004C6 ....         ZEROEQUAL: DW     $+2
    561.10 0004C8                      ELSE
    561.11 0004C8              ZEROEQUAL: DW      DOCODE
    561.12 0004C8                      ENDIF
    561.13 0004C8                      ENDM
    562    0004C8 1783                 SUB     #1,TOS      ; borrow (clear cy)
                                                            if TOS was
                                                            0
    563    0004CA 0777                 SUBC    TOS,TOS     ; TOS=-1 if borrow
                                                            was set
    564    0004CC                      NEXT
    564.1  0004CC 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
    564.2  0004CE 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
    564.3  0004D0                      ENDM
    565    0004D0              
    566    0004D0              ;C 0<     n -- flag      true if TOS negative
    567    0004D0                      HEADER ZEROLESS,2,'0<',DOCODE
    567.1  000000                      PUBLIC  ZEROLESS
    567.2  0004D0 ....                 DW      link
    567.3  0004D2 FF                   DB      0FFh       ; not immediate
    567.4  0004D3              link    SET     $
    567.5  0004D3 02                   DB      2
    567.6  0004D4 303C                 DB      '0<'
    567.7  0004D6                      EVEN
    567.8  0004D6                      IF      'DOCODE'='DOCODE'
    567.9  0004D6 ....         ZEROLESS: DW     $+2
    567.10 0004D8                      ELSE
    567.11 0004D8              ZEROLESS: DW      DOCODE
    567.12 0004D8                      ENDIF
    567.13 0004D8                      ENDM
    568    0004D8 0757                 ADD     TOS,TOS     ; set cy if TOS
                                                            negative
    569    0004DA 0777                 SUBC    TOS,TOS     ; TOS=-1 if carry
                                                            was clear
    570    0004DC 37E3                 XOR     #-1,TOS     ; TOS=-1 if carry
                                                            was set
    571    0004DE                      NEXT
    571.1  0004DE 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
    571.2  0004E0 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
    571.3  0004E2                      ENDM
    572    0004E2              
    573    0004E2              ;C =      x1 x2 -- flag         test x1=x2
    574    0004E2                      HEADER EQUAL,1,'=',DOCODE
    574.1  000000                      PUBLIC  EQUAL
    574.2  0004E2 ....                 DW      link
    574.3  0004E4 FF                   DB      0FFh       ; not immediate
    574.4  0004E5              link    SET     $
    574.5  0004E5 01                   DB      1
    574.6  0004E6 3D                   DB      '='
    574.7  0004E7 00                   EVEN
    574.8  0004E8                      IF      'DOCODE'='DOCODE'
    574.9  0004E8 ....         EQUAL: DW     $+2
    574.10 0004EA                      ELSE
    574.11 0004EA              EQUAL: DW      DOCODE
    574.12 0004EA                      ENDIF
    574.13 0004EA                      ENDM
    575    0004EA 3644                 MOV     @PSP+,W
    576    0004EC 0687                 SUB     TOS,W       ; x1-x2 in W, flags
                                                            set
    577    0004EE 1124                 JZ      TOSTRUE
    578    0004F0 0743         TOSFALSE: MOV   #0,TOS
    579    0004F2                      NEXT
    579.1  0004F2 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
    579.2  0004F4 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
    579.3  0004F6                      ENDM
    580    0004F6              
    581    0004F6              ;X <>     x1 x2 -- flag    test not eq (not
                                ANSI)
    582    0004F6                      HEADER NOTEQUAL,2,'<>',DOCOLON
    582.1  000000                      PUBLIC  NOTEQUAL
    582.2  0004F6 ....                 DW      link
    582.3  0004F8 FF                   DB      0FFh       ; not immediate
    582.4  0004F9              link    SET     $
    582.5  0004F9 02                   DB      2
    582.6  0004FA 3C3E                 DB      '<>'
    582.7  0004FC                      EVEN
    582.8  0004FC                      IF      'DOCOLON'='DOCODE'
    582.9  0004FC              NOTEQUAL: DW     $+2
    582.10 0004FC                      ELSE
    582.11 0004FC ....         NOTEQUAL: DW      DOCOLON
    582.12 0004FE                      ENDIF
    582.13 0004FE                      ENDM
    583    0004FE ............         DW EQUAL,ZEROEQUAL,EXIT
    584    000504              
    585    000504              ;C <      n1 n2 -- flag        test n1<n2,
                                signed
    586    000504                      HEADER LESS,1,'<',DOCODE
    586.1  000000                      PUBLIC  LESS
    586.2  000504 ....                 DW      link
    586.3  000506 FF                   DB      0FFh       ; not immediate
    586.4  000507              link    SET     $
    586.5  000507 01                   DB      1
    586.6  000508 3C                   DB      '<'
    586.7  000509 00                   EVEN
    586.8  00050A                      IF      'DOCODE'='DOCODE'
    586.9  00050A ....         LESS: DW     $+2
    586.10 00050C                      ELSE
    586.11 00050C              LESS: DW      DOCODE
    586.12 00050C                      ENDIF
    586.13 00050C                      ENDM
    587    00050C 3644                 MOV     @PSP+,W
    588    00050E 0687                 SUB     TOS,W       ; x1-x2 in W, flags
                                                            set
    589    000510 EF37                 JGE     TOSFALSE
    590    000512 3743         TOSTRUE: MOV    #-1,TOS
    591    000514                      NEXT
    591.1  000514 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
    591.2  000516 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
    591.3  000518                      ENDM
    592    000518              
    593    000518              ;C >     n1 n2 -- flag         test n1>n2,
                                signed
    594    000518                      HEADER GREATER,1,'>',DOCOLON
    594.1  000000                      PUBLIC  GREATER
    594.2  000518 ....                 DW      link
    594.3  00051A FF                   DB      0FFh       ; not immediate
    594.4  00051B              link    SET     $
    594.5  00051B 01                   DB      1
    594.6  00051C 3E                   DB      '>'
    594.7  00051D 00                   EVEN
    594.8  00051E                      IF      'DOCOLON'='DOCODE'
    594.9  00051E              GREATER: DW     $+2
    594.10 00051E                      ELSE
    594.11 00051E ....         GREATER: DW      DOCOLON
    594.12 000520                      ENDIF
    594.13 000520                      ENDM
    595    000520 ............         DW SWAP,LESS,EXIT
    596    000526              
    597    000526              ;C U<    u1 u2 -- flag       test u1<u2,
                                unsigned
    598    000526                      HEADER ULESS,2,'U<',DOCODE
    598.1  000000                      PUBLIC  ULESS
    598.2  000526 ....                 DW      link
    598.3  000528 FF                   DB      0FFh       ; not immediate
    598.4  000529              link    SET     $
    598.5  000529 02                   DB      2
    598.6  00052A 553C                 DB      'U<'
    598.7  00052C                      EVEN
    598.8  00052C                      IF      'DOCODE'='DOCODE'
    598.9  00052C ....         ULESS: DW     $+2
    598.10 00052E                      ELSE
    598.11 00052E              ULESS: DW      DOCODE
    598.12 00052E                      ENDIF
    598.13 00052E                      ENDM
    599    00052E 3644                 MOV     @PSP+,W
    600    000530 0687                 SUB     TOS,W       ; u1-u2 in W, cy
                                                            clear if borrow
    601    000532 EF2B                 JNC     TOSTRUE
    602    000534 DD3F                 JMP     TOSFALSE
    603    000536              
    604    000536              ;X U>    u1 u2 -- flag     u1>u2 unsgd (not
                                ANSI)
    605    000536                      HEADER UGREATER,2,'U>',DOCOLON
    605.1  000000                      PUBLIC  UGREATER
    605.2  000536 ....                 DW      link
    605.3  000538 FF                   DB      0FFh       ; not immediate
    605.4  000539              link    SET     $
    605.5  000539 02                   DB      2
    605.6  00053A 553E                 DB      'U>'
    605.7  00053C                      EVEN
    605.8  00053C                      IF      'DOCOLON'='DOCODE'
    605.9  00053C              UGREATER: DW     $+2
    605.10 00053C                      ELSE
    605.11 00053C ....         UGREATER: DW      DOCOLON
    605.12 00053E                      ENDIF
    605.13 00053E                      ENDM
    606    00053E ............         DW SWAP,ULESS,EXIT
    607    000544              
    608    000544              ; ----------------------------------------------
                               ------------------------
    609    000544              ; LOOP AND BRANCH OPERATIONS 
    610    000544              ; These use relative branch addresses: a branch
                                is ADD @IP,IP
    611    000544              
    612    000544              ;Z branch   --                  branch
                                always
    613    000544                      HEADER  bran,6,'branch',DOCODE
    613.1  000000                      PUBLIC  bran
    613.2  000544 ....                 DW      link
    613.3  000546 FF                   DB      0FFh       ; not immediate
    613.4  000547              link    SET     $
    613.5  000547 06                   DB      6
    613.6  000548 6272616E6368         DB      'branch'
    613.7  00054E                      EVEN
    613.8  00054E                      IF      'DOCODE'='DOCODE'
    613.9  00054E ....         bran: DW     $+2
    613.10 000550                      ELSE
    613.11 000550              bran: DW      DOCODE
    613.12 000550                      ENDIF
    613.13 000550                      ENDM
    614    000550 2555         dobran:  ADD @IP,IP   ; 2
    615    000552                      NEXT            ; 4
    615.1  000552 3645                 MOV @IP+,W     // ; fetch word address
                                                            into W
    615.2  000554 3046                 MOV @W+,PC     // ; fetch code address
                                                            into PC, W=PFA
    615.3  000556                      ENDM
    616    000556              
    617    000556              ;Z ?branch   x --              branch if TOS
                                zero
    618    000556                      HEADER  qbran,7,'?branch',DOCODE
    618.1  000000                      PUBLIC  qbran
    618.2  000556 ....                 DW      link
    618.3  000558 FF                   DB      0FFh       ; not immediate
    618.4  000559              link    SET     $
    618.5  000559 07                   DB      7
    618.6  00055A 3F6272616E63*        DB      '?branch'
    618.7  000561 00                   EVEN
    618.8  000562                      IF      'DOCODE'='DOCODE'
    618.9  000562 ....         qbran: DW     $+2
    618.10 000564                      ELSE
    618.11 000564              qbran: DW      DOCODE
    618.12 000564                      ENDIF
    618.13 000564                      ENDM
    619    000564 0753                 ADD #0,TOS      ; 1  test TOS value
    620    000566 3744                 MOV @PSP+,TOS   ; 2  pop new TOS value
                                                        (doesn't change
                                                        flags)
    621    000568 F327                 JZ  dobran    ; 2  if TOS was zero, take
                                                      the branch
    622    00056A 2553                 ADD #2,IP       ; 1  else skip the
                                                        branch destination
    623    00056C                      NEXT            ; 4
    623.1  00056C 3645                 MOV @IP+,W     // ; fetch word address
                                                            into W
    623.2  00056E 3046                 MOV @W+,PC     // ; fetch code address
                                                            into PC, W=PFA
    623.3  000570                      ENDM
    624    000570              
    625    000570              ;Z (do)    n1|u1 n2|u2 -- R: -- sys1 sys2       
                                   run-time code for DO
    626    000570              ; '83 and ANSI standard loops terminate when the
                                boundary of 
    627    000570              ; limit-1 and limit is crossed, in either
                                direction.  This can 
    628    000570              ; be conveniently implemented by making the
                                limit 8000h, so that
    629    000570              ; arithmetic overflow logic can detect crossing.
                                 I learned this 
    630    000570              ; trick from Laxen & Perry F83.
    631    000570              ; fudge factor = 8000h-limit, to be added to the
                                start value.
    632    000570                      HEADER  xdo,4,'(do)',DOCODE
    632.1  000000                      PUBLIC  xdo
    632.2  000570 ....                 DW      link
    632.3  000572 FF                   DB      0FFh       ; not immediate
    632.4  000573              link    SET     $
    632.5  000573 04                   DB      4
    632.6  000574 28646F29             DB      '(do)'
    632.7  000578                      EVEN
    632.8  000578                      IF      'DOCODE'='DOCODE'
    632.9  000578 ....         xdo: DW     $+2
    632.10 00057A                      ELSE
    632.11 00057A              xdo: DW      DOCODE
    632.12 00057A                      ENDIF
    632.13 00057A                      ENDM
    633    00057A 2182                 SUB     #4,RSP          ; push old loop
                                                                values on
                                                                return
                                                                stack
    634    00057C 81490200             MOV     LIMIT,2(RSP)
    635    000580 81480000             MOV     INDEX,0(RSP)
    636    000584 39400080             MOV     #8000h,LIMIT    ; compute
                                                                8000h-limit
                                                                "fudge
                                                                factor"
    637    000588 3984                 SUB     @PSP+,LIMIT
    638    00058A 0847                 MOV     TOS,INDEX       ; loop ctr =
                                                                index+fudge
    639    00058C 0859                 ADD     LIMIT,INDEX
    640    00058E 3744                 MOV     @PSP+,TOS       ; pop new
                                                                TOS
    641    000590                      NEXT
    641.1  000590 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
    641.2  000592 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
    641.3  000594                      ENDM
    642    000594              
    643    000594              ;Z (loop)   R: sys1 sys2 -- | sys1 sys2         
                                 run-time code for LOOP
    644    000594              ; Add 1 to the loop index.  If loop terminates,
                                clean up the 
    645    000594              ; return stack and skip the branch.  Else take
                                the inline branch.  
    646    000594              ; Note that LOOP terminates when index=8000h.
    647    000594                      HEADER  xloop,6,'(loop)',DOCODE
    647.1  000000                      PUBLIC  xloop
    647.2  000594 ....                 DW      link
    647.3  000596 FF                   DB      0FFh       ; not immediate
    647.4  000597              link    SET     $
    647.5  000597 06                   DB      6
    647.6  000598 286C6F6F7029         DB      '(loop)'
    647.7  00059E                      EVEN
    647.8  00059E                      IF      'DOCODE'='DOCODE'
    647.9  00059E ....         xloop: DW     $+2
    647.10 0005A0                      ELSE
    647.11 0005A0              xloop: DW      DOCODE
    647.12 0005A0                      ENDIF
    647.13 0005A0                      ENDM
    648    0005A0 1853                 ADD     #1,INDEX
    649    0005A2 32B00001             BIT     #100h,SR    ; is overflow bit
                                                            set?
    650    0005A6 D427                 JZ      dobran    ; no overflow =
                                                          loop
    651    0005A8 2553                 ADD     #2,IP       ; overflow = loop
                                                            done, skip branch
                                                            ofs
    652    0005AA 3841                 MOV     @RSP+,INDEX ; restore old loop
                                                            values
    653    0005AC 3941                 MOV     @RSP+,LIMIT
    654    0005AE                      NEXT
    654.1  0005AE 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
    654.2  0005B0 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
    654.3  0005B2                      ENDM
    655    0005B2              
    656    0005B2              ;Z (+loop)   n -- R: sys1 sys2 -- | sys1 sys2   
                                    run-time code for +LOOP
    657    0005B2              ; Add n to the loop index.  If loop terminates,
                                clean up the 
    658    0005B2              ; return stack and skip the branch. Else take
                                the inline branch.
    659    0005B2                      HEADER  xplusloop,7,'(+loop)',DOCODE
    659.1  000000                      PUBLIC  xplusloop
    659.2  0005B2 ....                 DW      link
    659.3  0005B4 FF                   DB      0FFh       ; not immediate
    659.4  0005B5              link    SET     $
    659.5  0005B5 07                   DB      7
    659.6  0005B6 282B6C6F6F70*        DB      '(+loop)'
    659.7  0005BD 00                   EVEN
    659.8  0005BE                      IF      'DOCODE'='DOCODE'
    659.9  0005BE ....         xplusloop: DW     $+2
    659.10 0005C0                      ELSE
    659.11 0005C0              xplusloop: DW      DOCODE
    659.12 0005C0                      ENDIF
    659.13 0005C0                      ENDM
    660    0005C0 0857                 ADD     TOS,INDEX
    661    0005C2 3744                 MOV     @PSP+,TOS   ; get new TOS,
                                                            doesn't change
                                                            flags
    662    0005C4 32B00001             BIT     #100h,SR    ; is overflow bit
                                                            set?
    663    0005C8 C327                 JZ      dobran    ; no overflow =
                                                          loop
    664    0005CA 2553                 ADD     #2,IP       ; overflow = loop
                                                            done, skip branch
                                                            ofs
    665    0005CC 3841                 MOV     @RSP+,INDEX ; restore old loop
                                                            values
    666    0005CE 3941                 MOV     @RSP+,LIMIT
    667    0005D0                      NEXT
    667.1  0005D0 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
    667.2  0005D2 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
    667.3  0005D4                      ENDM
    668    0005D4              
    669    0005D4              ;C I        -- n R: sys1 sys2 -- sys1 sys2      
                                 get the innermost loop index
    670    0005D4                      HEADER  II,1,'I',DOCODE
    670.1  000000                      PUBLIC  II
    670.2  0005D4 ....                 DW      link
    670.3  0005D6 FF                   DB      0FFh       ; not immediate
    670.4  0005D7              link    SET     $
    670.5  0005D7 01                   DB      1
    670.6  0005D8 49                   DB      'I'
    670.7  0005D9 00                   EVEN
    670.8  0005DA                      IF      'DOCODE'='DOCODE'
    670.9  0005DA ....         II: DW     $+2
    670.10 0005DC                      ELSE
    670.11 0005DC              II: DW      DOCODE
    670.12 0005DC                      ENDIF
    670.13 0005DC                      ENDM
    671    0005DC 2483                 SUB     #2,PSP          ; make room in
                                                                TOS
    672    0005DE 84470000             MOV     TOS,0(PSP)
    673    0005E2 0748                 MOV     INDEX,TOS       ; index =
                                                                loopctr -
                                                                fudge
    674    0005E4 0789                 SUB     LIMIT,TOS
    675    0005E6                      NEXT
    675.1  0005E6 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
    675.2  0005E8 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
    675.3  0005EA                      ENDM
    676    0005EA              
    677    0005EA              ;C J        -- n R: 4*sys -- 4*sys              
                                  get the second loop index
    678    0005EA                      HEADER  JJ,1,'J',DOCODE
    678.1  000000                      PUBLIC  JJ
    678.2  0005EA ....                 DW      link
    678.3  0005EC FF                   DB      0FFh       ; not immediate
    678.4  0005ED              link    SET     $
    678.5  0005ED 01                   DB      1
    678.6  0005EE 4A                   DB      'J'
    678.7  0005EF 00                   EVEN
    678.8  0005F0                      IF      'DOCODE'='DOCODE'
    678.9  0005F0 ....         JJ: DW     $+2
    678.10 0005F2                      ELSE
    678.11 0005F2              JJ: DW      DOCODE
    678.12 0005F2                      ENDIF
    678.13 0005F2                      ENDM
    679    0005F2 2483                 SUB     #2,PSP          ; make room in
                                                                TOS
    680    0005F4 84470000             MOV     TOS,0(PSP)
    681    0005F8 2741                 MOV     @RSP,TOS        ; index =
                                                                loopctr -
                                                                fudge
    682    0005FA 17810200             SUB     2(RSP),TOS
    683    0005FE                      NEXT
    683.1  0005FE 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
    683.2  000600 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
    683.3  000602                      ENDM
    684    000602              
    685    000602              ;C UNLOOP    -- R: sys1 sys2 --                 
                                  drop loop parms
    686    000602                      HEADER  UNLOOP,6,'UNLOOP',DOCODE
    686.1  000000                      PUBLIC  UNLOOP
    686.2  000602 ....                 DW      link
    686.3  000604 FF                   DB      0FFh       ; not immediate
    686.4  000605              link    SET     $
    686.5  000605 06                   DB      6
    686.6  000606 554E4C4F4F50         DB      'UNLOOP'
    686.7  00060C                      EVEN
    686.8  00060C                      IF      'DOCODE'='DOCODE'
    686.9  00060C ....         UNLOOP: DW     $+2
    686.10 00060E                      ELSE
    686.11 00060E              UNLOOP: DW      DOCODE
    686.12 00060E                      ENDIF
    686.13 00060E                      ENDM
    687    00060E 3841                 MOV     @RSP+,INDEX     ; restore old
                                                                loop values
    688    000610 3941                 MOV     @RSP+,LIMIT
    689    000612                      NEXT
    689.1  000612 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
    689.2  000614 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
    689.3  000616                      ENDM
    690    000616              
    691    000616              ; ----------------------------------------------
                               ------------------------
    692    000616              ; MULTIPLY AND DIVIDE
    693    000616              
    694    000616              ;C UM*     u1 u2 -- ud      unsigned 16x16->32
                                mult.
    695    000616                      HEADER  UMSTAR,3,'UM*',DOCODE
    695.1  000000                      PUBLIC  UMSTAR
    695.2  000616 ....                 DW      link
    695.3  000618 FF                   DB      0FFh       ; not immediate
    695.4  000619              link    SET     $
    695.5  000619 03                   DB      3
    695.6  00061A 554D2A               DB      'UM*'
    695.7  00061D 00                   EVEN
    695.8  00061E                      IF      'DOCODE'='DOCODE'
    695.9  00061E ....         UMSTAR: DW     $+2
    695.10 000620                      ELSE
    695.11 000620              UMSTAR: DW      DOCODE
    695.12 000620                      ENDIF
    695.13 000620                      ENDM
    696    000620                      ; IROP1 = TOS register
    697    000620 2A44                 MOV     @PSP,IROP2L     ; get u1, leave
                                                                room on
                                                                stack
    698    000622              ;
    699    000622              ; T.I. SIGNED MULTIPLY SUBROUTINE: IROP1 x
                                IROP2L -> IRACM|IRACL
    700    000622 0C43         MPYU:   CLR IRACL ; 0 -> LSBs RESULT
    701    000624 0D43                 CLR IRACM ; 0 -> MSBs RESULT
    702    000626              ; UNSIGNED MULTIPLY AND ACCUMULATE SUBROUTINE:
    703    000626              ; (IROP1 x IROP2L) + IRACM|IRACL -> IRACM|IRACL
    704    000626 0B43         MACU:   CLR IROP2M  ; MSBs MULTIPLIER
    705    000628 1643                 MOV #1,IRBT ; BIT TEST REGISTER
    706    00062A 07B6         L$002:  BIT IRBT,IROP1 ; TEST ACTUAL BIT
    707    00062C 0224                 JZ L$01     ; IF 0: DO NOTHING
    708    00062E 0C5A                 ADD IROP2L,IRACL ; IF 1: ADD MULTIPLIER
                                                         TO RESULT
    709    000630 0D6B                 ADDC IROP2M,IRACM
    710    000632 0A5A         L$01:   RLA IROP2L  ; MULTIPLIER x 2
    711    000634 0B6B                 RLC IROP2M
    712    000636              ;
    713    000636 0656                 RLA IRBT    ; NEXT BIT TO TEST
    714    000638 F82B                 JNC L$002   ; IF BIT IN CARRY:
                                                    FINISHED
    715    00063A              ; END T.I. ROUTINE  section 5.1.1 of MSP430
                                Family Application Reports
    716    00063A 844C0000             MOV     IRACL,0(PSP)    ; low result on
                                                                stack
    717    00063E 074D                 MOV     IRACM,TOS       ; high result in
                                                                TOS
    718    000640                      NEXT
    718.1  000640 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
    718.2  000642 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
    718.3  000644                      ENDM
    719    000644              
    720    000644              ;C UM/MOD   ud u1 -- u2 u3   unsigned 32/16->16
    721    000644                      HEADER  UMSLASHMOD,6,'UM/MOD',DOCODE
    721.1  000000                      PUBLIC  UMSLASHMOD
    721.2  000644 ....                 DW      link
    721.3  000646 FF                   DB      0FFh       ; not immediate
    721.4  000647              link    SET     $
    721.5  000647 06                   DB      6
    721.6  000648 554D2F4D4F44         DB      'UM/MOD'
    721.7  00064E                      EVEN
    721.8  00064E                      IF      'DOCODE'='DOCODE'
    721.9  00064E ....         UMSLASHMOD: DW     $+2
    721.10 000650                      ELSE
    721.11 000650              UMSLASHMOD: DW      DOCODE
    721.12 000650                      ENDIF
    721.13 000650                      ENDM
    722    000650                      ; IROP1 = TOS register
    723    000650 3B44                 MOV     @PSP+,IROP2M    ; get ud
                                                                hi
    724    000652 2A44                 MOV     @PSP,IROP2L     ; get ud lo,
                                                                leave room on
                                                                stack
    725    000654              ;
    726    000654              ; T.I. UNSIGNED DIVISION SUBROUTINE 32-BIT BY
                                16-BIT
    727    000654              ; IROP2M|IROP2L : IROP1 -> IRACL REMAINDER IN
                                IROP2M
    728    000654              ; RETURN: CARRY = 0: OK CARRY = 1: QUOTIENT > 16
                                BITS
    729    000654 0C43         DIVIDE: CLR IRACL   ; CLEAR RESULT
    730    000656 36401100             MOV #17,IRBT ; INITIALIZE LOOP
                                                     COUNTER
    731    00065A 0B97         DIV1:   CMP IROP1,IROP2M ;
    732    00065C 0128                 JLO DIV2
    733    00065E 0B87                 SUB IROP1,IROP2M
    734    000660 0C6C         DIV2:   RLC IRACL
    735    000662 092C                 JC DIV4     ; Error: result > 16
                                                    bits
    736    000664 1683                 DEC IRBT    ; Decrement loop counter
    737    000666 0624                 JZ DIV3     ; Is 0: terminate w/o
                                                    error
    738    000668 0A5A                 RLA IROP2L
    739    00066A 0B6B                 RLC IROP2M
    740    00066C F62B                 JNC DIV1
    741    00066E 0B87                 SUB IROP1,IROP2M
    742    000670 12D3                 SETC
    743    000672 F63F                 JMP DIV2
    744    000674 12C3         DIV3:   CLRC        ; No error, C = 0
    745    000676              DIV4:   ; Error indication in C
    746    000676              ; END T.I. ROUTINE  Section 5.1.5 of MSP430
                                Family Application Reports
    747    000676 844B0000             MOV     IROP2M,0(PSP)   ; remainder on
                                                                stack
    748    00067A 074C                 MOV     IRACL,TOS       ; quotient in
                                                                TOS
    749    00067C                      NEXT
    749.1  00067C 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
    749.2  00067E 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
    749.3  000680                      ENDM
    750    000680              
    751    000680              ; ----------------------------------------------
                               ------------------------
    752    000680              ; BLOCK AND STRING OPERATIONS
    753    000680              
    754    000680              ;C FILL   c-addr u char --  fill memory with
                                char
    755    000680                      HEADER  FILL,4,'FILL',DOCODE
    755.1  000000                      PUBLIC  FILL
    755.2  000680 ....                 DW      link
    755.3  000682 FF                   DB      0FFh       ; not immediate
    755.4  000683              link    SET     $
    755.5  000683 04                   DB      4
    755.6  000684 46494C4C             DB      'FILL'
    755.7  000688                      EVEN
    755.8  000688                      IF      'DOCODE'='DOCODE'
    755.9  000688 ....         FILL: DW     $+2
    755.10 00068A                      ELSE
    755.11 00068A              FILL: DW      DOCODE
    755.12 00068A                      ENDIF
    755.13 00068A                      ENDM
    756    00068A 3A44                 MOV     @PSP+,X     ; count
    757    00068C 3644                 MOV     @PSP+,W     ; address
    758    00068E 0A93                 CMP     #0,X
    759    000690 0524                 JZ      FILL_X
    760    000692 C6470000     FILL_1: MOV.B   TOS,0(W)    ; store char in
                                                            memory
    761    000696 1653                 ADD     #1,W
    762    000698 1A83                 SUB     #1,X
    763    00069A FB23                 JNZ     FILL_1
    764    00069C 3744         FILL_X: MOV     @PSP+,TOS   ; pop new TOS
    765    00069E                      NEXT
    765.1  00069E 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
    765.2  0006A0 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
    765.3  0006A2                      ENDM
    766    0006A2              
    767    0006A2              ;X CMOVE   c-addr1 c-addr2 u --  move from
                                bottom
    768    0006A2              ; as defined in the ANSI optional String word
                                set
    769    0006A2              ; On byte machines, CMOVE and CMOVE> are
                                logical
    770    0006A2              ; factors of MOVE.  They are easy to implement
                                on
    771    0006A2              ; CPUs which have a block-move instruction.
    772    0006A2                      HEADER  CMOVE,5,'CMOVE',DOCODE
    772.1  000000                      PUBLIC  CMOVE
    772.2  0006A2 ....                 DW      link
    772.3  0006A4 FF                   DB      0FFh       ; not immediate
    772.4  0006A5              link    SET     $
    772.5  0006A5 05                   DB      5
    772.6  0006A6 434D4F5645           DB      'CMOVE'
    772.7  0006AB 00                   EVEN
    772.8  0006AC                      IF      'DOCODE'='DOCODE'
    772.9  0006AC ....         CMOVE: DW     $+2
    772.10 0006AE                      ELSE
    772.11 0006AE              CMOVE: DW      DOCODE
    772.12 0006AE                      ENDIF
    772.13 0006AE                      ENDM
    773    0006AE 3644                 MOV     @PSP+,W     ; dest adrs
    774    0006B0 3A44                 MOV     @PSP+,X     ; src adrs
    775    0006B2 0793                 CMP     #0,TOS
    776    0006B4 0524                 JZ      CMOVE_X
    777    0006B6 F64A0000     CMOVE_1: MOV.B  @X+,0(W)    ; copy byte
    778    0006BA 1653                 ADD     #1,W
    779    0006BC 1783                 SUB     #1,TOS
    780    0006BE FB23                 JNZ     CMOVE_1
    781    0006C0 3744         CMOVE_X: MOV    @PSP+,TOS   ; pop new TOS
    782    0006C2                      NEXT
    782.1  0006C2 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
    782.2  0006C4 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
    782.3  0006C6                      ENDM
    783    0006C6              
    784    0006C6              ;X CMOVE>  c-addr1 c-addr2 u --  move from
                                top
    785    0006C6              ; as defined in the ANSI optional String word
                                set
    786    0006C6                      HEADER  CMOVEUP,6,'CMOVE>',DOCODE
    786.1  000000                      PUBLIC  CMOVEUP
    786.2  0006C6 ....                 DW      link
    786.3  0006C8 FF                   DB      0FFh       ; not immediate
    786.4  0006C9              link    SET     $
    786.5  0006C9 06                   DB      6
    786.6  0006CA 434D4F56453E         DB      'CMOVE>'
    786.7  0006D0                      EVEN
    786.8  0006D0                      IF      'DOCODE'='DOCODE'
    786.9  0006D0 ....         CMOVEUP: DW     $+2
    786.10 0006D2                      ELSE
    786.11 0006D2              CMOVEUP: DW      DOCODE
    786.12 0006D2                      ENDIF
    786.13 0006D2                      ENDM
    787    0006D2 3644                 MOV     @PSP+,W     ; dest adrs
    788    0006D4 3A44                 MOV     @PSP+,X     ; src adrs
    789    0006D6 0793                 CMP     #0,TOS
    790    0006D8 0824                 JZ      CMOVU_X
    791    0006DA 0657                 ADD     TOS,W       ; start at
                                                            end
    792    0006DC 0A57                 ADD     TOS,X
    793    0006DE 1A83         CMOVU_1: SUB    #1,X
    794    0006E0 1683                 SUB     #1,W
    795    0006E2 E64A0000             MOV.B   @X,0(W)     ; copy byte
    796    0006E6 1783                 SUB     #1,TOS
    797    0006E8 FA23                 JNZ     CMOVU_1
    798    0006EA 3744         CMOVU_X: MOV    @PSP+,TOS   ; pop new TOS
    799    0006EC                      NEXT
    799.1  0006EC 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
    799.2  0006EE 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
    799.3  0006F0                      ENDM
    800    0006F0              
    801    0006F0              ;Z I->D     c-addr1 c-addr2 u --      move
                                Code->Data
    802    0006F0              ; Block move from Code space to Data space.
    803    0006F0              ; On the MSP430, this is the same as CMOVE.
    804    0006F0                     HEADER  ITOD,4,'I->D',CMOVE+2
    804.1  000000                      PUBLIC  ITOD
    804.2  0006F0 ....                 DW      link
    804.3  0006F2 FF                   DB      0FFh       ; not immediate
    804.4  0006F3              link    SET     $
    804.5  0006F3 04                   DB      4
    804.6  0006F4 492D3E44             DB      'I->D'
    804.7  0006F8                      EVEN
    804.8  0006F8                      IF      'CMOVE+2'='DOCODE'
    804.9  0006F8              ITOD: DW     $+2
    804.10 0006F8                      ELSE
    804.11 0006F8 ....         ITOD: DW      CMOVE+2
    804.12 0006FA                      ENDIF
    804.13 0006FA                      ENDM
    805    0006FA              
    806    0006FA              ;Z SKIP   c-addr u c -- c-addr' u'              
                                      skip matching chars
    807    0006FA              ; Although SKIP, SCAN, and S= are perhaps not
                                the ideal factors 
    808    0006FA              ; of WORD and FIND, they closely follow the
                                string operations 
    809    0006FA              ; available on many CPUs, and so are easy to
                                implement and fast.
    810    0006FA                      HEADER  SKIP,4,'SKIP',DOCODE
    810.1  000000                      PUBLIC  SKIP
    810.2  0006FA ....                 DW      link
    810.3  0006FC FF                   DB      0FFh       ; not immediate
    810.4  0006FD              link    SET     $
    810.5  0006FD 04                   DB      4
    810.6  0006FE 534B4950             DB      'SKIP'
    810.7  000702                      EVEN
    810.8  000702                      IF      'DOCODE'='DOCODE'
    810.9  000702 ....         SKIP: DW     $+2
    810.10 000704                      ELSE
    810.11 000704              SKIP: DW      DOCODE
    810.12 000704                      ENDIF
    810.13 000704                      ENDM
    811    000704 3A44                 MOV     @PSP+,X     ; get count
    812    000706 2644                 MOV     @PSP,W      ; get address, leave
                                                            space on stack
    813    000708 0A93                 CMP     #0,X
    814    00070A 0524                 JZ      SKIP_X
    815    00070C 6796         SKIP_1: CMP.B   @W,TOS      ; does character
                                                            match?
    816    00070E 0320                 JNZ     SKIP_X      ; no, we are
                                                            done
    817    000710 1653                 ADD     #1,W
    818    000712 1A83                 SUB     #1,X
    819    000714 FB23                 JNZ     SKIP_1
    820    000716 84460000     SKIP_X: MOV     W,0(PSP)    ; store updated
                                                            address on
                                                            stack
    821    00071A 074A                 MOV     X,TOS       ; updated count to
                                                            TOS
    822    00071C                      NEXT
    822.1  00071C 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
    822.2  00071E 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
    822.3  000720                      ENDM
    823    000720              
    824    000720              ;Z SCAN    c-addr u c -- c-addr' u'             
                                       find matching char
    825    000720                      HEADER  SCAN,4,'SCAN',DOCODE
    825.1  000000                      PUBLIC  SCAN
    825.2  000720 ....                 DW      link
    825.3  000722 FF                   DB      0FFh       ; not immediate
    825.4  000723              link    SET     $
    825.5  000723 04                   DB      4
    825.6  000724 5343414E             DB      'SCAN'
    825.7  000728                      EVEN
    825.8  000728                      IF      'DOCODE'='DOCODE'
    825.9  000728 ....         SCAN: DW     $+2
    825.10 00072A                      ELSE
    825.11 00072A              SCAN: DW      DOCODE
    825.12 00072A                      ENDIF
    825.13 00072A                      ENDM
    826    00072A 3A44                 MOV     @PSP+,X     ; get count
    827    00072C 2644                 MOV     @PSP,W      ; get address, leave
                                                            space on stack
    828    00072E 0A93                 CMP     #0,X
    829    000730 0524                 JZ      SCAN_X
    830    000732 6796         SCAN_1: CMP.B   @W,TOS      ; does character
                                                            match?
    831    000734 0324                 JZ      SCAN_X      ; yes, we are
                                                            done
    832    000736 1653                 ADD     #1,W
    833    000738 1A83                 SUB     #1,X
    834    00073A FB23                 JNZ     SCAN_1
    835    00073C 84460000     SCAN_X: MOV     W,0(PSP)    ; store updated
                                                            address on
                                                            stack
    836    000740 074A                 MOV     X,TOS       ; updated count to
                                                            TOS
    837    000742                      NEXT
    837.1  000742 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
    837.2  000744 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
    837.3  000746                      ENDM
    838    000746              
    839    000746              ;Z S=    c-addr1 c-addr2 u -- n   string
                                compare
    840    000746              ;Z S=    n<0: s1<s2, n=0: s1=s2, n>0: s1>s2
    841    000746                      HEADER  SEQUAL,2,'S=',DOCODE
    841.1  000000                      PUBLIC  SEQUAL
    841.2  000746 ....                 DW      link
    841.3  000748 FF                   DB      0FFh       ; not immediate
    841.4  000749              link    SET     $
    841.5  000749 02                   DB      2
    841.6  00074A 533D                 DB      'S='
    841.7  00074C                      EVEN
    841.8  00074C                      IF      'DOCODE'='DOCODE'
    841.9  00074C ....         SEQUAL: DW     $+2
    841.10 00074E                      ELSE
    841.11 00074E              SEQUAL: DW      DOCODE
    841.12 00074E                      ENDIF
    841.13 00074E                      ENDM
    842    00074E 3644                 MOV     @PSP+,W     ; adrs2
    843    000750 3A44                 MOV     @PSP+,X     ; adrs1
    844    000752 0793                 CMP     #0,TOS
    845    000754 0A24                 JZ      SEQU_X
    846    000756 FA960000     SEQU_1: CMP.B   @W+,0(X)    ; compare char1-char
                                                           2
    847    00075A 0420                 JNZ     SMISMATCH
    848    00075C 1A53                 ADD     #1,X
    849    00075E 1783                 SUB     #1,TOS
    850    000760 FA23                 JNZ     SEQU_1
    851    000762                      ; no mismatch found, strings are equal,
                                TOS=0
    852    000762 033C                 JMP     SEQU_X
    853    000764                      ; mismatch found, CY clear if borrow set
                                (s1<s2)
    854    000764 0777         SMISMATCH: SUBC TOS,TOS     ; TOS=-1 if borrow
                                                            was set
    855    000766 0757                 ADD     TOS,TOS     ; TOS=-2 or
                                                            0
    856    000768 1753                 ADD     #1,TOS      ; TOS=-1 or
                                                            +1
    857    00076A              SEQU_X: NEXT                ; return result in
                                TOS
    857.1  00076A 3645                 MOV @IP+,W     // ; fetch word address
  into W
    857.2  00076C 3046                 MOV @W+,PC     // ; fetch code address
  into PC, W=PFA
    857.3  00076E                      ENDM
    858    00076E              
    859    00076E              ;Z N=    c-addr1 c-addr2 u -- n   name
                                compare
    860    00076E              ;Z N=    n<0: s1<s2, n=0: s1=s2, n>0: s1>s2
    861    00076E              ; For Harvard model, c-addr1 is Data, c-addr2 is
                                Header.
    862    00076E              ; On MSP430, both use the same fetch instruction
                               , so N= is the same as S=.
    863    00076E                      HEADER  NEQUAL,2,'N=',SEQUAL+2
    863.1  000000                      PUBLIC  NEQUAL
    863.2  00076E ....                 DW      link
    863.3  000770 FF                   DB      0FFh       ; not immediate
    863.4  000771              link    SET     $
    863.5  000771 02                   DB      2
    863.6  000772 4E3D                 DB      'N='
    863.7  000774                      EVEN
    863.8  000774                      IF      'SEQUAL+2'='DOCODE'
    863.9  000774              NEQUAL: DW     $+2
    863.10 000774                      ELSE
    863.11 000774 ....         NEQUAL: DW      SEQUAL+2
    863.12 000776                      ENDIF
    863.13 000776                      ENDM
    864    000776              
    865    000776              ; ----------------------------------------------
                               ------------------------
    866    000776              ; TERMINAL I/O
    867    000776              
    868    000776              ;C EMIT     c --    output character to
                                console
    869    000776                      HEADER  EMIT,4,'EMIT',DOCODE
    869.1  000000                      PUBLIC  EMIT
    869.2  000776 ....                 DW      link
    869.3  000778 FF                   DB      0FFh       ; not immediate
    869.4  000779              link    SET     $
    869.5  000779 04                   DB      4
    869.6  00077A 454D4954             DB      'EMIT'
    869.7  00077E                      EVEN
    869.8  00077E                      IF      'DOCODE'='DOCODE'
    869.9  00077E ....         EMIT: DW     $+2
    869.10 000780                      ELSE
    869.11 000780              EMIT: DW      DOCODE
    869.12 000780                      ENDIF
    869.13 000780                      ENDM
    870    000780              EMITLOOP:
    871    000780 E2B30300             BIT.B   #UCA0TXIFG,&IFG2
    872    000784 FD27                 JZ      EMITLOOP
    873    000786 C2476700             MOV.B   TOS,&UCA0TXBUF 
    874    00078A 3744                 MOV @PSP+,TOS
    875    00078C                      NEXT
    875.1  00078C 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
    875.2  00078E 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
    875.3  000790                      ENDM
    876    000790              
    877    000790              ;C KEY      -- c      get character from
                                keyboard
    878    000790                      HEADER  KEY,3,'KEY',DOCODE
    878.1  000000                      PUBLIC  KEY
    878.2  000790 ....                 DW      link
    878.3  000792 FF                   DB      0FFh       ; not immediate
    878.4  000793              link    SET     $
    878.5  000793 03                   DB      3
    878.6  000794 4B4559               DB      'KEY'
    878.7  000797 00                   EVEN
    878.8  000798                      IF      'DOCODE'='DOCODE'
    878.9  000798 ....         KEY: DW     $+2
    878.10 00079A                      ELSE
    878.11 00079A              KEY: DW      DOCODE
    878.12 00079A                      ENDIF
    878.13 00079A                      ENDM
    879    00079A              KEYLOOP:
    880    00079A D2B30300             BIT.B   #UCA0RXIFG,&IFG2
    881    00079E FD27                 JZ      KEYLOOP
    882    0007A0 2483                 SUB     #2,PSP          ; 1  push old
                                                                TOS..
    883    0007A2 84470000             MOV     TOS,0(PSP)      ; 4  ..onto
                                                                stack
    884    0007A6 57426600             MOV.B   &UCA0RXBUF,TOS    ; read
                                                                  character
                                                                  into
                                                                  TOS
    885    0007AA              donoop:
    886    0007AA              donext: NEXT
    886.1  0007AA 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
    886.2  0007AC 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
    886.3  0007AE                      ENDM
    887    0007AE              
    888    0007AE              ;X KEY?     -- f    return true if char
                                waiting
    889    0007AE                      HEADER  KEYQ,4,'KEY?',DOCODE
    889.1  000000                      PUBLIC  KEYQ
    889.2  0007AE ....                 DW      link
    889.3  0007B0 FF                   DB      0FFh       ; not immediate
    889.4  0007B1              link    SET     $
    889.5  0007B1 04                   DB      4
    889.6  0007B2 4B45593F             DB      'KEY?'
    889.7  0007B6                      EVEN
    889.8  0007B6                      IF      'DOCODE'='DOCODE'
    889.9  0007B6 ....         KEYQ: DW     $+2
    889.10 0007B8                      ELSE
    889.11 0007B8              KEYQ: DW      DOCODE
    889.12 0007B8                      ENDIF
    889.13 0007B8                      ENDM
    890    0007B8 2483                 SUB     #2,PSP          ; 1  push old
                                                                TOS..
    891    0007BA 84470000             MOV     TOS,0(PSP)      ; 4  ..onto
                                                                stack
    892    0007BE D2B30300             BIT.B   #UCA0RXIFG,&IFG2
    893    0007C2 A722                 JNZ     TOSTRUE
    894    0007C4 953E                 JMP     TOSFALSE
    895    0007C6              
    896    0007C6              ;X ZERO     -- 0      put zero on stack. Often
                                usesd word.
    897    0007C6                      HEADER  ZERO,4,'ZERO',DOCON
    897.1  000000                      PUBLIC  ZERO
    897.2  0007C6 ....                 DW      link
    897.3  0007C8 FF                   DB      0FFh       ; not immediate
    897.4  0007C9              link    SET     $
    897.5  0007C9 04                   DB      4
    897.6  0007CA 5A45524F             DB      'ZERO'
    897.7  0007CE                      EVEN
    897.8  0007CE                      IF      'DOCON'='DOCODE'
    897.9  0007CE              ZERO: DW     $+2
    897.10 0007CE                      ELSE
    897.11 0007CE ....         ZERO: DW      DOCON
    897.12 0007D0                      ENDIF
    897.13 0007D0                      ENDM
    898    0007D0 0000                   DW 0
    899    0007D2              ; ----------------------------------------------
                               ------------------------
    900    0007D2              ; We #include the following source files, rather
                                than compiling them 
    901    0007D2              ; separately, so that they can inherit the value
                                of 'link'.
    902    0007D2              
    903    0007D2              #include "4e-deps430G2553.s43"
      1    0007D2              ; ----------------------------------------------
                               ------------------------
      2    0007D2              ; 4e4th is a Forth based on CamelForth
                                
      3    0007D2              ; for the Texas Instruments MSP430 
      4    0007D2              ; 
      5    0007D2              ; This program is free software; you can
                                redistribute it and/or modify
      6    0007D2              ; it under the terms of the GNU General Public
                                License as published by
      7    0007D2              ; the Free Software Foundation; either version 3
                                of the License, or
      8    0007D2              ; (at your option) any later version.
      9    0007D2              ; 
     10    0007D2              ; This program is distributed in the hope that
                                it will be useful,
     11    0007D2              ; but WITHOUT ANY WARRANTY; without even the
                                implied warranty of
     12    0007D2              ; MERCHANTABILITY or FITNESS FOR A PARTICULAR
                                PURPOSE.  See the
     13    0007D2              ; GNU General Public License for more details.
     14    0007D2              ;
     15    0007D2              ; You should have received a copy of the GNU
                                General Public License
     16    0007D2              ; along with this program.  If not, see
                                <http://www.gnu.org/licenses/>.
     17    0007D2              ; 
     18    0007D2              ; See LICENSE TERMS in Brads file readme.txt as
                                well.
     19    0007D2              
     20    0007D2              ; ----------------------------------------------
                               ------------------------
     21    0007D2              ; 4e-deps430.s43: CPU and Model Dependencies -
                                MSP430G2553
     22    0007D2              ; ----------------------------------------------
                               ------------------------
     23    0007D2              
     24    0007D2              ;   Forth words are documented as follows:
     25    0007D2              ;x   NAME     stack -- stack    description
     26    0007D2              ;   where x=C for ANS Forth Core words, X for
                                ANS
     27    0007D2              ;   Extensions, Z for internal or private
                                words.
     28    0007D2              ;
     29    0007D2              ; Indirect-Threaded Forth model for T.I.
                                MSP430
     30    0007D2              ;   cell size is   16 bits (2 bytes)
     31    0007D2              ;   char size is    8 bits (1 byte)
     32    0007D2              ;   address unit is 8 bits (1 byte), i.e.,
                                addresses are byte-aligned.
     33    0007D2              ; ----------------------------------------------
                               ------------------------
     34    0007D2              
     35    0007D2              ; ----------------------------------------------
                               ------------------------
     36    0007D2              ; ALIGNMENT AND PORTABILITY OPERATORS 
     37    0007D2              ; Many of these are synonyms for other
                                words,
     38    0007D2              ; and so are defined as CODE words.
     39    0007D2              
     40    0007D2              ;C ALIGN    --                         align
                                HERE
     41    0007D2              ;   IHERE 1 AND IALLOT ;
     42    0007D2                      HEADER  ALIGNN,5,'ALIGN',DOCOLON
     42.1  000000                      PUBLIC  ALIGNN
     42.2  0007D2 ....                 DW      link
     42.3  0007D4 FF                   DB      0FFh       ; not immediate
     42.4  0007D5              link    SET     $
     42.5  0007D5 05                   DB      5
     42.6  0007D6 414C49474E           DB      'ALIGN'
     42.7  0007DB 00                   EVEN
     42.8  0007DC                      IF      'DOCOLON'='DOCODE'
     42.9  0007DC              ALIGNN: DW     $+2
     42.10 0007DC                      ELSE
     42.11 0007DC ....         ALIGNN: DW      DOCOLON
     42.12 0007DE                      ENDIF
     42.13 0007DE                      ENDM
     43    0007DE ........0100*        DW  IHERE,lit,1,ANDD,IALLOT,EXIT
     44    0007EA              
     45    0007EA              ;C ALIGNED  addr -- a-addr       align given
                                addr
     46    0007EA              ;   DUP 1 AND + ;
     47    0007EA                      HEADER  ALIGNED,7,'ALIGNED',DOCOLON
     47.1  000000                      PUBLIC  ALIGNED
     47.2  0007EA ....                 DW      link
     47.3  0007EC FF                   DB      0FFh       ; not immediate
     47.4  0007ED              link    SET     $
     47.5  0007ED 07                   DB      7
     47.6  0007EE 414C49474E45*        DB      'ALIGNED'
     47.7  0007F5 00                   EVEN
     47.8  0007F6                      IF      'DOCOLON'='DOCODE'
     47.9  0007F6              ALIGNED: DW     $+2
     47.10 0007F6                      ELSE
     47.11 0007F6 ....         ALIGNED: DW      DOCOLON
     47.12 0007F8                      ENDIF
     47.13 0007F8                      ENDM
     48    0007F8 ........0100*        DW  DUP,lit,1,ANDD,PLUS,EXIT
     49    000804              
     50    000804              ;Z CELL     -- n                 size of one
                                cell
     51    000804                      HEADER  CELL,4,'CELL',DOCON
     51.1  000000                      PUBLIC  CELL
     51.2  000804 ....                 DW      link
     51.3  000806 FF                   DB      0FFh       ; not immediate
     51.4  000807              link    SET     $
     51.5  000807 04                   DB      4
     51.6  000808 43454C4C             DB      'CELL'
     51.7  00080C                      EVEN
     51.8  00080C                      IF      'DOCON'='DOCODE'
     51.9  00080C              CELL: DW     $+2
     51.10 00080C                      ELSE
     51.11 00080C ....         CELL: DW      DOCON
     51.12 00080E                      ENDIF
     51.13 00080E                      ENDM
     52    00080E 0200                 dw 2
     53    000810              
     54    000810              ;C CELL+    a-addr1 -- a-addr2      add cell
                                size
     55    000810              ;   2 + ;
     56    000810                      HEADER  CELLPLUS,5,'CELL+',DOCODE
     56.1  000000                      PUBLIC  CELLPLUS
     56.2  000810 ....                 DW      link
     56.3  000812 FF                   DB      0FFh       ; not immediate
     56.4  000813              link    SET     $
     56.5  000813 05                   DB      5
     56.6  000814 43454C4C2B           DB      'CELL+'
     56.7  000819 00                   EVEN
     56.8  00081A                      IF      'DOCODE'='DOCODE'
     56.9  00081A ....         CELLPLUS: DW     $+2
     56.10 00081C                      ELSE
     56.11 00081C              CELLPLUS: DW      DOCODE
     56.12 00081C                      ENDIF
     56.13 00081C                      ENDM
     57    00081C 2753                 ADD     #2,TOS
     58    00081E C53F                 JMP     donext
     59    000820              
     60    000820              ;C CELLS    n1 -- n2            cells->adrs
                                units
     61    000820                      HEADER  CELLS,5,'CELLS',TWOSTAR+2
     61.1  000000                      PUBLIC  CELLS
     61.2  000820 ....                 DW      link
     61.3  000822 FF                   DB      0FFh       ; not immediate
     61.4  000823              link    SET     $
     61.5  000823 05                   DB      5
     61.6  000824 43454C4C53           DB      'CELLS'
     61.7  000829 00                   EVEN
     61.8  00082A                      IF      'TWOSTAR+2'='DOCODE'
     61.9  00082A              CELLS: DW     $+2
     61.10 00082A                      ELSE
     61.11 00082A ....         CELLS: DW      TWOSTAR+2
     61.12 00082C                      ENDIF
     61.13 00082C                      ENDM
     62    00082C              
     63    00082C              ;C CHAR+    c-addr1 -- c-addr2   add char
                                size
     64    00082C                      HEADER  CHARPLUS,5,'CHAR+',ONEPLUS+2
     64.1  000000                      PUBLIC  CHARPLUS
     64.2  00082C ....                 DW      link
     64.3  00082E FF                   DB      0FFh       ; not immediate
     64.4  00082F              link    SET     $
     64.5  00082F 05                   DB      5
     64.6  000830 434841522B           DB      'CHAR+'
     64.7  000835 00                   EVEN
     64.8  000836                      IF      'ONEPLUS+2'='DOCODE'
     64.9  000836              CHARPLUS: DW     $+2
     64.10 000836                      ELSE
     64.11 000836 ....         CHARPLUS: DW      ONEPLUS+2
     64.12 000838                      ENDIF
     64.13 000838                      ENDM
     65    000838              
     66    000838              ;C CHARS    n1 -- n2            chars->adrs
                                units
     67    000838                      HEADER  CHARS,5,'CHARS',donoop
     67.1  000000                      PUBLIC  CHARS
     67.2  000838 ....                 DW      link
     67.3  00083A FF                   DB      0FFh       ; not immediate
     67.4  00083B              link    SET     $
     67.5  00083B 05                   DB      5
     67.6  00083C 4348415253           DB      'CHARS'
     67.7  000841 00                   EVEN
     67.8  000842                      IF      'donoop'='DOCODE'
     67.9  000842              CHARS: DW     $+2
     67.10 000842                      ELSE
     67.11 000842 ....         CHARS: DW      donoop
     67.12 000844                      ENDIF
     67.13 000844                      ENDM
     68    000844              
     69    000844              ;C >BODY    xt -- a-addr      adrs of CREATE
                                data
     70    000844              ;   2+ ;                   8086 (3 byte
                                CALL)
     71    000844                      HEADER  TOBODY,5,'>BODY',CELLPLUS+2
     71.1  000000                      PUBLIC  TOBODY
     71.2  000844 ....                 DW      link
     71.3  000846 FF                   DB      0FFh       ; not immediate
     71.4  000847              link    SET     $
     71.5  000847 05                   DB      5
     71.6  000848 3E424F4459           DB      '>BODY'
     71.7  00084D 00                   EVEN
     71.8  00084E                      IF      'CELLPLUS+2'='DOCODE'
     71.9  00084E              TOBODY: DW     $+2
     71.10 00084E                      ELSE
     71.11 00084E ....         TOBODY: DW      CELLPLUS+2
     71.12 000850                      ENDIF
     71.13 000850                      ENDM
     72    000850              
     73    000850              ;X COMPILE,  xt --         append execution
                                token
     74    000850              ; I called this word ,XT before I discovered
                                that it is defined in the 
     75    000850              ; ANSI standard as COMPILE,. On a DTC Forth this
                                simply appends xt 
     76    000850              ; (like , ) but on an STC Forth this must append
                                'CALL xt'.
     77    000850                      HEADER  COMMAXT,8,'COMPILE,',DOALIAS
     77.1  000000                      PUBLIC  COMMAXT
     77.2  000850 ....                 DW      link
     77.3  000852 FF                   DB      0FFh       ; not immediate
     77.4  000853              link    SET     $
     77.5  000853 08                   DB      8
     77.6  000854 434F4D50494C*        DB      'COMPILE,'
     77.7  00085C                      EVEN
     77.8  00085C                      IF      'DOALIAS'='DOCODE'
     77.9  00085C              COMMAXT: DW     $+2
     77.10 00085C                      ELSE
     77.11 00085C ....         COMMAXT: DW      DOALIAS
     77.12 00085E                      ENDIF
     77.13 00085E                      ENDM
     78    00085E ....                 DW  ICOMMA
     79    000860              
     80    000860              ;Z !CF    adrs cfa --   set code action of a
                                word
     81    000860              ;   I! ;  
     82    000860              ; Indirect threaded model just stores adrs in
                                cfa field.
     83    000860                      HEADER  STORECF,3,'!CF',DOALIAS
     83.1  000000                      PUBLIC  STORECF
     83.2  000860 ....                 DW      link
     83.3  000862 FF                   DB      0FFh       ; not immediate
     83.4  000863              link    SET     $
     83.5  000863 03                   DB      3
     83.6  000864 214346               DB      '!CF'
     83.7  000867 00                   EVEN
     83.8  000868                      IF      'DOALIAS'='DOCODE'
     83.9  000868              STORECF: DW     $+2
     83.10 000868                      ELSE
     83.11 000868 ....         STORECF: DW      DOALIAS
     83.12 00086A                      ENDIF
     83.13 00086A                      ENDM
     84    00086A ....                 DW  ISTORE
     85    00086C              
     86    00086C              ;Z ,CF    adrs --       append a code field
     87    00086C              ;   IHERE !CF 2 IALLOT ;  MSP430 VERSION (2
                                bytes)
     88    00086C                      HEADER  COMMACF,3,',CF',DOCOLON
     88.1  000000                      PUBLIC  COMMACF
     88.2  00086C ....                 DW      link
     88.3  00086E FF                   DB      0FFh       ; not immediate
     88.4  00086F              link    SET     $
     88.5  00086F 03                   DB      3
     88.6  000870 2C4346               DB      ',CF'
     88.7  000873 00                   EVEN
     88.8  000874                      IF      'DOCOLON'='DOCODE'
     88.9  000874              COMMACF: DW     $+2
     88.10 000874                      ELSE
     88.11 000874 ....         COMMACF: DW      DOCOLON
     88.12 000876                      ENDIF
     88.13 000876                      ENDM
     89    000876 ............*        DW IHERE,STORECF,lit,2,IALLOT,EXIT
     90    000882              
     91    000882              ;Z ,CALL  adrs --       append a subroutine
                                CALL
     92    000882              ; MSP430:  128x is call, Ad=11, Dreg=0000 (PC) 
                                thus append 12B0,adrs.
     93    000882                      HEADER  COMMACALL,5,',CALL',DOCOLON
     93.1  000000                      PUBLIC  COMMACALL
     93.2  000882 ....                 DW      link
     93.3  000884 FF                   DB      0FFh       ; not immediate
     93.4  000885              link    SET     $
     93.5  000885 05                   DB      5
     93.6  000886 2C43414C4C           DB      ',CALL'
     93.7  00088B 00                   EVEN
     93.8  00088C                      IF      'DOCOLON'='DOCODE'
     93.9  00088C              COMMACALL: DW     $+2
     93.10 00088C                      ELSE
     93.11 00088C ....         COMMACALL: DW      DOCOLON
     93.12 00088E                      ENDIF
     93.13 00088E                      ENDM
     94    00088E ....B012....*        DW lit,12B0h,ICOMMA,ICOMMA,EXIT
     95    000898              
     96    000898              ;Z ,JMP   adrs --       append an absolute
                                16-bit JMP  (MOV #xx,PC)
     97    000898              ; MSP430:  opcode 4, Sreg=0000, Ad=0, As=11
                                (immed), Dreg=0000 (PC)  
     98    000898              ; thus append 4030,adrs.
     99    000898                      HEADER  COMMAJMP,4,',JMP',DOCOLON
     99.1  000000                      PUBLIC  COMMAJMP
     99.2  000898 ....                 DW      link
     99.3  00089A FF                   DB      0FFh       ; not immediate
     99.4  00089B              link    SET     $
     99.5  00089B 04                   DB      4
     99.6  00089C 2C4A4D50             DB      ',JMP'
     99.7  0008A0                      EVEN
     99.8  0008A0                      IF      'DOCOLON'='DOCODE'
     99.9  0008A0              COMMAJMP: DW     $+2
     99.10 0008A0                      ELSE
     99.11 0008A0 ....         COMMAJMP: DW      DOCOLON
     99.12 0008A2                      ENDIF
     99.13 0008A2                      ENDM
    100    0008A2 ....3040....*        DW lit,4030h,ICOMMA,ICOMMA,EXIT
    101    0008AC              
    102    0008AC              ;Z !COLON   --      change code field to
                                DOCOLON
    103    0008AC              ;   -2 IALLOT DOCOLON-adrs ,CF ;
    104    0008AC              ; This should be used immediately after
                                CREATE.
    105    0008AC              ; This is made a distinct word, because on an
                                STC
    106    0008AC              ; Forth, colon definitions have no code
                                field.
    107    0008AC                      HEADER  STORCOLON,6,'!COLON',DOCOLON
    107.1  000000                      PUBLIC  STORCOLON
    107.2  0008AC ....                 DW      link
    107.3  0008AE FF                   DB      0FFh       ; not immediate
    107.4  0008AF              link    SET     $
    107.5  0008AF 06                   DB      6
    107.6  0008B0 21434F4C4F4E         DB      '!COLON'
    107.7  0008B6                      EVEN
    107.8  0008B6                      IF      'DOCOLON'='DOCODE'
    107.9  0008B6              STORCOLON: DW     $+2
    107.10 0008B6                      ELSE
    107.11 0008B6 ....         STORCOLON: DW      DOCOLON
    107.12 0008B8                      ENDIF
    107.13 0008B8                      ENDM
    108    0008B8 ....FEFF....         DW lit,-2,IALLOT
    109    0008BE ............*        DW lit,DOCOLON,COMMACF,EXIT
    110    0008C6              
    111    0008C6              ;Z ,EXIT    --      append hi-level EXIT
                                action
    112    0008C6              ;   ['] EXIT ,XT ;
    113    0008C6              ; This is made a distinct word, because on an
                                STC
    114    0008C6              ; Forth, it appends a RET instruction, not an
                                xt.
    115    0008C6                      HEADER  CEXIT,5,',EXIT',DOCOLON
    115.1  000000                      PUBLIC  CEXIT
    115.2  0008C6 ....                 DW      link
    115.3  0008C8 FF                   DB      0FFh       ; not immediate
    115.4  0008C9              link    SET     $
    115.5  0008C9 05                   DB      5
    115.6  0008CA 2C45584954           DB      ',EXIT'
    115.7  0008CF 00                   EVEN
    115.8  0008D0                      IF      'DOCOLON'='DOCODE'
    115.9  0008D0              CEXIT: DW     $+2
    115.10 0008D0                      ELSE
    115.11 0008D0 ....         CEXIT: DW      DOCOLON
    115.12 0008D2                      ENDIF
    115.13 0008D2                      ENDM
    116    0008D2 ............*        DW lit,EXIT,COMMAXT,EXIT
    117    0008DA              
    118    0008DA              ; ----------------------------------------------
                               ------------------------
    119    0008DA              ; CONTROL STRUCTURES 
    120    0008DA              ; These words allow Forth control structure
                                words
    121    0008DA              ; to be defined portably.
    122    0008DA              
    123    0008DA              ;Z ,BRANCH   xt --    append a branch instructio
                               n
    124    0008DA              ; xt is the branch operator to use, e.g. qbranch
                                or (loop).  
    125    0008DA              ; It does NOT append the destination address. 
                                
    126    0008DA              ; On the MSP430 this is equivalent to ,XT
                                (above).
    127    0008DA                      HEADER  COMMABRANCH,7,',BRANCH',DOALIAS
    127.1  000000                      PUBLIC  COMMABRANCH
    127.2  0008DA ....                 DW      link
    127.3  0008DC FF                   DB      0FFh       ; not immediate
    127.4  0008DD              link    SET     $
    127.5  0008DD 07                   DB      7
    127.6  0008DE 2C4252414E43*        DB      ',BRANCH'
    127.7  0008E5 00                   EVEN
    127.8  0008E6                      IF      'DOALIAS'='DOCODE'
    127.9  0008E6              COMMABRANCH: DW     $+2
    127.10 0008E6                      ELSE
    127.11 0008E6 ....         COMMABRANCH: DW      DOALIAS
    127.12 0008E8                      ENDIF
    127.13 0008E8                      ENDM
    128    0008E8 ....                 DW  ICOMMA
    129    0008EA              
    130    0008EA              ;Z ,DEST   dest --        append a branch
                                address
    131    0008EA              ;   IHERE - , ;
    132    0008EA              ; This appends the given destination address to
                                the branch instruction. 
    133    0008EA              ; The MSP430 uses relative addressing from the
                                location of the offset cell,
    134    0008EA              ; i.e., to branch to FOO the offset cell at $
                                contains FOO-$.
    135    0008EA                      HEADER  COMMADEST,5,',DEST',DOCOLON
    135.1  000000                      PUBLIC  COMMADEST
    135.2  0008EA ....                 DW      link
    135.3  0008EC FF                   DB      0FFh       ; not immediate
    135.4  0008ED              link    SET     $
    135.5  0008ED 05                   DB      5
    135.6  0008EE 2C44455354           DB      ',DEST'
    135.7  0008F3 00                   EVEN
    135.8  0008F4                      IF      'DOCOLON'='DOCODE'
    135.9  0008F4              COMMADEST: DW     $+2
    135.10 0008F4                      ELSE
    135.11 0008F4 ....         COMMADEST: DW      DOCOLON
    135.12 0008F6                      ENDIF
    135.13 0008F6                      ENDM
    136    0008F6 ............*        DW  IHERE,MINUS,ICOMMA,EXIT
    137    0008FE              
    138    0008FE              ;Z !DEST   dest adrs --    change a branch
                                dest'n
    139    0008FE              ;   TUCK - SWAP I! ;
    140    0008FE              ; Changes the destination address found at
                                'adrs' to the given 'dest'.  
    141    0008FE              ; The MSP430 uses relative addressing from the
                                location of the offset cell,
    142    0008FE              ; i.e., to branch to FOO the offset cell at $
                                contains FOO-$.
    143    0008FE                      HEADER  STOREDEST,5,'!DEST',DOCOLON
    143.1  000000                      PUBLIC  STOREDEST
    143.2  0008FE ....                 DW      link
    143.3  000900 FF                   DB      0FFh       ; not immediate
    143.4  000901              link    SET     $
    143.5  000901 05                   DB      5
    143.6  000902 2144455354           DB      '!DEST'
    143.7  000907 00                   EVEN
    143.8  000908                      IF      'DOCOLON'='DOCODE'
    143.9  000908              STOREDEST: DW     $+2
    143.10 000908                      ELSE
    143.11 000908 ....         STOREDEST: DW      DOCOLON
    143.12 00090A                      ENDIF
    143.13 00090A                      ENDM
    144    00090A ............*        DW  TUCK,MINUS,SWAP,ISTORE,EXIT
    145    000914              
    146    000914              ;Z ,NONE   --              append a null
                                destination (Flashable)
    147    000914              ;   CELL IALLOT ;
    148    000914              ; When compiling in Flash ROM a branch to be
                                resolved later, we must
    149    000914              ; skip the cell so that it can be programmed at
                                a later time.
    150    000914              ; In general Flash memory can only be written
                                once!
    151    000914              ; ,NONE should be used wherever !DEST will
                                resolve the branch.
    152    000914                      HEADER  COMMANONE,5,',NONE',DOCOLON
    152.1  000000                      PUBLIC  COMMANONE
    152.2  000914 ....                 DW      link
    152.3  000916 FF                   DB      0FFh       ; not immediate
    152.4  000917              link    SET     $
    152.5  000917 05                   DB      5
    152.6  000918 2C4E4F4E45           DB      ',NONE'
    152.7  00091D 00                   EVEN
    152.8  00091E                      IF      'DOCOLON'='DOCODE'
    152.9  00091E              COMMANONE: DW     $+2
    152.10 00091E                      ELSE
    152.11 00091E ....         COMMANONE: DW      DOCOLON
    152.12 000920                      ENDIF
    152.13 000920                      ENDM
    153    000920 ............         DW  CELL,IALLOT,EXIT
    154    000926              
    155    000926              ; ----------------------------------------------
                               ------------------------
    156    000926              ; HEADER STRUCTURE 
    157    000926              ; The structure of the Forth dictionary headers
                                (name, link, immediate 
    158    000926              ; flag, and "smudge" bit) does not necessarily
                                differ across CPUs.  This
    159    000926              ; structure is not easily factored into distinct
                                "portable" words; 
    160    000926              ; instead, it is implicit in the definitions of
                                FIND and CREATE, and 
    161    000926              ; also in NFA>LFA, NFA>CFA, IMMED?, IMMEDIATE,
                                HIDE, and REVEAL.
    162    000926              ; These words must be (substantially) rewritten
                                if either the header 
    163    000926              ; structure or its inherent assumptions are
                                changed.
    164    000926              
    904    000926              #include "4e-hilvl430G2553.s43"
      1    000926              ; ----------------------------------------------
                               ------------------------
      2    000926              ; 4e4th is a Forth based on CamelForth
                                
      3    000926              ; for the Texas Instruments MSP430 
      4    000926              ; 
      5    000926              ; This program is free software; you can
                                redistribute it and/or modify
      6    000926              ; it under the terms of the GNU General Public
                                License as published by
      7    000926              ; the Free Software Foundation; either version 3
                                of the License, or
      8    000926              ; (at your option) any later version.
      9    000926              ; 
     10    000926              ; This program is distributed in the hope that
                                it will be useful,
     11    000926              ; but WITHOUT ANY WARRANTY; without even the
                                implied warranty of
     12    000926              ; MERCHANTABILITY or FITNESS FOR A PARTICULAR
                                PURPOSE.  See the
     13    000926              ; GNU General Public License for more details.
     14    000926              ;
     15    000926              ; You should have received a copy of the GNU
                                General Public License
     16    000926              ; along with this program.  If not, see
                                <http://www.gnu.org/licenses/>.
     17    000926              ; 
     18    000926              ; See LICENSE TERMS in Brads file readme.txt as
                                well.
     19    000926              
     20    000926              ; ----------------------------------------------
                               ------------------------
     21    000926              ; 4e-hilvl430G2553.s43 - High Level Words -
                                MSP430G2553 
     22    000926              ; ----------------------------------------------
                               ------------------------
     23    000926              
     24    000926              ;   Forth words are documented as follows:
     25    000926              ;x   NAME     stack -- stack    description
     26    000926              ;   where x=C for ANS Forth Core words, X for
                                ANS
     27    000926              ;   Extensions, Z for internal or private
                                words.
     28    000926              ; ----------------------------------------------
                               ------------------------
     29    000926              ; REVISION HISTORY
     30    000926              
     31    000926              ; 30 Mar 2012 mk fixed FM/MOD
     32    000926              ; 26 Feb 2012 mk - adopted to MSP430G2553
     33    000926              ;   MEM ( -- n ) n = bytes left in flash
     34    000926              ;   FLASHEND constant MEMTOP
     35    000926              ;   FLASHSTART constant MEMBOT
     36    000926              ;   kernel at $E000, IDP = FLASHSTART =
                                C000
     37    000926              ;   fixed backspace.
     38    000926              ;   ok promt at end of line.
     39    000926              ;   .S prints depth.
     40    000926              ; 
     41    000926              ; 17 jan 09 bjr - changed label _DP to DDP for
                                compatibility with token
     42    000926              ;   naming convention.  Now uses DEST macro to
                                compute branch offsets.
     43    000926              ; 11 jan 09 bjr - modified QUIT for Xon/Xoff
                                flow control
     44    000926              ; 4 jan 09 bjr - created from Camel86h.asm.
     45    000926              
     46    000926              ; SYSTEM VARIABLES & CONSTANTS =================
                               =
     47    000926              
     48    000926              ;Z u0      -- a-addr       current user area
                                adrs
     49    000926              ;  0 USER U0
     50    000926                  HEADER  U0,2,'U0',DOUSER
     50.1  000000                      PUBLIC  U0
     50.2  000926 ....                 DW      link
     50.3  000928 FF                   DB      0FFh       ; not immediate
     50.4  000929              link    SET     $
     50.5  000929 02                   DB      2
     50.6  00092A 5530                 DB      'U0'
     50.7  00092C                      EVEN
     50.8  00092C                      IF      'DOUSER'='DOCODE'
     50.9  00092C              U0: DW     $+2
     50.10 00092C                      ELSE
     50.11 00092C ....         U0: DW      DOUSER
     50.12 00092E                      ENDIF
     50.13 00092E                      ENDM
     51    00092E 0000                 DW 0
     52    000930              
     53    000930              ;C >IN     -- a-addr        holds offset into
                                TIB
     54    000930              ;  2 USER >IN
     55    000930                  HEADER  TOIN,3,'>IN',DOUSER
     55.1  000000                      PUBLIC  TOIN
     55.2  000930 ....                 DW      link
     55.3  000932 FF                   DB      0FFh       ; not immediate
     55.4  000933              link    SET     $
     55.5  000933 03                   DB      3
     55.6  000934 3E494E               DB      '>IN'
     55.7  000937 00                   EVEN
     55.8  000938                      IF      'DOUSER'='DOCODE'
     55.9  000938              TOIN: DW     $+2
     55.10 000938                      ELSE
     55.11 000938 ....         TOIN: DW      DOUSER
     55.12 00093A                      ENDIF
     55.13 00093A                      ENDM
     56    00093A 0200                 DW 2
     57    00093C              
     58    00093C              ;C BASE    -- a-addr       holds conversion
                                radix
     59    00093C              ;  4 USER BASE
     60    00093C                  HEADER  BASE,4,'BASE',DOUSER
     60.1  000000                      PUBLIC  BASE
     60.2  00093C ....                 DW      link
     60.3  00093E FF                   DB      0FFh       ; not immediate
     60.4  00093F              link    SET     $
     60.5  00093F 04                   DB      4
     60.6  000940 42415345             DB      'BASE'
     60.7  000944                      EVEN
     60.8  000944                      IF      'DOUSER'='DOCODE'
     60.9  000944              BASE: DW     $+2
     60.10 000944                      ELSE
     60.11 000944 ....         BASE: DW      DOUSER
     60.12 000946                      ENDIF
     60.13 000946                      ENDM
     61    000946 0400                 DW 4
     62    000948              
     63    000948              ;C STATE   -- a-addr       holds compiler
                                state
     64    000948              ;  6 USER STATE
     65    000948                  HEADER  STATE,5,'STATE',DOUSER
     65.1  000000                      PUBLIC  STATE
     65.2  000948 ....                 DW      link
     65.3  00094A FF                   DB      0FFh       ; not immediate
     65.4  00094B              link    SET     $
     65.5  00094B 05                   DB      5
     65.6  00094C 5354415445           DB      'STATE'
     65.7  000951 00                   EVEN
     65.8  000952                      IF      'DOUSER'='DOCODE'
     65.9  000952              STATE: DW     $+2
     65.10 000952                      ELSE
     65.11 000952 ....         STATE: DW      DOUSER
     65.12 000954                      ENDIF
     65.13 000954                      ENDM
     66    000954 0600                 DW 6
     67    000956              
     68    000956              ;Z dp      -- a-addr       holds dictionary
                                ptr
     69    000956              ;  8 USER DP
     70    000956                  HEADER  DDP,2,'DP',DOUSER
     70.1  000000                      PUBLIC  DDP
     70.2  000956 ....                 DW      link
     70.3  000958 FF                   DB      0FFh       ; not immediate
     70.4  000959              link    SET     $
     70.5  000959 02                   DB      2
     70.6  00095A 4450                 DB      'DP'
     70.7  00095C                      EVEN
     70.8  00095C                      IF      'DOUSER'='DOCODE'
     70.9  00095C              DDP: DW     $+2
     70.10 00095C                      ELSE
     70.11 00095C ....         DDP: DW      DOUSER
     70.12 00095E                      ENDIF
     70.13 00095E                      ENDM
     71    00095E 0800                 DW 8
     72    000960              
     73    000960              ;Z 'source  -- a-addr      two cells: len,
                                adrs
     74    000960              ; 10 USER 'SOURCE
     75    000960                  HEADER  TICKSOURCE,7,'\'SOURCE',DOUSER
     75.1  000000                      PUBLIC  TICKSOURCE
     75.2  000960 ....                 DW      link
     75.3  000962 FF                   DB      0FFh       ; not immediate
     75.4  000963              link    SET     $
     75.5  000963 07                   DB      7
     75.6  000964 27534F555243*        DB      '\'SOURCE'
     75.7  00096B 00                   EVEN
     75.8  00096C                      IF      'DOUSER'='DOCODE'
     75.9  00096C              TICKSOURCE: DW     $+2
     75.10 00096C                      ELSE
     75.11 00096C ....         TICKSOURCE: DW      DOUSER
     75.12 00096E                      ENDIF
     75.13 00096E                      ENDM
     76    00096E 0A00                 DW 10
     77    000970              
     78    000970              ;Z latest    -- a-addr     last word in
                                dict.
     79    000970              ;   14 USER LATEST
     80    000970                  HEADER  LATEST,6,'LATEST',DOUSER
     80.1  000000                      PUBLIC  LATEST
     80.2  000970 ....                 DW      link
     80.3  000972 FF                   DB      0FFh       ; not immediate
     80.4  000973              link    SET     $
     80.5  000973 06                   DB      6
     80.6  000974 4C4154455354         DB      'LATEST'
     80.7  00097A                      EVEN
     80.8  00097A                      IF      'DOUSER'='DOCODE'
     80.9  00097A              LATEST: DW     $+2
     80.10 00097A                      ELSE
     80.11 00097A ....         LATEST: DW      DOUSER
     80.12 00097C                      ENDIF
     80.13 00097C                      ENDM
     81    00097C 0E00                 DW 14
     82    00097E              
     83    00097E              ;Z hp       -- a-addr     HOLD pointer
     84    00097E              ;   16 USER HP
     85    00097E                  HEADER  HP,2,'HP',DOUSER
     85.1  000000                      PUBLIC  HP
     85.2  00097E ....                 DW      link
     85.3  000980 FF                   DB      0FFh       ; not immediate
     85.4  000981              link    SET     $
     85.5  000981 02                   DB      2
     85.6  000982 4850                 DB      'HP'
     85.7  000984                      EVEN
     85.8  000984                      IF      'DOUSER'='DOCODE'
     85.9  000984              HP: DW     $+2
     85.10 000984                      ELSE
     85.11 000984 ....         HP: DW      DOUSER
     85.12 000986                      ENDIF
     85.13 000986                      ENDM
     86    000986 1000                 DW 16
     87    000988              
     88    000988              ;Z LP       -- a-addr     Leave-stack pointer
     89    000988              ;   18 USER LP
     90    000988                  HEADER  LP,2,'LP',DOUSER
     90.1  000000                      PUBLIC  LP
     90.2  000988 ....                 DW      link
     90.3  00098A FF                   DB      0FFh       ; not immediate
     90.4  00098B              link    SET     $
     90.5  00098B 02                   DB      2
     90.6  00098C 4C50                 DB      'LP'
     90.7  00098E                      EVEN
     90.8  00098E                      IF      'DOUSER'='DOCODE'
     90.9  00098E              LP: DW     $+2
     90.10 00098E                      ELSE
     90.11 00098E ....         LP: DW      DOUSER
     90.12 000990                      ENDIF
     90.13 000990                      ENDM
     91    000990 1200                 DW 18
     92    000992              
     93    000992              ;Z IDP    -- a-addr        ROM dictionary
                                pointer
     94    000992              ;   20 USER IDP
     95    000992                  HEADER  IDP,3,'IDP',DOUSER
     95.1  000000                      PUBLIC  IDP
     95.2  000992 ....                 DW      link
     95.3  000994 FF                   DB      0FFh       ; not immediate
     95.4  000995              link    SET     $
     95.5  000995 03                   DB      3
     95.6  000996 494450               DB      'IDP'
     95.7  000999 00                   EVEN
     95.8  00099A                      IF      'DOUSER'='DOCODE'
     95.9  00099A              IDP: DW     $+2
     95.10 00099A                      ELSE
     95.11 00099A ....         IDP: DW      DOUSER
     95.12 00099C                      ENDIF
     95.13 00099C                      ENDM
     96    00099C 1400                 DW 20
     97    00099E              
     98    00099E              ;Z NEWEST   -- a-addr       temporary LATEST
                                storage
     99    00099E              ;   22 USER NEWEST
    100    00099E                  HEADER  NEWEST,6,'NEWEST',DOUSER
    100.1  000000                      PUBLIC  NEWEST
    100.2  00099E ....                 DW      link
    100.3  0009A0 FF                   DB      0FFh       ; not immediate
    100.4  0009A1              link    SET     $
    100.5  0009A1 06                   DB      6
    100.6  0009A2 4E4557455354         DB      'NEWEST'
    100.7  0009A8                      EVEN
    100.8  0009A8                      IF      'DOUSER'='DOCODE'
    100.9  0009A8              NEWEST: DW     $+2
    100.10 0009A8                      ELSE
    100.11 0009A8 ....         NEWEST: DW      DOUSER
    100.12 0009AA                      ENDIF
    100.13 0009AA                      ENDM
    101    0009AA 1600                 DW 22
    102    0009AC              
    103    0009AC              ;Z APP      -- a-addr        xt of app ( was
                                TURNKEY)
    104    0009AC              ;    24 USER APP
    105    0009AC                  HEADER  APP,3,'APP',DOUSER
    105.1  000000                      PUBLIC  APP
    105.2  0009AC ....                 DW      link
    105.3  0009AE FF                   DB      0FFh       ; not immediate
    105.4  0009AF              link    SET     $
    105.5  0009AF 03                   DB      3
    105.6  0009B0 415050               DB      'APP'
    105.7  0009B3 00                   EVEN
    105.8  0009B4                      IF      'DOUSER'='DOCODE'
    105.9  0009B4              APP: DW     $+2
    105.10 0009B4                      ELSE
    105.11 0009B4 ....         APP: DW      DOUSER
    105.12 0009B6                      ENDIF
    105.13 0009B6                      ENDM
    106    0009B6 1800                 DW 24
    107    0009B8              
    108    0009B8              ;Z CAPS     -- a-addr        capitalize
                                words
    109    0009B8              ;    26 USER CAPS
    110    0009B8                  HEADER  CAPS,4,'CAPS',DOUSER
    110.1  000000                      PUBLIC  CAPS
    110.2  0009B8 ....                 DW      link
    110.3  0009BA FF                   DB      0FFh       ; not immediate
    110.4  0009BB              link    SET     $
    110.5  0009BB 04                   DB      4
    110.6  0009BC 43415053             DB      'CAPS'
    110.7  0009C0                      EVEN
    110.8  0009C0                      IF      'DOUSER'='DOCODE'
    110.9  0009C0              CAPS: DW     $+2
    110.10 0009C0                      ELSE
    110.11 0009C0 ....         CAPS: DW      DOUSER
    110.12 0009C2                      ENDIF
    110.13 0009C2                      ENDM
    111    0009C2 1A00                 DW 26
    112    0009C4              
    113    0009C4              ; user variables 28,30 tbd
    114    0009C4              
    115    0009C4              ;X PAD       -- a-addr    user PAD buffer
    116    0009C4              ;                         = end of hold
                                area!
    117    0009C4                  HEADER  PAD,3,'PAD',DOUSER
    117.1  000000                      PUBLIC  PAD
    117.2  0009C4 ....                 DW      link
    117.3  0009C6 FF                   DB      0FFh       ; not immediate
    117.4  0009C7              link    SET     $
    117.5  0009C7 03                   DB      3
    117.6  0009C8 504144               DB      'PAD'
    117.7  0009CB 00                   EVEN
    117.8  0009CC                      IF      'DOUSER'='DOCODE'
    117.9  0009CC              PAD: DW     $+2
    117.10 0009CC                      ELSE
    117.11 0009CC ....         PAD: DW      DOUSER
    117.12 0009CE                      ENDIF
    117.13 0009CE                      ENDM
    118    0009CE ....                 DW PADAREA-UAREA
    119    0009D0              
    120    0009D0              ;Z l0       -- a-addr     bottom of Leave
                                stack
    121    0009D0                  HEADER  L0,2,'L0',DOUSER
    121.1  000000                      PUBLIC  L0
    121.2  0009D0 ....                 DW      link
    121.3  0009D2 FF                   DB      0FFh       ; not immediate
    121.4  0009D3              link    SET     $
    121.5  0009D3 02                   DB      2
    121.6  0009D4 4C30                 DB      'L0'
    121.7  0009D6                      EVEN
    121.8  0009D6                      IF      'DOUSER'='DOCODE'
    121.9  0009D6              L0: DW     $+2
    121.10 0009D6                      ELSE
    121.11 0009D6 ....         L0: DW      DOUSER
    121.12 0009D8                      ENDIF
    121.13 0009D8                      ENDM
    122    0009D8 ....                 DW LSTACK-UAREA
    123    0009DA              
    124    0009DA              ;Z r0       -- a-addr     end of return
                                stack
    125    0009DA                  HEADER  RZERO,2,'R0',DOUSER
    125.1  000000                      PUBLIC  RZERO
    125.2  0009DA ....                 DW      link
    125.3  0009DC FF                   DB      0FFh       ; not immediate
    125.4  0009DD              link    SET     $
    125.5  0009DD 02                   DB      2
    125.6  0009DE 5230                 DB      'R0'
    125.7  0009E0                      EVEN
    125.8  0009E0                      IF      'DOUSER'='DOCODE'
    125.9  0009E0              RZERO: DW     $+2
    125.10 0009E0                      ELSE
    125.11 0009E0 ....         RZERO: DW      DOUSER
    125.12 0009E2                      ENDIF
    125.13 0009E2                      ENDM
    126    0009E2 ....                 DW RSTACK-UAREA
    127    0009E4              
    128    0009E4              ;Z s0       -- a-addr     end of parameter
                                stack
    129    0009E4                  HEADER  S0,2,'S0',DOUSER
    129.1  000000                      PUBLIC  S0
    129.2  0009E4 ....                 DW      link
    129.3  0009E6 FF                   DB      0FFh       ; not immediate
    129.4  0009E7              link    SET     $
    129.5  0009E7 02                   DB      2
    129.6  0009E8 5330                 DB      'S0'
    129.7  0009EA                      EVEN
    129.8  0009EA                      IF      'DOUSER'='DOCODE'
    129.9  0009EA              S0: DW     $+2
    129.10 0009EA                      ELSE
    129.11 0009EA ....         S0: DW      DOUSER
    129.12 0009EC                      ENDIF
    129.13 0009EC                      ENDM
    130    0009EC ....                 DW PSTACK-UAREA
    131    0009EE              
    132    0009EE              ;X tib     -- a-addr     Terminal Input
                                Buffer
    133    0009EE              ;  HEX 80 USER TIB       8086: above user
                                area
    134    0009EE                  HEADER  TIB,3,'TIB',DOUSER
    134.1  000000                      PUBLIC  TIB
    134.2  0009EE ....                 DW      link
    134.3  0009F0 FF                   DB      0FFh       ; not immediate
    134.4  0009F1              link    SET     $
    134.5  0009F1 03                   DB      3
    134.6  0009F2 544942               DB      'TIB'
    134.7  0009F5 00                   EVEN
    134.8  0009F6                      IF      'DOUSER'='DOCODE'
    134.9  0009F6              TIB: DW     $+2
    134.10 0009F6                      ELSE
    134.11 0009F6 ....         TIB: DW      DOUSER
    134.12 0009F8                      ENDIF
    134.13 0009F8                      ENDM
    135    0009F8 ....                 DW TIBAREA-UAREA
    136    0009FA              
    137    0009FA              ;Z tibsize  -- n         size of TIB
    138    0009FA                  HEADER  TIBSIZE,7,'TIBSIZE',DOCON
    138.1  000000                      PUBLIC  TIBSIZE
    138.2  0009FA ....                 DW      link
    138.3  0009FC FF                   DB      0FFh       ; not immediate
    138.4  0009FD              link    SET     $
    138.5  0009FD 07                   DB      7
    138.6  0009FE 54494253495A*        DB      'TIBSIZE'
    138.7  000A05 00                   EVEN
    138.8  000A06                      IF      'DOCON'='DOCODE'
    138.9  000A06              TIBSIZE: DW     $+2
    138.10 000A06                      ELSE
    138.11 000A06 ....         TIBSIZE: DW      DOCON
    138.12 000A08                      ENDIF
    138.13 000A08                      ENDM
    139    000A08 ....                 DW TIB_SIZE-2    ; 2 chars safety zone
                                                         
    140    000A0A              
    141    000A0A              ;C BL      -- char            an ASCII
                                space
    142    000A0A                  HEADER  BLANK,2,'BL',DOCON
    142.1  000000                      PUBLIC  BLANK
    142.2  000A0A ....                 DW      link
    142.3  000A0C FF                   DB      0FFh       ; not immediate
    142.4  000A0D              link    SET     $
    142.5  000A0D 02                   DB      2
    142.6  000A0E 424C                 DB      'BL'
    142.7  000A10                      EVEN
    142.8  000A10                      IF      'DOCON'='DOCODE'
    142.9  000A10              BLANK: DW     $+2
    142.10 000A10                      ELSE
    142.11 000A10 ....         BLANK: DW      DOCON
    142.12 000A12                      ENDIF
    142.13 000A12                      ENDM
    143    000A12 2000                 DW 20h
    144    000A14              
    145    000A14              ;Z uinit    -- addr  initial values for user
                                area
    146    000A14              ; MSP430: we also use this to initialize the RAM
                                interrupt
    147    000A14              ; vectors, which immediately follow the user
                                area.
    148    000A14              ; Per init430f1611.s43, allocate 16 cells for
                                user
    149    000A14              ; variables, followed by 30 cells for interrupt
                                vectors.
    150    000A14                  HEADER  UINIT,5,'UINIT',DOROM
    150.1  000000                      PUBLIC  UINIT
    150.2  000A14 ....                 DW      link
    150.3  000A16 FF                   DB      0FFh       ; not immediate
    150.4  000A17              link    SET     $
    150.5  000A17 05                   DB      5
    150.6  000A18 55494E4954           DB      'UINIT'
    150.7  000A1D 00                   EVEN
    150.8  000A1E                      IF      'DOROM'='DOCODE'
    150.9  000A1E              UINIT: DW     $+2
    150.10 000A1E                      ELSE
    150.11 000A1E ....         UINIT: DW      DOROM
    150.12 000A20                      ENDIF
    150.13 000A20                      ENDM
    151    000A20 000000000A00*        DW 0,0,10,0     ; reserved,>IN,BASE,STAT
                                                       E  ; start in HEX 
                                                        mk
    152    000A28 ....                 DW RAMDICT      ; DP
    153    000A2A 00000000             DW 0,0          ; SOURCE init'd
                                                        elsewhere
    154    000A2E ....                 DW lastword     ; LATEST
    155    000A30 00000000             DW 0,0          ; HP,LP init'd
                                                        elsewhere
    156    000A34 00C0                 DW FLASHSTART   ; IDP
    157    000A36 0000                 DW 0            ; NEWEST not init'd
    158    000A38 ....                 DW DOTCOLD      ; app
    159    000A3A FFFF                 DW -1           ; CAPS on
    160    000A3C 00000000             DW 0,0          ; user variables
                                                        TBD
    161    000A40              
    162    000A40              /* not there     mk
    163    000A40              ; RAM interrupt vectors, 15 vectors of 2 cells
                                each
    164    000A40                      MOV #nullirq,PC
    165    000A40                      MOV #nullirq,PC
    166    000A40                      MOV #nullirq,PC
    167    000A40                      MOV #nullirq,PC
    168    000A40                      MOV #nullirq,PC
    169    000A40                      MOV #nullirq,PC
    170    000A40                      MOV #nullirq,PC
    171    000A40                      MOV #nullirq,PC
    172    000A40                      MOV #nullirq,PC
    173    000A40                      MOV #nullirq,PC
    174    000A40                      MOV #nullirq,PC
    175    000A40                      MOV #nullirq,PC
    176    000A40                      MOV #nullirq,PC
    177    000A40                      MOV #nullirq,PC
    178    000A40                      MOV #nullirq,PC
    179    000A40              */
    180    000A40              
    181    000A40              ;Z #init    -- n    #bytes of user area init
                                data
    182    000A40                  HEADER  NINIT,5,'#INIT',DOCON
    182.1  000000                      PUBLIC  NINIT
    182.2  000A40 ....                 DW      link
    182.3  000A42 FF                   DB      0FFh       ; not immediate
    182.4  000A43              link    SET     $
    182.5  000A43 05                   DB      5
    182.6  000A44 23494E4954           DB      '#INIT'
    182.7  000A49 00                   EVEN
    182.8  000A4A                      IF      'DOCON'='DOCODE'
    182.9  000A4A              NINIT: DW     $+2
    182.10 000A4A                      ELSE
    182.11 000A4A ....         NINIT: DW      DOCON
    182.12 000A4C                      ENDIF
    182.13 000A4C                      ENDM
    183    000A4C ....                 DW (UAREA_SIZE)*2     ; SIZEs given in
                                                              cells
    184    000A4E                      
    185    000A4E              
    186    000000              EXTERN cor,infoB,AppU0
    187    000A4E              ;Z COR      -- adr       cause of reset
    188    000A4E                  HEADER  COR,3,'COR',DOCON
    188.1  000000                      PUBLIC  COR
    188.2  000A4E ....                 DW      link
    188.3  000A50 FF                   DB      0FFh       ; not immediate
    188.4  000A51              link    SET     $
    188.5  000A51 03                   DB      3
    188.6  000A52 434F52               DB      'COR'
    188.7  000A55 00                   EVEN
    188.8  000A56                      IF      'DOCON'='DOCODE'
    188.9  000A56              COR: DW     $+2
    188.10 000A56                      ELSE
    188.11 000A56 ....         COR: DW      DOCON
    188.12 000A58                      ENDIF
    188.13 000A58                      ENDM
    189    000A58 ....                 DW cor
    190    000A5A              
    191    000A5A              ;Z INFOB    -- adr       start of info B
                                segment
    192    000A5A                  HEADER  INFOB,5,'INFOB',DOCON
    192.1  000000                      PUBLIC  INFOB
    192.2  000A5A ....                 DW      link
    192.3  000A5C FF                   DB      0FFh       ; not immediate
    192.4  000A5D              link    SET     $
    192.5  000A5D 05                   DB      5
    192.6  000A5E 494E464F42           DB      'INFOB'
    192.7  000A63 00                   EVEN
    192.8  000A64                      IF      'DOCON'='DOCODE'
    192.9  000A64              INFOB: DW     $+2
    192.10 000A64                      ELSE
    192.11 000A64 ....         INFOB: DW      DOCON
    192.12 000A66                      ENDIF
    192.13 000A66                      ENDM
    193    000A66 ....                 DW infoB
    194    000A68              
    195    000A68              ;Z APPU0    -- adr       start of Application
                                user area
    196    000A68                  HEADER  APPU0,5,'APPU0',DOCON
    196.1  000000                      PUBLIC  APPU0
    196.2  000A68 ....                 DW      link
    196.3  000A6A FF                   DB      0FFh       ; not immediate
    196.4  000A6B              link    SET     $
    196.5  000A6B 05                   DB      5
    196.6  000A6C 4150505530           DB      'APPU0'
    196.7  000A71 00                   EVEN
    196.8  000A72                      IF      'DOCON'='DOCODE'
    196.9  000A72              APPU0: DW     $+2
    196.10 000A72                      ELSE
    196.11 000A72 ....         APPU0: DW      DOCON
    196.12 000A74                      ENDIF
    196.13 000A74                      ENDM
    197    000A74 ....                 DW AppU0
    198    000A76                      
    199    000A76              
    200    000A76              ; ARITHMETIC OPERATORS =========================
                               =
    201    000A76              
    202    000A76              ;C S>D    n -- d          single -> double
                                prec.
    203    000A76              ;   DUP 0< ;
    204    000A76                  HEADER  STOD,3,'S>D',DOCOLON
    204.1  000000                      PUBLIC  STOD
    204.2  000A76 ....                 DW      link
    204.3  000A78 FF                   DB      0FFh       ; not immediate
    204.4  000A79              link    SET     $
    204.5  000A79 03                   DB      3
    204.6  000A7A 533E44               DB      'S>D'
    204.7  000A7D 00                   EVEN
    204.8  000A7E                      IF      'DOCOLON'='DOCODE'
    204.9  000A7E              STOD: DW     $+2
    204.10 000A7E                      ELSE
    204.11 000A7E ....         STOD: DW      DOCOLON
    204.12 000A80                      ENDIF
    204.13 000A80                      ENDM
    205    000A80 ............         DW DUP,ZEROLESS,EXIT
    206    000A86              
    207    000A86              ;Z ?NEGATE  n1 n2 -- n3  negate n1 if n2
                                negative
    208    000A86              ;   0< IF NEGATE THEN ;        ...a common
                                factor
    209    000A86                  HEADER  QNEGATE,7,'?NEGATE',DOCOLON
    209.1  000000                      PUBLIC  QNEGATE
    209.2  000A86 ....                 DW      link
    209.3  000A88 FF                   DB      0FFh       ; not immediate
    209.4  000A89              link    SET     $
    209.5  000A89 07                   DB      7
    209.6  000A8A 3F4E45474154*        DB      '?NEGATE'
    209.7  000A91 00                   EVEN
    209.8  000A92                      IF      'DOCOLON'='DOCODE'
    209.9  000A92              QNEGATE: DW     $+2
    209.10 000A92                      ELSE
    209.11 000A92 ....         QNEGATE: DW      DOCOLON
    209.12 000A94                      ENDIF
    209.13 000A94                      ENDM
    210    000A94 ........             DW ZEROLESS,qbran
    211    000A98                      DEST  QNEG1
    211.1  000A98 0400                 DW      QNEG1-$
    211.2  000A9A                      ENDM
    212    000A9A ....                 DW NEGATE
    213    000A9C ....         QNEG1:  DW EXIT
    214    000A9E              
    215    000A9E              ;C ABS     n1 -- +n2     absolute value
    216    000A9E              ;   DUP ?NEGATE ;
    217    000A9E                  HEADER  ABBS,3,'ABS',DOCOLON
    217.1  000000                      PUBLIC  ABBS
    217.2  000A9E ....                 DW      link
    217.3  000AA0 FF                   DB      0FFh       ; not immediate
    217.4  000AA1              link    SET     $
    217.5  000AA1 03                   DB      3
    217.6  000AA2 414253               DB      'ABS'
    217.7  000AA5 00                   EVEN
    217.8  000AA6                      IF      'DOCOLON'='DOCODE'
    217.9  000AA6              ABBS: DW     $+2
    217.10 000AA6                      ELSE
    217.11 000AA6 ....         ABBS: DW      DOCOLON
    217.12 000AA8                      ENDIF
    217.13 000AA8                      ENDM
    218    000AA8 ............         DW DUP,QNEGATE,EXIT
    219    000AAE              
    220    000AAE              ;X DNEGATE   d1 -- d2     negate double
                                precision
    221    000AAE              ;   SWAP INVERT SWAP INVERT 1 M+ ;
    222    000AAE                  HEADER  DNEGATE,7,'DNEGATE',DOCOLON
    222.1  000000                      PUBLIC  DNEGATE
    222.2  000AAE ....                 DW      link
    222.3  000AB0 FF                   DB      0FFh       ; not immediate
    222.4  000AB1              link    SET     $
    222.5  000AB1 07                   DB      7
    222.6  000AB2 444E45474154*        DB      'DNEGATE'
    222.7  000AB9 00                   EVEN
    222.8  000ABA                      IF      'DOCOLON'='DOCODE'
    222.9  000ABA              DNEGATE: DW     $+2
    222.10 000ABA                      ELSE
    222.11 000ABA ....         DNEGATE: DW      DOCOLON
    222.12 000ABC                      ENDIF
    222.13 000ABC                      ENDM
    223    000ABC ............*        DW SWAP,INVERT,SWAP,INVERT,lit,1,MPLUS
    224    000ACA ....                 DW EXIT
    225    000ACC              
    226    000ACC              ;Z ?DNEGATE  d1 n -- d2   negate d1 if n
                                negative
    227    000ACC              ;   0< IF DNEGATE THEN ;       ...a common
                                factor
    228    000ACC                  HEADER  QDNEGATE,8,'?DNEGATE',DOCOLON
    228.1  000000                      PUBLIC  QDNEGATE
    228.2  000ACC ....                 DW      link
    228.3  000ACE FF                   DB      0FFh       ; not immediate
    228.4  000ACF              link    SET     $
    228.5  000ACF 08                   DB      8
    228.6  000AD0 3F444E454741*        DB      '?DNEGATE'
    228.7  000AD8                      EVEN
    228.8  000AD8                      IF      'DOCOLON'='DOCODE'
    228.9  000AD8              QDNEGATE: DW     $+2
    228.10 000AD8                      ELSE
    228.11 000AD8 ....         QDNEGATE: DW      DOCOLON
    228.12 000ADA                      ENDIF
    228.13 000ADA                      ENDM
    229    000ADA ........             DW ZEROLESS,qbran
    230    000ADE                      DEST  DNEG1
    230.1  000ADE 0400                 DW      DNEG1-$
    230.2  000AE0                      ENDM
    231    000AE0 ....                 DW DNEGATE
    232    000AE2 ....         DNEG1:  DW EXIT
    233    000AE4              
    234    000AE4              ;X DABS     d1 -- +d2    absolute value
                                dbl.prec.
    235    000AE4              ;   DUP ?DNEGATE ;
    236    000AE4                  HEADER  DABS,4,'DABS',DOCOLON
    236.1  000000                      PUBLIC  DABS
    236.2  000AE4 ....                 DW      link
    236.3  000AE6 FF                   DB      0FFh       ; not immediate
    236.4  000AE7              link    SET     $
    236.5  000AE7 04                   DB      4
    236.6  000AE8 44414253             DB      'DABS'
    236.7  000AEC                      EVEN
    236.8  000AEC                      IF      'DOCOLON'='DOCODE'
    236.9  000AEC              DABS: DW     $+2
    236.10 000AEC                      ELSE
    236.11 000AEC ....         DABS: DW      DOCOLON
    236.12 000AEE                      ENDIF
    236.13 000AEE                      ENDM
    237    000AEE ............         DW DUP,QDNEGATE,EXIT
    238    000AF4              
    239    000AF4              ;C M*     n1 n2 -- d    signed 16*16->32
                                multiply
    240    000AF4              ;   2DUP XOR >R        carries sign of the
                                result
    241    000AF4              ;   SWAP ABS SWAP ABS UM*
    242    000AF4              ;   R> ?DNEGATE ;
    243    000AF4                  HEADER  MSTAR,2,'M*',DOCOLON
    243.1  000000                      PUBLIC  MSTAR
    243.2  000AF4 ....                 DW      link
    243.3  000AF6 FF                   DB      0FFh       ; not immediate
    243.4  000AF7              link    SET     $
    243.5  000AF7 02                   DB      2
    243.6  000AF8 4D2A                 DB      'M*'
    243.7  000AFA                      EVEN
    243.8  000AFA                      IF      'DOCOLON'='DOCODE'
    243.9  000AFA              MSTAR: DW     $+2
    243.10 000AFA                      ELSE
    243.11 000AFA ....         MSTAR: DW      DOCOLON
    243.12 000AFC                      ENDIF
    243.13 000AFC                      ENDM
    244    000AFC ............         DW TWODUP,XORR,TOR
    245    000B02 ............*        DW SWAP,ABBS,SWAP,ABBS,UMSTAR
    246    000B0C ............         DW RFROM,QDNEGATE,EXIT
    247    000B12              
    248    000B12              ;C SM/REM   d1 n1 -- n2 n3   symmetric signed
                                div
    249    000B12              ;   2DUP XOR >R              sign of quotient
    250    000B12              ;   OVER >R                  sign of remainder
    251    000B12              ;   ABS >R DABS R> UM/MOD
    252    000B12              ;   SWAP R> ?NEGATE
    253    000B12              ;   SWAP R> ?NEGATE ;
    254    000B12              ; Ref. dpANS-6 section 3.2.2.1.
    255    000B12                  HEADER  SMSLASHREM,6,'SM/REM',DOCOLON
    255.1  000000                      PUBLIC  SMSLASHREM
    255.2  000B12 ....                 DW      link
    255.3  000B14 FF                   DB      0FFh       ; not immediate
    255.4  000B15              link    SET     $
    255.5  000B15 06                   DB      6
    255.6  000B16 534D2F52454D         DB      'SM/REM'
    255.7  000B1C                      EVEN
    255.8  000B1C                      IF      'DOCOLON'='DOCODE'
    255.9  000B1C              SMSLASHREM: DW     $+2
    255.10 000B1C                      ELSE
    255.11 000B1C ....         SMSLASHREM: DW      DOCOLON
    255.12 000B1E                      ENDIF
    255.13 000B1E                      ENDM
    256    000B1E ............*        DW TWODUP,XORR,TOR,OVER,TOR
    257    000B28 ............*        DW ABBS,TOR,DABS,RFROM,UMSLASHMOD
    258    000B32 ............*        DW SWAP,RFROM,QNEGATE,SWAP,RFROM,QNEGATE
    259    000B3E ....                 DW EXIT
    260    000B40              
    261    000B40              ;C FM/MOD   d1 n1 -- n2 n3   floored signed
                                div'n
    262    000B40              ;                            Ching-Tang Tseng 
                                Mar 24 2012
    263    000B40              ;   DUP >R OVER OVER XOR >R 
    264    000B40              ;   SM/REM 
    265    000B40              ;   OVER R> 0< AND 
    266    000B40              ;   IF SWAP R@ + SWAP 1 - 
    267    000B40              ;   THEN R> DROP ; 
    268    000B40              ; 1 0 2 FM/MOD(OK) . . 0 1  ok 
    269    000B40              ; 7 0 9 FM/MOD(OK) . . 0 7  ok 
    270    000B40              ; Ref. dpANS-6 section 3.2.2.1.
    271    000B40                  HEADER  FMSLASHMOD,6,'FM/MOD',DOCOLON
    271.1  000000                      PUBLIC  FMSLASHMOD
    271.2  000B40 ....                 DW      link
    271.3  000B42 FF                   DB      0FFh       ; not immediate
    271.4  000B43              link    SET     $
    271.5  000B43 06                   DB      6
    271.6  000B44 464D2F4D4F44         DB      'FM/MOD'
    271.7  000B4A                      EVEN
    271.8  000B4A                      IF      'DOCOLON'='DOCODE'
    271.9  000B4A              FMSLASHMOD: DW     $+2
    271.10 000B4A                      ELSE
    271.11 000B4A ....         FMSLASHMOD: DW      DOCOLON
    271.12 000B4C                      ENDIF
    271.13 000B4C                      ENDM
    272    000B4C ............*        DW DUP,TOR,OVER,OVER,XORR,TOR
    273    000B58 ....                 DW SMSLASHREM
    274    000B5A ............*        DW OVER,RFROM,ZEROLESS,ANDD,qbran
    275    000B64                      DEST  FMMOD1
    275.1  000B64 0C00                 DW      FMMOD1-$
    275.2  000B66                      ENDM
    276    000B66 ............*        DW SWAP,RFETCH,PLUS,SWAP,ONEMINUS
    277    000B70 ............ FMMOD1: DW RFROM,DROP,EXIT
    278    000B76              
    279    000B76              ;C *      n1 n2 -- n3       signed multiply
    280    000B76              ;   M* DROP ;
    281    000B76                  HEADER  STAR,1,'*',DOCOLON
    281.1  000000                      PUBLIC  STAR
    281.2  000B76 ....                 DW      link
    281.3  000B78 FF                   DB      0FFh       ; not immediate
    281.4  000B79              link    SET     $
    281.5  000B79 01                   DB      1
    281.6  000B7A 2A                   DB      '*'
    281.7  000B7B 00                   EVEN
    281.8  000B7C                      IF      'DOCOLON'='DOCODE'
    281.9  000B7C              STAR: DW     $+2
    281.10 000B7C                      ELSE
    281.11 000B7C ....         STAR: DW      DOCOLON
    281.12 000B7E                      ENDIF
    281.13 000B7E                      ENDM
    282    000B7E ............         DW MSTAR,DROP,EXIT
    283    000B84              
    284    000B84              ;C /MOD   n1 n2 -- n3 n4    signed divide/rem'dr
    285    000B84              ;   >R S>D R> FM/MOD ;
    286    000B84                  HEADER  SLASHMOD,4,'/MOD',DOCOLON
    286.1  000000                      PUBLIC  SLASHMOD
    286.2  000B84 ....                 DW      link
    286.3  000B86 FF                   DB      0FFh       ; not immediate
    286.4  000B87              link    SET     $
    286.5  000B87 04                   DB      4
    286.6  000B88 2F4D4F44             DB      '/MOD'
    286.7  000B8C                      EVEN
    286.8  000B8C                      IF      'DOCOLON'='DOCODE'
    286.9  000B8C              SLASHMOD: DW     $+2
    286.10 000B8C                      ELSE
    286.11 000B8C ....         SLASHMOD: DW      DOCOLON
    286.12 000B8E                      ENDIF
    286.13 000B8E                      ENDM
    287    000B8E ............*        DW TOR,STOD,RFROM,FMSLASHMOD,EXIT
    288    000B98              
    289    000B98              ;C /      n1 n2 -- n3       signed divide
    290    000B98              ;   /MOD nip ;
    291    000B98                  HEADER  SLASH,1,'/',DOCOLON
    291.1  000000                      PUBLIC  SLASH
    291.2  000B98 ....                 DW      link
    291.3  000B9A FF                   DB      0FFh       ; not immediate
    291.4  000B9B              link    SET     $
    291.5  000B9B 01                   DB      1
    291.6  000B9C 2F                   DB      '/'
    291.7  000B9D 00                   EVEN
    291.8  000B9E                      IF      'DOCOLON'='DOCODE'
    291.9  000B9E              SLASH: DW     $+2
    291.10 000B9E                      ELSE
    291.11 000B9E ....         SLASH: DW      DOCOLON
    291.12 000BA0                      ENDIF
    291.13 000BA0                      ENDM
    292    000BA0 ............         DW SLASHMOD,NIP,EXIT
    293    000BA6              
    294    000BA6              ;C MOD    n1 n2 -- n3       signed remainder
    295    000BA6              ;   /MOD DROP ;
    296    000BA6                  HEADER  MODD,3,'MOD',DOCOLON
    296.1  000000                      PUBLIC  MODD
    296.2  000BA6 ....                 DW      link
    296.3  000BA8 FF                   DB      0FFh       ; not immediate
    296.4  000BA9              link    SET     $
    296.5  000BA9 03                   DB      3
    296.6  000BAA 4D4F44               DB      'MOD'
    296.7  000BAD 00                   EVEN
    296.8  000BAE                      IF      'DOCOLON'='DOCODE'
    296.9  000BAE              MODD: DW     $+2
    296.10 000BAE                      ELSE
    296.11 000BAE ....         MODD: DW      DOCOLON
    296.12 000BB0                      ENDIF
    296.13 000BB0                      ENDM
    297    000BB0 ............         DW SLASHMOD,DROP,EXIT
    298    000BB6              
    299    000BB6              ;C */MOD  n1 n2 n3 -- n4 n5    n1*n2/n3,
                                rem&quot
    300    000BB6              ;   >R M* R> FM/MOD ;
    301    000BB6                  HEADER  SSMOD,5,'*/MOD',DOCOLON
    301.1  000000                      PUBLIC  SSMOD
    301.2  000BB6 ....                 DW      link
    301.3  000BB8 FF                   DB      0FFh       ; not immediate
    301.4  000BB9              link    SET     $
    301.5  000BB9 05                   DB      5
    301.6  000BBA 2A2F4D4F44           DB      '*/MOD'
    301.7  000BBF 00                   EVEN
    301.8  000BC0                      IF      'DOCOLON'='DOCODE'
    301.9  000BC0              SSMOD: DW     $+2
    301.10 000BC0                      ELSE
    301.11 000BC0 ....         SSMOD: DW      DOCOLON
    301.12 000BC2                      ENDIF
    301.13 000BC2                      ENDM
    302    000BC2 ............*        DW TOR,MSTAR,RFROM,FMSLASHMOD,EXIT
    303    000BCC              
    304    000BCC              ;C */     n1 n2 n3 -- n4        n1*n2/n3
    305    000BCC              ;   */MOD nip ;
    306    000BCC                  HEADER  STARSLASH,2,'*/',DOCOLON
    306.1  000000                      PUBLIC  STARSLASH
    306.2  000BCC ....                 DW      link
    306.3  000BCE FF                   DB      0FFh       ; not immediate
    306.4  000BCF              link    SET     $
    306.5  000BCF 02                   DB      2
    306.6  000BD0 2A2F                 DB      '*/'
    306.7  000BD2                      EVEN
    306.8  000BD2                      IF      'DOCOLON'='DOCODE'
    306.9  000BD2              STARSLASH: DW     $+2
    306.10 000BD2                      ELSE
    306.11 000BD2 ....         STARSLASH: DW      DOCOLON
    306.12 000BD4                      ENDIF
    306.13 000BD4                      ENDM
    307    000BD4 ............         DW SSMOD,NIP,EXIT
    308    000BDA              
    309    000BDA              ;C MAX    n1 n2 -- n3       signed maximum
    310    000BDA              ;   2DUP < IF SWAP THEN DROP ;
    311    000BDA                  HEADER  MAX,3,'MAX',DOCOLON
    311.1  000000                      PUBLIC  MAX
    311.2  000BDA ....                 DW      link
    311.3  000BDC FF                   DB      0FFh       ; not immediate
    311.4  000BDD              link    SET     $
    311.5  000BDD 03                   DB      3
    311.6  000BDE 4D4158               DB      'MAX'
    311.7  000BE1 00                   EVEN
    311.8  000BE2                      IF      'DOCOLON'='DOCODE'
    311.9  000BE2              MAX: DW     $+2
    311.10 000BE2                      ELSE
    311.11 000BE2 ....         MAX: DW      DOCOLON
    311.12 000BE4                      ENDIF
    311.13 000BE4                      ENDM
    312    000BE4 ............         DW TWODUP,LESS,qbran
    313    000BEA                      DEST  MAX1
    313.1  000BEA 0400                 DW      MAX1-$
    313.2  000BEC                      ENDM
    314    000BEC ....                 DW  SWAP
    315    000BEE ........     MAX1:   DW DROP,EXIT
    316    000BF2              
    317    000BF2              ;C MIN    n1 n2 -- n3       signed minimum
    318    000BF2              ;   2DUP > IF SWAP THEN DROP ;
    319    000BF2                  HEADER  MIN,3,'MIN',DOCOLON
    319.1  000000                      PUBLIC  MIN
    319.2  000BF2 ....                 DW      link
    319.3  000BF4 FF                   DB      0FFh       ; not immediate
    319.4  000BF5              link    SET     $
    319.5  000BF5 03                   DB      3
    319.6  000BF6 4D494E               DB      'MIN'
    319.7  000BF9 00                   EVEN
    319.8  000BFA                      IF      'DOCOLON'='DOCODE'
    319.9  000BFA              MIN: DW     $+2
    319.10 000BFA                      ELSE
    319.11 000BFA ....         MIN: DW      DOCOLON
    319.12 000BFC                      ENDIF
    319.13 000BFC                      ENDM
    320    000BFC ............         DW TWODUP,GREATER,qbran
    321    000C02                      DEST  MIN1
    321.1  000C02 0400                 DW      MIN1-$
    321.2  000C04                      ENDM
    322    000C04 ....                 DW SWAP
    323    000C06 ........     MIN1:   DW DROP,EXIT
    324    000C0A              
    325    000C0A              ; DOUBLE OPERATORS =============================
                               =
    326    000C0A              
    327    000C0A              ;C 2@    a-addr -- x1 x2    fetch 2 cells
    328    000C0A              ;   DUP CELL+ @ SWAP @ ;
    329    000C0A              ;   the lower address will appear on top of
                                stack
    330    000C0A                  HEADER  TWOFETCH,2,'2@',DOCOLON
    330.1  000000                      PUBLIC  TWOFETCH
    330.2  000C0A ....                 DW      link
    330.3  000C0C FF                   DB      0FFh       ; not immediate
    330.4  000C0D              link    SET     $
    330.5  000C0D 02                   DB      2
    330.6  000C0E 3240                 DB      '2@'
    330.7  000C10                      EVEN
    330.8  000C10                      IF      'DOCOLON'='DOCODE'
    330.9  000C10              TWOFETCH: DW     $+2
    330.10 000C10                      ELSE
    330.11 000C10 ....         TWOFETCH: DW      DOCOLON
    330.12 000C12                      ENDIF
    330.13 000C12                      ENDM
    331    000C12 ............*        DW DUP,CELLPLUS,FETCH,SWAP,FETCH,EXIT
    332    000C1E              
    333    000C1E              ;C 2!    x1 x2 a-addr --    store 2 cells
    334    000C1E              ;   SWAP OVER ! CELL+ ! ;
    335    000C1E              ;   the top of stack is stored at the lower
                                adrs
    336    000C1E                  HEADER  TWOSTORE,2,'2!',DOCOLON
    336.1  000000                      PUBLIC  TWOSTORE
    336.2  000C1E ....                 DW      link
    336.3  000C20 FF                   DB      0FFh       ; not immediate
    336.4  000C21              link    SET     $
    336.5  000C21 02                   DB      2
    336.6  000C22 3221                 DB      '2!'
    336.7  000C24                      EVEN
    336.8  000C24                      IF      'DOCOLON'='DOCODE'
    336.9  000C24              TWOSTORE: DW     $+2
    336.10 000C24                      ELSE
    336.11 000C24 ....         TWOSTORE: DW      DOCOLON
    336.12 000C26                      ENDIF
    336.13 000C26                      ENDM
    337    000C26 ............*        DW SWAP,OVER,STORE,CELLPLUS,STORE,EXIT
    338    000C32              
    339    000C32              ;C 2DROP  x1 x2 --          drop 2 cells
    340    000C32              ;   DROP DROP ;
    341    000C32                  HEADER  TWODROP,5,'2DROP',DOCOLON
    341.1  000000                      PUBLIC  TWODROP
    341.2  000C32 ....                 DW      link
    341.3  000C34 FF                   DB      0FFh       ; not immediate
    341.4  000C35              link    SET     $
    341.5  000C35 05                   DB      5
    341.6  000C36 3244524F50           DB      '2DROP'
    341.7  000C3B 00                   EVEN
    341.8  000C3C                      IF      'DOCOLON'='DOCODE'
    341.9  000C3C              TWODROP: DW     $+2
    341.10 000C3C                      ELSE
    341.11 000C3C ....         TWODROP: DW      DOCOLON
    341.12 000C3E                      ENDIF
    341.13 000C3E                      ENDM
    342    000C3E ............         DW DROP,DROP,EXIT
    343    000C44              
    344    000C44              ;C 2DUP   x1 x2 -- x1 x2 x1 x2   dup top 2
                                cells
    345    000C44              ;   OVER OVER ;
    346    000C44                  HEADER  TWODUP,4,'2DUP',DOCOLON
    346.1  000000                      PUBLIC  TWODUP
    346.2  000C44 ....                 DW      link
    346.3  000C46 FF                   DB      0FFh       ; not immediate
    346.4  000C47              link    SET     $
    346.5  000C47 04                   DB      4
    346.6  000C48 32445550             DB      '2DUP'
    346.7  000C4C                      EVEN
    346.8  000C4C                      IF      'DOCOLON'='DOCODE'
    346.9  000C4C              TWODUP: DW     $+2
    346.10 000C4C                      ELSE
    346.11 000C4C ....         TWODUP: DW      DOCOLON
    346.12 000C4E                      ENDIF
    346.13 000C4E                      ENDM
    347    000C4E ............         DW OVER,OVER,EXIT
    348    000C54              
    349    000C54              ;C 2SWAP  x1 x2 x3 x4 -- x3 x4 x1 x2  per
                                diagram
    350    000C54              ;   ROT >R ROT R> ;
    351    000C54                  HEADER  TWOSWAP,5,'2SWAP',DOCOLON
    351.1  000000                      PUBLIC  TWOSWAP
    351.2  000C54 ....                 DW      link
    351.3  000C56 FF                   DB      0FFh       ; not immediate
    351.4  000C57              link    SET     $
    351.5  000C57 05                   DB      5
    351.6  000C58 3253574150           DB      '2SWAP'
    351.7  000C5D 00                   EVEN
    351.8  000C5E                      IF      'DOCOLON'='DOCODE'
    351.9  000C5E              TWOSWAP: DW     $+2
    351.10 000C5E                      ELSE
    351.11 000C5E ....         TWOSWAP: DW      DOCOLON
    351.12 000C60                      ENDIF
    351.13 000C60                      ENDM
    352    000C60 ............*        DW ROT,TOR,ROT,RFROM,EXIT
    353    000C6A              
    354    000C6A              ;C 2OVER  x1 x2 x3 x4 -- x1 x2 x3 x4 x1
                                x2
    355    000C6A              ;   >R >R 2DUP R> R> 2SWAP ;
    356    000C6A                  HEADER  TWOOVER,5,'2OVER',DOCOLON
    356.1  000000                      PUBLIC  TWOOVER
    356.2  000C6A ....                 DW      link
    356.3  000C6C FF                   DB      0FFh       ; not immediate
    356.4  000C6D              link    SET     $
    356.5  000C6D 05                   DB      5
    356.6  000C6E 324F564552           DB      '2OVER'
    356.7  000C73 00                   EVEN
    356.8  000C74                      IF      'DOCOLON'='DOCODE'
    356.9  000C74              TWOOVER: DW     $+2
    356.10 000C74                      ELSE
    356.11 000C74 ....         TWOOVER: DW      DOCOLON
    356.12 000C76                      ENDIF
    356.13 000C76                      ENDM
    357    000C76 ............*        DW TOR,TOR,TWODUP,RFROM,RFROM
    358    000C80 ........             DW TWOSWAP,EXIT
    359    000C84              
    360    000C84              ; INPUT/OUTPUT =================================
                               =
    361    000C84              
    362    000C84              ;C COUNT   c-addr1 -- c-addr2 u  counted->adr/le
                               n
    363    000C84              ;   DUP CHAR+ SWAP C@ ;
    364    000C84                  HEADER  COUNT,5,'COUNT',DOCOLON
    364.1  000000                      PUBLIC  COUNT
    364.2  000C84 ....                 DW      link
    364.3  000C86 FF                   DB      0FFh       ; not immediate
    364.4  000C87              link    SET     $
    364.5  000C87 05                   DB      5
    364.6  000C88 434F554E54           DB      'COUNT'
    364.7  000C8D 00                   EVEN
    364.8  000C8E                      IF      'DOCOLON'='DOCODE'
    364.9  000C8E              COUNT: DW     $+2
    364.10 000C8E                      ELSE
    364.11 000C8E ....         COUNT: DW      DOCOLON
    364.12 000C90                      ENDIF
    364.13 000C90                      ENDM
    365    000C90 ............*        DW DUP,CHARPLUS,SWAP,CFETCH,EXIT
    366    000C9A              
    367    000C9A              ;C CR      --               output newline
    368    000C9A              ;   0D EMIT 0A EMIT ;
    369    000C9A                  HEADER  CR,2,'CR',DOCOLON
    369.1  000000                      PUBLIC  CR
    369.2  000C9A ....                 DW      link
    369.3  000C9C FF                   DB      0FFh       ; not immediate
    369.4  000C9D              link    SET     $
    369.5  000C9D 02                   DB      2
    369.6  000C9E 4352                 DB      'CR'
    369.7  000CA0                      EVEN
    369.8  000CA0                      IF      'DOCOLON'='DOCODE'
    369.9  000CA0              CR: DW     $+2
    369.10 000CA0                      ELSE
    369.11 000CA0 ....         CR: DW      DOCOLON
    369.12 000CA2                      ENDIF
    369.13 000CA2                      ENDM
    370    000CA2 ....0D00....*        DW lit,0dh,EMIT,lit,0ah,EMIT,EXIT
    371    000CB0              
    372    000CB0              ;C SPACE   --               output a space
    373    000CB0              ;   BL EMIT ;
    374    000CB0                  HEADER  SPACE,5,'SPACE',DOCOLON
    374.1  000000                      PUBLIC  SPACE
    374.2  000CB0 ....                 DW      link
    374.3  000CB2 FF                   DB      0FFh       ; not immediate
    374.4  000CB3              link    SET     $
    374.5  000CB3 05                   DB      5
    374.6  000CB4 5350414345           DB      'SPACE'
    374.7  000CB9 00                   EVEN
    374.8  000CBA                      IF      'DOCOLON'='DOCODE'
    374.9  000CBA              SPACE: DW     $+2
    374.10 000CBA                      ELSE
    374.11 000CBA ....         SPACE: DW      DOCOLON
    374.12 000CBC                      ENDIF
    374.13 000CBC                      ENDM
    375    000CBC ............         DW BLANK,EMIT,EXIT
    376    000CC2              
    377    000CC2              ;C SPACES   n --            output n spaces
    378    000CC2              ;   BEGIN DUP WHILE SPACE 1- REPEAT DROP
                                ;
    379    000CC2                  HEADER  SPACES,6,'SPACES',DOCOLON
    379.1  000000                      PUBLIC  SPACES
    379.2  000CC2 ....                 DW      link
    379.3  000CC4 FF                   DB      0FFh       ; not immediate
    379.4  000CC5              link    SET     $
    379.5  000CC5 06                   DB      6
    379.6  000CC6 535041434553         DB      'SPACES'
    379.7  000CCC                      EVEN
    379.8  000CCC                      IF      'DOCOLON'='DOCODE'
    379.9  000CCC              SPACES: DW     $+2
    379.10 000CCC                      ELSE
    379.11 000CCC ....         SPACES: DW      DOCOLON
    379.12 000CCE                      ENDIF
    379.13 000CCE                      ENDM
    380    000CCE ........     SPCS1:  DW DUP,qbran
    381    000CD2                      DEST  SPCS2
    381.1  000CD2 0A00                 DW      SPCS2-$
    381.2  000CD4                      ENDM
    382    000CD4 ............         DW SPACE,ONEMINUS,bran
    383    000CDA                      DEST  SPCS1
    383.1  000CDA F4FF                 DW      SPCS1-$
    383.2  000CDC                      ENDM
    384    000CDC ........     SPCS2:  DW DROP,EXIT
    385    000CE0              
    386    000CE0              ;Z umin     u1 u2 -- u      unsigned minimum
    387    000CE0              ;   2DUP U> IF SWAP THEN DROP ;
    388    000CE0                  HEADER  UMIN,4,'UMIN',DOCOLON
    388.1  000000                      PUBLIC  UMIN
    388.2  000CE0 ....                 DW      link
    388.3  000CE2 FF                   DB      0FFh       ; not immediate
    388.4  000CE3              link    SET     $
    388.5  000CE3 04                   DB      4
    388.6  000CE4 554D494E             DB      'UMIN'
    388.7  000CE8                      EVEN
    388.8  000CE8                      IF      'DOCOLON'='DOCODE'
    388.9  000CE8              UMIN: DW     $+2
    388.10 000CE8                      ELSE
    388.11 000CE8 ....         UMIN: DW      DOCOLON
    388.12 000CEA                      ENDIF
    388.13 000CEA                      ENDM
    389    000CEA ............         DW TWODUP,UGREATER,qbran
    390    000CF0                      DEST  UMIN1
    390.1  000CF0 0400                 DW      UMIN1-$
    390.2  000CF2                      ENDM
    391    000CF2 ....                 DW SWAP
    392    000CF4 ........     UMIN1:  DW DROP,EXIT
    393    000CF8              
    394    000CF8              ;Z umax    u1 u2 -- u       unsigned maximum
    395    000CF8              ;   2DUP U< IF SWAP THEN DROP ;
    396    000CF8                  HEADER  UMAX,4,'UMAX',DOCOLON
    396.1  000000                      PUBLIC  UMAX
    396.2  000CF8 ....                 DW      link
    396.3  000CFA FF                   DB      0FFh       ; not immediate
    396.4  000CFB              link    SET     $
    396.5  000CFB 04                   DB      4
    396.6  000CFC 554D4158             DB      'UMAX'
    396.7  000D00                      EVEN
    396.8  000D00                      IF      'DOCOLON'='DOCODE'
    396.9  000D00              UMAX: DW     $+2
    396.10 000D00                      ELSE
    396.11 000D00 ....         UMAX: DW      DOCOLON
    396.12 000D02                      ENDIF
    396.13 000D02                      ENDM
    397    000D02 ............         DW TWODUP,ULESS,qbran
    398    000D08                      DEST  UMAX1
    398.1  000D08 0400                 DW      UMAX1-$
    398.2  000D0A                      ENDM
    399    000D0A ....                 DW SWAP
    400    000D0C ........     UMAX1:  DW DROP,EXIT
    401    000D10              
    402    000D10              ;C ACCEPT  c-addr +n -- +n'  get line from
                                term'l
    403    000D10              ;   OVER + 1- OVER      -- sa ea a
    404    000D10              ;   BEGIN KEY           -- sa ea a c
    405    000D10              ;   DUP 0D <> WHILE
    406    000D10              ;       DUP EMIT        -- sa ea a c
    407    000D10              ;       DUP 8 = IF  DROP 1-    >R OVER R>
                                UMAX
    408    000D10              ;             ELSE  OVER C! 1+ OVER UMIN
    409    000D10              ;       THEN            -- sa ea a
    410    000D10              ;   REPEAT              -- sa ea a c
    411    000D10              ;   DROP NIP SWAP - ;
    412    000D10                  HEADER  ACCEPT,6,'ACCEPT',DOCOLON
    412.1  000000                      PUBLIC  ACCEPT
    412.2  000D10 ....                 DW      link
    412.3  000D12 FF                   DB      0FFh       ; not immediate
    412.4  000D13              link    SET     $
    412.5  000D13 06                   DB      6
    412.6  000D14 414343455054         DB      'ACCEPT'
    412.7  000D1A                      EVEN
    412.8  000D1A                      IF      'DOCOLON'='DOCODE'
    412.9  000D1A              ACCEPT: DW     $+2
    412.10 000D1A                      ELSE
    412.11 000D1A ....         ACCEPT: DW      DOCOLON
    412.12 000D1C                      ENDIF
    412.13 000D1C                      ENDM
    413    000D1C ............*        DW OVER,PLUS,ONEMINUS,OVER
    414    000D24              ACC1: ;  DW KEY,DUP,lit,0DH,NOTEQUAL,qbran
    415    000D24 ....                 DW KEY
    416    000D26 ........0D00*        DW DUP,lit,0DH,NOTEQUAL ; ( -- c f )
                                                                CR
    417    000D2E              ;        DW OVER,lit,0AH,NOTEQUAL ; ( -- c f f )
                                LF
    418    000D2E              ;        DW ANDD
    419    000D2E ....                 DW qbran
    420    000D30                      DEST  ACC5
    420.1  000D30 3800                 DW      ACC5-$
    420.2  000D32                      ENDM
    421    000D32 ........             DW DUP,EMIT
    422    000D36              ;        DW DUP,STORELEDS ; testing
    423    000D36 ........0800*        DW DUP,lit,8,EQUAL,qbran  ;mk BS
                                                                  received?
    424    000D40                      DEST  ACC3
    424.1  000D40 1A00                 DW      ACC3-$
    424.2  000D42                      ENDM
    425    000D42 ............*        DW DROP,ONEMINUS,TOR,OVER,RFROM,UMAX ;mk
                                            backspace handling
    426    000D4E ........0800*        DW SPACE,lit,8,EMIT ;mk $08 == BS (for
                                                            tera term and
                                                            hyterterminal)
    427    000D56 ....                 DW bran
    428    000D58                      DEST  ACC4
    428.1  000D58 0C00                 DW      ACC4-$
    428.2  000D5A                      ENDM
    429    000D5A ............*ACC3:   DW OVER,CSTORE,ONEPLUS,OVER,UMIN
    430    000D64 ....         ACC4:   DW bran
    431    000D66                      DEST  ACC1
    431.1  000D66 BEFF                 DW      ACC1-$
    431.2  000D68                      ENDM
    432    000D68 ............*ACC5:   DW DROP,NIP,SWAP,MINUS,EXIT
    433    000D72              
    434    000D72              ;C TYPE    c-addr +n --     type line to
                                term'l
    435    000D72              ;   ?DUP IF
    436    000D72              ;     OVER + SWAP DO I C@ EMIT LOOP
    437    000D72              ;   ELSE DROP THEN ;
    438    000D72                  HEADER  TYP,4,'TYPE',DOCOLON
    438.1  000000                      PUBLIC  TYP
    438.2  000D72 ....                 DW      link
    438.3  000D74 FF                   DB      0FFh       ; not immediate
    438.4  000D75              link    SET     $
    438.5  000D75 04                   DB      4
    438.6  000D76 54595045             DB      'TYPE'
    438.7  000D7A                      EVEN
    438.8  000D7A                      IF      'DOCOLON'='DOCODE'
    438.9  000D7A              TYP: DW     $+2
    438.10 000D7A                      ELSE
    438.11 000D7A ....         TYP: DW      DOCOLON
    438.12 000D7C                      ENDIF
    438.13 000D7C                      ENDM
    439    000D7C ........             DW QDUP,qbran
    440    000D80                      DEST  TYP4
    440.1  000D80 1800                 DW      TYP4-$
    440.2  000D82                      ENDM
    441    000D82 ............*        DW OVER,PLUS,SWAP,xdo
    442    000D8A ............*TYP3:   DW II,CFETCH,EMIT,xloop
    443    000D92                      DEST  TYP3
    443.1  000D92 F8FF                 DW      TYP3-$
    443.2  000D94                      ENDM
    444    000D94 ....                 DW bran
    445    000D96                      DEST  TYP5
    445.1  000D96 0400                 DW      TYP5-$
    445.2  000D98                      ENDM
    446    000D98 ....         TYP4:   DW DROP
    447    000D9A ....         TYP5:   DW EXIT
    448    000D9C              
    449    000D9C              #define ITYPE TYP
    450    000D9C              #define ICOUNT COUNT
    451    000D9C              
    452    000D9C              ; HARVARD MODEL EXTENSIONS (split Code &
                                Data)
    453    000D9C              
    454    000D9C              /*
    455    000D9C              ;Z ICOUNT  c-addr1 -- c-addr2 u  counted->adr/le
                               n
    456    000D9C              ;   DUP CHAR+ SWAP IC@ ;          from Code
                                space
    457    000D9C                  HEADER  ICOUNT,6,'ICOUNT',DOCOLON
    458    000D9C                      DW DUP,CHARPLUS,SWAP,ICFETCH,EXIT
    459    000D9C              
    460    000D9C              ;Z ITYPE   c-addr +n --       type line to
                                term'l
    461    000D9C              ;   ?DUP IF                       from Code
                                space
    462    000D9C              ;     OVER + SWAP DO I IC@ EMIT LOOP
    463    000D9C              ;   ELSE DROP THEN ;
    464    000D9C                  HEADER  ITYPE,5,'ITYPE',DOCOLON
    465    000D9C                      DW QDUP,qbran
    466    000D9C                      DEST  ITYP4
    467    000D9C                      DW OVER,PLUS,SWAP,xdo
    468    000D9C              ITYP3:  DW II,ICFETCH,EMIT,xloop
    469    000D9C                      DEST  ITYP3
    470    000D9C                      DW bran
    471    000D9C                      DEST  ITYP5
    472    000D9C              ITYP4:  DW DROP
    473    000D9C              ITYP5:  DW EXIT
    474    000D9C              */
    475    000D9C              
    476    000D9C              
    477    000D9C              ;Z (IS")     -- c-addr u   run-time code for
                                S"
    478    000D9C              ;   R> ICOUNT 2DUP + ALIGNED >R  ;
    479    000D9C              ; Harvard model, for string stored in Code
                                space
    480    000D9C              ; e.g. as used by ."
    481    000D9C                  HEADER  XISQUOTE,5,'(IS")',DOCOLON
    481.1  000000                      PUBLIC  XISQUOTE
    481.2  000D9C ....                 DW      link
    481.3  000D9E FF                   DB      0FFh       ; not immediate
    481.4  000D9F              link    SET     $
    481.5  000D9F 05                   DB      5
    481.6  000DA0 2849532229           DB      '(IS")'
    481.7  000DA5 00                   EVEN
    481.8  000DA6                      IF      'DOCOLON'='DOCODE'
    481.9  000DA6              XISQUOTE: DW     $+2
    481.10 000DA6                      ELSE
    481.11 000DA6 ....         XISQUOTE: DW      DOCOLON
    481.12 000DA8                      ENDIF
    481.13 000DA8                      ENDM
    482    000DA8 ............*        DW RFROM,ICOUNT,TWODUP,PLUS,ALIGNED,TOR
    483    000DB4 ....                 DW EXIT
    484    000DB6              
    485    000DB6              ;Z (S")     -- c-addr u   run-time code for
                                S"
    486    000DB6              ;   R@ I@                     get Data
                                address
    487    000DB6              ;   R> CELL+ DUP IC@ CHAR+    -- Dadr Radr+2
                                n+1
    488    000DB6              ;   2DUP + ALIGNED >R         -- Dadr Iadr
                                n+1
    489    000DB6              ;   >R OVER R> I->D           -- Dadr
    490    000DB6              ;   COUNT ;
    491    000DB6              ; Harvard model, for string stored in Code
                                space
    492    000DB6              ; which is copied to Data space.
    493    000DB6                  HEADER  XSQUOTE,4,'(S")',DOCOLON
    493.1  000000                      PUBLIC  XSQUOTE
    493.2  000DB6 ....                 DW      link
    493.3  000DB8 FF                   DB      0FFh       ; not immediate
    493.4  000DB9              link    SET     $
    493.5  000DB9 04                   DB      4
    493.6  000DBA 28532229             DB      '(S")'
    493.7  000DBE                      EVEN
    493.8  000DBE                      IF      'DOCOLON'='DOCODE'
    493.9  000DBE              XSQUOTE: DW     $+2
    493.10 000DBE                      ELSE
    493.11 000DBE ....         XSQUOTE: DW      DOCOLON
    493.12 000DC0                      ENDIF
    493.13 000DC0                      ENDM
    494    000DC0 ........             DW RFETCH,IFETCH
    495    000DC4 ............*        DW RFROM,CELLPLUS,DUP,ICFETCH,CHARPLUS
    496    000DCE ............*        DW TWODUP,PLUS,ALIGNED,TOR
    497    000DD6 ............*        DW TOR,OVER,RFROM,ITOD,COUNT,EXIT
    498    000DE2              
    499    000DE2              ;C IS"      -- adr n         compile in-line
                                string
    500    000DE2              ;   COMPILE (IS")  [ HEX ]
    501    000DE2              ;   22 IWORD
    502    000DE2              ;   IC@ 1+ ALIGNED IALLOT ; IMMEDIATE
    503    000DE2              ; Harvard model: string is stored in Code
                                space
    504    000DE2                  IMMED  ISQUOTE,3,'IS"',DOCOLON
    504.1  000000                      PUBLIC  ISQUOTE
    504.2  000DE2 ....                 DW      link
    504.3  000DE4 FE                   DB      0FEh      // ; immediate
                                                                   (LSB=0)
    504.4  000DE5              link    SET     $
    504.5  000DE5 03                   DB      3
    504.6  000DE6 495322               DB      'IS"'
    504.7  000DE9 00                   EVEN
    504.8  000DEA                      IF      'DOCOLON'='DOCODE'
    504.9  000DEA              ISQUOTE: DW     $+2
    504.10 000DEA                      ELSE
    504.11 000DEA ....         ISQUOTE: DW      DOCOLON
    504.12 000DEC                      ENDIF
    504.13 000DEC                      ENDM
    505    000DEC ............         DW lit,XISQUOTE,COMMAXT
    506    000DF2 ....2200....         DW lit,22H,IWORD
    507    000DF8 ............*        DW ICFETCH,ONEPLUS,ALIGNED,IALLOT,EXIT
    508    000E02              
    509    000E02              /*
    510    000E02              ; S"       --             compile in-line
                                string
    511    000E02              ;   COMPILE (S")  [ HEX ]
    512    000E02              ;   HERE I,                     data address
    513    000E02              ;   22 IWORD
    514    000E02              ;   IC@ 1+ ALIGNED
    515    000E02              ;   DUP ALLOT IALLOT ; IMMEDIATE
    516    000E02              ; Harvard model: string is stored in Code
                                space
    517    000E02                  IMMED  SQUOTE,2,'S"',DOCOLON
    518    000E02                      DW lit,XSQUOTE,COMMAXT
    519    000E02                      DW HERE,ICOMMA,lit,22H,IWORD
    520    000E02                      DW ICFETCH,ONEPLUS,ALIGNED
    521    000E02                      DW DUP,ALLOT,IALLOT,EXIT
    522    000E02              */
    523    000E02              
    524    000E02              
    525    000E02              ;C ."       --         compile string to
                                print
    526    000E02              ;   POSTPONE IS"  POSTPONE ITYPE ; IMMEDIATE
    527    000E02                  IMMED  DOTQUOTE,2,'."',DOCOLON
    527.1  000000                      PUBLIC  DOTQUOTE
    527.2  000E02 ....                 DW      link
    527.3  000E04 FE                   DB      0FEh      // ; immediate
                                                                   (LSB=0)
    527.4  000E05              link    SET     $
    527.5  000E05 02                   DB      2
    527.6  000E06 2E22                 DB      '."'
    527.7  000E08                      EVEN
    527.8  000E08                      IF      'DOCOLON'='DOCODE'
    527.9  000E08              DOTQUOTE: DW     $+2
    527.10 000E08                      ELSE
    527.11 000E08 ....         DOTQUOTE: DW      DOCOLON
    527.12 000E0A                      ENDIF
    527.13 000E0A                      ENDM
    528    000E0A ....                 DW ISQUOTE
    529    000E0C ............         DW lit,ITYPE,COMMAXT
    530    000E12 ....                 DW EXIT
    531    000E14              
    532    000E14              ;Z IWORD     c -- c-addr       WORD to Code
                                space
    533    000E14              ;   WORD
    534    000E14              ;   IHERE TUCK OVER C@ CHAR+ D->I ;
    535    000E14                  HEADER  IWORD,5,'IWORD',DOCOLON
    535.1  000000                      PUBLIC  IWORD
    535.2  000E14 ....                 DW      link
    535.3  000E16 FF                   DB      0FFh       ; not immediate
    535.4  000E17              link    SET     $
    535.5  000E17 05                   DB      5
    535.6  000E18 49574F5244           DB      'IWORD'
    535.7  000E1D 00                   EVEN
    535.8  000E1E                      IF      'DOCOLON'='DOCODE'
    535.9  000E1E              IWORD: DW     $+2
    535.10 000E1E                      ELSE
    535.11 000E1E ....         IWORD: DW      DOCOLON
    535.12 000E20                      ENDIF
    535.13 000E20                      ENDM
    536    000E20 ....                 DW WORDD
    537    000E22 ............*IWORD1: DW IHERE,TUCK,OVER,CFETCH
    538    000E2A ............         DW CHARPLUS,DTOI,EXIT
    539    000E30              
    540    000E30              ;Z IWORDC     c -- c-addr       maybe capitalize
                                WORD to Code space
    541    000E30              ;   WORD CAPITALIZE
    542    000E30              ;   IHERE TUCK OVER C@ CHAR+ D->I ;
    543    000E30              ;    HEADER  IWORDC,6,'IWORDC',DOCOLON
    544    000E30                   HEADLESS IWORDC, DOCOLON
    544.1  000000                      PUBLIC  IWORDC
    544.2  000E30                      IF      'DOCOLON'='DOCODE'
    544.3  000E30              IWORDC: DW     $+2
    544.4  000E30                      ELSE
    544.5  000E30 ....         IWORDC: DW      DOCOLON
    544.6  000E32                      ENDIF
    544.7  000E32                      ENDM
    545    000E32 ........             DW WORDD, CAPITALIZE
    546    000E36 ....                 DW bran
    547    000E38                      DEST IWORD1
    547.1  000E38 EAFF                 DW      IWORD1-$
    547.2  000E3A                      ENDM
    548    000E3A              
    549    000E3A              ; SEPARATE HEADER EXTENSIONS ARE NOT USED
    550    000E3A              #define HCOUNT ICOUNT
    551    000E3A              #define HTYPE  ITYPE
    552    000E3A              #define HWORD  IWORDC
    553    000E3A              
    554    000E3A              ; NUMERIC OUTPUT ===============================
                               =
    555    000E3A              ; Numeric conversion is done l.s.digit first,
                                so
    556    000E3A              ; the output buffer is built backwards in
                                memory.
    557    000E3A              
    558    000E3A              ; Some double-precision arithmetic operators
                                are
    559    000E3A              ; needed to implement ANSI numeric conversion.
    560    000E3A              
    561    000E3A              ;Z UD/MOD   ud1 u2 -- u3 ud4   32/16->32
                                divide
    562    000E3A              ;   >R 0 R@ UM/MOD  ROT ROT R> UM/MOD ROT
                                ;
    563    000E3A                  HEADER  UDSLASHMOD,6,'UD/MOD',DOCOLON
    563.1  000000                      PUBLIC  UDSLASHMOD
    563.2  000E3A ....                 DW      link
    563.3  000E3C FF                   DB      0FFh       ; not immediate
    563.4  000E3D              link    SET     $
    563.5  000E3D 06                   DB      6
    563.6  000E3E 55442F4D4F44         DB      'UD/MOD'
    563.7  000E44                      EVEN
    563.8  000E44                      IF      'DOCOLON'='DOCODE'
    563.9  000E44              UDSLASHMOD: DW     $+2
    563.10 000E44                      ELSE
    563.11 000E44 ....         UDSLASHMOD: DW      DOCOLON
    563.12 000E46                      ENDIF
    563.13 000E46                      ENDM
    564    000E46 ............*        DW TOR,ZERO,RFETCH,UMSLASHMOD,ROT,ROT
    565    000E52 ............*        DW RFROM,UMSLASHMOD,ROT,EXIT
    566    000E5A              
    567    000E5A              ;Z UD*      ud1 d2 -- ud3      32*16->32
                                multiply
    568    000E5A              ;   DUP >R UM* DROP  SWAP R> UM* ROT +
                                ;
    569    000E5A                  HEADER  UDSTAR,3,'UD*',DOCOLON
    569.1  000000                      PUBLIC  UDSTAR
    569.2  000E5A ....                 DW      link
    569.3  000E5C FF                   DB      0FFh       ; not immediate
    569.4  000E5D              link    SET     $
    569.5  000E5D 03                   DB      3
    569.6  000E5E 55442A               DB      'UD*'
    569.7  000E61 00                   EVEN
    569.8  000E62                      IF      'DOCOLON'='DOCODE'
    569.9  000E62              UDSTAR: DW     $+2
    569.10 000E62                      ELSE
    569.11 000E62 ....         UDSTAR: DW      DOCOLON
    569.12 000E64                      ENDIF
    569.13 000E64                      ENDM
    570    000E64 ............*        DW DUP,TOR,UMSTAR,DROP
    571    000E6C ............*        DW SWAP,RFROM,UMSTAR,ROT,PLUS,EXIT
    572    000E78              
    573    000E78              ;C HOLD  char --        add char to output
                                string
    574    000E78              ;   -1 HP +!  HP @ C! ;
    575    000E78                  HEADER  HOLD,4,'HOLD',DOCOLON
    575.1  000000                      PUBLIC  HOLD
    575.2  000E78 ....                 DW      link
    575.3  000E7A FF                   DB      0FFh       ; not immediate
    575.4  000E7B              link    SET     $
    575.5  000E7B 04                   DB      4
    575.6  000E7C 484F4C44             DB      'HOLD'
    575.7  000E80                      EVEN
    575.8  000E80                      IF      'DOCOLON'='DOCODE'
    575.9  000E80              HOLD: DW     $+2
    575.10 000E80                      ELSE
    575.11 000E80 ....         HOLD: DW      DOCOLON
    575.12 000E82                      ENDIF
    575.13 000E82                      ENDM
    576    000E82 ....FFFF....*        DW lit,-1,HP,PLUSSTORE
    577    000E8A ............*        DW HP,FETCH,CSTORE,EXIT
    578    000E92              
    579    000E92              ;C <#    --             begin numeric conversion
    580    000E92              ;   PAD HP ! ;          (initialize Hold
                                Pointer)
    581    000E92                  HEADER  LESSNUM,2,'<#',DOCOLON
    581.1  000000                      PUBLIC  LESSNUM
    581.2  000E92 ....                 DW      link
    581.3  000E94 FF                   DB      0FFh       ; not immediate
    581.4  000E95              link    SET     $
    581.5  000E95 02                   DB      2
    581.6  000E96 3C23                 DB      '<#'
    581.7  000E98                      EVEN
    581.8  000E98                      IF      'DOCOLON'='DOCODE'
    581.9  000E98              LESSNUM: DW     $+2
    581.10 000E98                      ELSE
    581.11 000E98 ....         LESSNUM: DW      DOCOLON
    581.12 000E9A                      ENDIF
    581.13 000E9A                      ENDM
    582    000E9A ............*        DW PAD,HP,STORE,EXIT
    583    000EA2              
    584    000EA2              ;Z >digit   n -- c      convert to 0..9A..Z
    585    000EA2              ;   [ HEX ] DUP 9 > 7 AND + 30 + ;
    586    000EA2                  HEADER  TODIGIT,6,'>DIGIT',DOCOLON
    586.1  000000                      PUBLIC  TODIGIT
    586.2  000EA2 ....                 DW      link
    586.3  000EA4 FF                   DB      0FFh       ; not immediate
    586.4  000EA5              link    SET     $
    586.5  000EA5 06                   DB      6
    586.6  000EA6 3E4449474954         DB      '>DIGIT'
    586.7  000EAC                      EVEN
    586.8  000EAC                      IF      'DOCOLON'='DOCODE'
    586.9  000EAC              TODIGIT: DW     $+2
    586.10 000EAC                      ELSE
    586.11 000EAC ....         TODIGIT: DW      DOCOLON
    586.12 000EAE                      ENDIF
    586.13 000EAE                      ENDM
    587    000EAE ........0900*        DW DUP,lit,9,GREATER,lit,7,ANDD,PLUS
    588    000EBE ....3000....*        DW lit,30H,PLUS,EXIT
    589    000EC6              
    590    000EC6              ;C #     ud1 -- ud2     convert 1 digit of
                                output
    591    000EC6              ;   BASE @ UD/MOD ROT >digit HOLD ;
    592    000EC6                  HEADER  NUM,1,'#',DOCOLON
    592.1  000000                      PUBLIC  NUM
    592.2  000EC6 ....                 DW      link
    592.3  000EC8 FF                   DB      0FFh       ; not immediate
    592.4  000EC9              link    SET     $
    592.5  000EC9 01                   DB      1
    592.6  000ECA 23                   DB      '#'
    592.7  000ECB 00                   EVEN
    592.8  000ECC                      IF      'DOCOLON'='DOCODE'
    592.9  000ECC              NUM: DW     $+2
    592.10 000ECC                      ELSE
    592.11 000ECC ....         NUM: DW      DOCOLON
    592.12 000ECE                      ENDIF
    592.13 000ECE                      ENDM
    593    000ECE ............*        DW BASE,FETCH,UDSLASHMOD,ROT,TODIGIT
    594    000ED8 ........             DW HOLD,EXIT
    595    000EDC              
    596    000EDC              ;C #S    ud1 -- ud2     convert remaining
                                digits
    597    000EDC              ;   BEGIN # 2DUP OR 0= UNTIL ;
    598    000EDC                  HEADER  NUMS,2,'#S',DOCOLON
    598.1  000000                      PUBLIC  NUMS
    598.2  000EDC ....                 DW      link
    598.3  000EDE FF                   DB      0FFh       ; not immediate
    598.4  000EDF              link    SET     $
    598.5  000EDF 02                   DB      2
    598.6  000EE0 2353                 DB      '#S'
    598.7  000EE2                      EVEN
    598.8  000EE2                      IF      'DOCOLON'='DOCODE'
    598.9  000EE2              NUMS: DW     $+2
    598.10 000EE2                      ELSE
    598.11 000EE2 ....         NUMS: DW      DOCOLON
    598.12 000EE4                      ENDIF
    598.13 000EE4                      ENDM
    599    000EE4 ............*NUMS1:  DW NUM,TWODUP,ORR,ZEROEQUAL,qbran
    600    000EEE                      DEST  NUMS1
    600.1  000EEE F6FF                 DW      NUMS1-$
    600.2  000EF0                      ENDM
    601    000EF0 ....                 DW EXIT
    602    000EF2              
    603    000EF2              ;C #>    ud1 -- c-addr u    end conv., get
                                string
    604    000EF2              ;   2DROP HP @ PAD OVER - ;
    605    000EF2                  HEADER  NUMGREATER,2,'#>',DOCOLON
    605.1  000000                      PUBLIC  NUMGREATER
    605.2  000EF2 ....                 DW      link
    605.3  000EF4 FF                   DB      0FFh       ; not immediate
    605.4  000EF5              link    SET     $
    605.5  000EF5 02                   DB      2
    605.6  000EF6 233E                 DB      '#>'
    605.7  000EF8                      EVEN
    605.8  000EF8                      IF      'DOCOLON'='DOCODE'
    605.9  000EF8              NUMGREATER: DW     $+2
    605.10 000EF8                      ELSE
    605.11 000EF8 ....         NUMGREATER: DW      DOCOLON
    605.12 000EFA                      ENDIF
    605.13 000EFA                      ENDM
    606    000EFA ............*        DW TWODROP,HP,FETCH,PAD,OVER,MINUS,EXIT
    607    000F08              
    608    000F08              ;C SIGN  n --           add minus sign if
                                n<0
    609    000F08              ;   0< IF 2D HOLD THEN ;
    610    000F08                  HEADER  SIGN,4,'SIGN',DOCOLON
    610.1  000000                      PUBLIC  SIGN
    610.2  000F08 ....                 DW      link
    610.3  000F0A FF                   DB      0FFh       ; not immediate
    610.4  000F0B              link    SET     $
    610.5  000F0B 04                   DB      4
    610.6  000F0C 5349474E             DB      'SIGN'
    610.7  000F10                      EVEN
    610.8  000F10                      IF      'DOCOLON'='DOCODE'
    610.9  000F10              SIGN: DW     $+2
    610.10 000F10                      ELSE
    610.11 000F10 ....         SIGN: DW      DOCOLON
    610.12 000F12                      ENDIF
    610.13 000F12                      ENDM
    611    000F12 ........             DW ZEROLESS,qbran
    612    000F16                      DEST  SIGN1
    612.1  000F16 0800                 DW      SIGN1-$
    612.2  000F18                      ENDM
    613    000F18 ....2D00....         DW lit,2DH,HOLD
    614    000F1E ....         SIGN1:  DW EXIT
    615    000F20              
    616    000F20              ;C U.    u --           display u unsigned
    617    000F20              ;   <# 0 #S #> TYPE SPACE ;
    618    000F20                  HEADER  UDOT,2,'U.',DOCOLON
    618.1  000000                      PUBLIC  UDOT
    618.2  000F20 ....                 DW      link
    618.3  000F22 FF                   DB      0FFh       ; not immediate
    618.4  000F23              link    SET     $
    618.5  000F23 02                   DB      2
    618.6  000F24 552E                 DB      'U.'
    618.7  000F26                      EVEN
    618.8  000F26                      IF      'DOCOLON'='DOCODE'
    618.9  000F26              UDOT: DW     $+2
    618.10 000F26                      ELSE
    618.11 000F26 ....         UDOT: DW      DOCOLON
    618.12 000F28                      ENDIF
    618.13 000F28                      ENDM
    619    000F28 ............*        DW LESSNUM,ZERO,NUMS,NUMGREATER,TYP
    620    000F32 ........             DW SPACE,EXIT
    621    000F36              
    622    000F36              ;C .     n --           display n signed
    623    000F36              ;   <# DUP ABS 0 #S ROT SIGN #> TYPE SPACE
                                ;
    624    000F36                  HEADER  DOT,1,'.',DOCOLON
    624.1  000000                      PUBLIC  DOT
    624.2  000F36 ....                 DW      link
    624.3  000F38 FF                   DB      0FFh       ; not immediate
    624.4  000F39              link    SET     $
    624.5  000F39 01                   DB      1
    624.6  000F3A 2E                   DB      '.'
    624.7  000F3B 00                   EVEN
    624.8  000F3C                      IF      'DOCOLON'='DOCODE'
    624.9  000F3C              DOT: DW     $+2
    624.10 000F3C                      ELSE
    624.11 000F3C ....         DOT: DW      DOCOLON
    624.12 000F3E                      ENDIF
    624.13 000F3E                      ENDM
    625    000F3E ............*        DW LESSNUM,DUP,ABBS,ZERO,NUMS
    626    000F48 ............*        DW ROT,SIGN,NUMGREATER,TYP,SPACE,EXIT
    627    000F54              
    628    000F54              ;C DECIMAL  --      set number base to
                                decimal
    629    000F54              ;   10 BASE ! ;
    630    000F54                  HEADER  DECIMAL,7,'DECIMAL',DOCOLON
    630.1  000000                      PUBLIC  DECIMAL
    630.2  000F54 ....                 DW      link
    630.3  000F56 FF                   DB      0FFh       ; not immediate
    630.4  000F57              link    SET     $
    630.5  000F57 07                   DB      7
    630.6  000F58 444543494D41*        DB      'DECIMAL'
    630.7  000F5F 00                   EVEN
    630.8  000F60                      IF      'DOCOLON'='DOCODE'
    630.9  000F60              DECIMAL: DW     $+2
    630.10 000F60                      ELSE
    630.11 000F60 ....         DECIMAL: DW      DOCOLON
    630.12 000F62                      ENDIF
    630.13 000F62                      ENDM
    631    000F62 ....0A00....*        DW lit,10,BASE,STORE,EXIT
    632    000F6C              
    633    000F6C              ;X HEX     --       set number base to
                                hex
    634    000F6C              ;   16 BASE ! ;
    635    000F6C                  HEADER  HEX,3,'HEX',DOCOLON
    635.1  000000                      PUBLIC  HEX
    635.2  000F6C ....                 DW      link
    635.3  000F6E FF                   DB      0FFh       ; not immediate
    635.4  000F6F              link    SET     $
    635.5  000F6F 03                   DB      3
    635.6  000F70 484558               DB      'HEX'
    635.7  000F73 00                   EVEN
    635.8  000F74                      IF      'DOCOLON'='DOCODE'
    635.9  000F74              HEX: DW     $+2
    635.10 000F74                      ELSE
    635.11 000F74 ....         HEX: DW      DOCOLON
    635.12 000F76                      ENDIF
    635.13 000F76                      ENDM
    636    000F76 ....1000....*        DW lit,16,BASE,STORE,EXIT
    637    000F80              
    638    000F80              ; DICTIONARY MANAGEMENT ========================
                               =
    639    000F80              
    640    000F80              ;C HERE    -- addr      returns dictionary
                                ptr
    641    000F80              ;   DP @ ;
    642    000F80                  HEADER  HERE,4,'HERE',DOCOLON
    642.1  000000                      PUBLIC  HERE
    642.2  000F80 ....                 DW      link
    642.3  000F82 FF                   DB      0FFh       ; not immediate
    642.4  000F83              link    SET     $
    642.5  000F83 04                   DB      4
    642.6  000F84 48455245             DB      'HERE'
    642.7  000F88                      EVEN
    642.8  000F88                      IF      'DOCOLON'='DOCODE'
    642.9  000F88              HERE: DW     $+2
    642.10 000F88                      ELSE
    642.11 000F88 ....         HERE: DW      DOCOLON
    642.12 000F8A                      ENDIF
    642.13 000F8A                      ENDM
    643    000F8A ............         DW DDP,FETCH,EXIT
    644    000F90              
    645    000F90              ;C ALLOT   n --         allocate n bytes in
                                dict
    646    000F90              ;   DP +! ;
    647    000F90                  HEADER  ALLOT,5,'ALLOT',DOCOLON
    647.1  000000                      PUBLIC  ALLOT
    647.2  000F90 ....                 DW      link
    647.3  000F92 FF                   DB      0FFh       ; not immediate
    647.4  000F93              link    SET     $
    647.5  000F93 05                   DB      5
    647.6  000F94 414C4C4F54           DB      'ALLOT'
    647.7  000F99 00                   EVEN
    647.8  000F9A                      IF      'DOCOLON'='DOCODE'
    647.9  000F9A              ALLOT: DW     $+2
    647.10 000F9A                      ELSE
    647.11 000F9A ....         ALLOT: DW      DOCOLON
    647.12 000F9C                      ENDIF
    647.13 000F9C                      ENDM
    648    000F9C ............         DW DDP,PLUSSTORE,EXIT
    649    000FA2              
    650    000FA2              ;C ,    x --           append cell to dict
    651    000FA2              ;   HERE ! 1 CELLS ALLOT ;
    652    000FA2                  HEADER  COMMA,1,',',DOCOLON
    652.1  000000                      PUBLIC  COMMA
    652.2  000FA2 ....                 DW      link
    652.3  000FA4 FF                   DB      0FFh       ; not immediate
    652.4  000FA5              link    SET     $
    652.5  000FA5 01                   DB      1
    652.6  000FA6 2C                   DB      ','
    652.7  000FA7 00                   EVEN
    652.8  000FA8                      IF      'DOCOLON'='DOCODE'
    652.9  000FA8              COMMA: DW     $+2
    652.10 000FA8                      ELSE
    652.11 000FA8 ....         COMMA: DW      DOCOLON
    652.12 000FAA                      ENDIF
    652.13 000FAA                      ENDM
    653    000FAA ............*        DW HERE,STORE,lit,1,CELLS,ALLOT,EXIT
    654    000FB8              
    655    000FB8              ;C C,   char --        append char to dict
    656    000FB8              ;   HERE C! 1 CHARS ALLOT ;
    657    000FB8                  HEADER  CCOMMA,2,'C,',DOCOLON
    657.1  000000                      PUBLIC  CCOMMA
    657.2  000FB8 ....                 DW      link
    657.3  000FBA FF                   DB      0FFh       ; not immediate
    657.4  000FBB              link    SET     $
    657.5  000FBB 02                   DB      2
    657.6  000FBC 432C                 DB      'C,'
    657.7  000FBE                      EVEN
    657.8  000FBE                      IF      'DOCOLON'='DOCODE'
    657.9  000FBE              CCOMMA: DW     $+2
    657.10 000FBE                      ELSE
    657.11 000FBE ....         CCOMMA: DW      DOCOLON
    657.12 000FC0                      ENDIF
    657.13 000FC0                      ENDM
    658    000FC0 ............*        DW HERE,CSTORE,lit,1,CHARS,ALLOT,EXIT
    659    000FCE              
    660    000FCE              ; The following additional words support
                                the
    661    000FCE              ; "Harvard" model, with separate address
                                spaces
    662    000FCE              ; for Instructions (Code) and Data.  ANSI
    663    000FCE              ; requires DP to manage the Data space, so
                                a
    664    000FCE              ; separate Instruction Dictionary Pointer,
                                IDP,
    665    000FCE              ; is added to manage the Code space.  Also
                                added:
    666    000FCE              ;   I@ IC@ I! IC! I->D D->I   (in the primitives
                               )
    667    000FCE              ;   ITYPE ICOUNT IWORD        (above)
    668    000FCE              ;   IHERE IALLOT I, IC,       (below)
    669    000FCE              ; It should be possible to convert the
                                Harvard
    670    000FCE              ; implementation to a combined-code-and-data
    671    000FCE              ; system, by equating these words to their
    672    000FCE              ; Data-space counterparts.
    673    000FCE              
    674    000FCE              ; on MSP430 we have Neumann, but
    675    000FCE              ;    I! IC! D->I   (in the primitives) work on
                                flash
    676    000FCE              ;    I@ IC@ alias @ C@
    677    000FCE              ;    I->D alias CMOVE
    678    000FCE              ;    IWORD works on flash
    679    000FCE              ;    IHERE IALLOT I, IC,  work on flash
    680    000FCE              
    681    000FCE              ;C IHERE    -- addr   returns Code dictionary
                                ptr
    682    000FCE              ;   IDP @ ;
    683    000FCE                  HEADER  IHERE,5,'IHERE',DOCOLON
    683.1  000000                      PUBLIC  IHERE
    683.2  000FCE ....                 DW      link
    683.3  000FD0 FF                   DB      0FFh       ; not immediate
    683.4  000FD1              link    SET     $
    683.5  000FD1 05                   DB      5
    683.6  000FD2 4948455245           DB      'IHERE'
    683.7  000FD7 00                   EVEN
    683.8  000FD8                      IF      'DOCOLON'='DOCODE'
    683.9  000FD8              IHERE: DW     $+2
    683.10 000FD8                      ELSE
    683.11 000FD8 ....         IHERE: DW      DOCOLON
    683.12 000FDA                      ENDIF
    683.13 000FDA                      ENDM
    684    000FDA ............         DW IDP,FETCH,EXIT
    685    000FE0              
    686    000FE0              ;C IALLOT   n --    allocate n bytes in Code
                                dict
    687    000FE0              ;   IDP +! ;
    688    000FE0                  HEADER  IALLOT,6,'IALLOT',DOCOLON
    688.1  000000                      PUBLIC  IALLOT
    688.2  000FE0 ....                 DW      link
    688.3  000FE2 FF                   DB      0FFh       ; not immediate
    688.4  000FE3              link    SET     $
    688.5  000FE3 06                   DB      6
    688.6  000FE4 49414C4C4F54         DB      'IALLOT'
    688.7  000FEA                      EVEN
    688.8  000FEA                      IF      'DOCOLON'='DOCODE'
    688.9  000FEA              IALLOT: DW     $+2
    688.10 000FEA                      ELSE
    688.11 000FEA ....         IALLOT: DW      DOCOLON
    688.12 000FEC                      ENDIF
    688.13 000FEC                      ENDM
    689    000FEC ............         DW IDP,PLUSSTORE,EXIT
    690    000FF2              
    691    000FF2              ;C I,    x --           append cell to Code
                                dict
    692    000FF2              ;   IHERE I! 1 CELLS IALLOT ;
    693    000FF2                  HEADER  ICOMMA,2,'I,',DOCOLON
    693.1  000000                      PUBLIC  ICOMMA
    693.2  000FF2 ....                 DW      link
    693.3  000FF4 FF                   DB      0FFh       ; not immediate
    693.4  000FF5              link    SET     $
    693.5  000FF5 02                   DB      2
    693.6  000FF6 492C                 DB      'I,'
    693.7  000FF8                      EVEN
    693.8  000FF8                      IF      'DOCOLON'='DOCODE'
    693.9  000FF8              ICOMMA: DW     $+2
    693.10 000FF8                      ELSE
    693.11 000FF8 ....         ICOMMA: DW      DOCOLON
    693.12 000FFA                      ENDIF
    693.13 000FFA                      ENDM
    694    000FFA ............*        DW IHERE,ISTORE,lit,1,CELLS,IALLOT,EXIT
    695    001008              
    696    001008              ;C IC,   char --        append char to Code
                                dict
    697    001008              ;   IHERE IC! 1 CHARS IALLOT ;
    698    001008                  HEADER  ICCOMMA,3,'IC,',DOCOLON
    698.1  000000                      PUBLIC  ICCOMMA
    698.2  001008 ....                 DW      link
    698.3  00100A FF                   DB      0FFh       ; not immediate
    698.4  00100B              link    SET     $
    698.5  00100B 03                   DB      3
    698.6  00100C 49432C               DB      'IC,'
    698.7  00100F 00                   EVEN
    698.8  001010                      IF      'DOCOLON'='DOCODE'
    698.9  001010              ICCOMMA: DW     $+2
    698.10 001010                      ELSE
    698.11 001010 ....         ICCOMMA: DW      DOCOLON
    698.12 001012                      ENDIF
    698.13 001012                      ENDM
    699    001012 ............*        DW IHERE,ICSTORE,lit,1,CHARS,IALLOT,EXIT
    700    001020              
    701    001020              ; SEPARATE HEADER EXTENSIONS ARE NOT USED
    702    001020              #define HHERE IHERE
    703    001020              #define HALLOT IALLOT
    704    001020              #define HCOMMA ICOMMA
    705    001020              #define HCCOMMA ICCOMMA
    706    001020              #define HCFETCH ICFETCH
    707    001020              #define HFETCH IFETCH
    708    001020              #define HCSTORE ICSTORE
    709    001020              #define HSTORE ISTORE
    710    001020              
    711    001020              ; INTERPRETER ==================================
                               =
    712    001020              ; Note that NFA>LFA, NFA>CFA, IMMED?, and
                                FIND
    713    001020              ; are dependent on the structure of the
                                Forth
    714    001020              ; header.  This may be common across many
                                CPUs,
    715    001020              ; or it may be different.
    716    001020              
    717    001020              ;C SOURCE   -- adr n    current input buffer
    718    001020              ;   'SOURCE 2@ ;        length is at lower
                                adrs
    719    001020                  HEADER  SOURCE,6,'SOURCE',DOCOLON
    719.1  000000                      PUBLIC  SOURCE
    719.2  001020 ....                 DW      link
    719.3  001022 FF                   DB      0FFh       ; not immediate
    719.4  001023              link    SET     $
    719.5  001023 06                   DB      6
    719.6  001024 534F55524345         DB      'SOURCE'
    719.7  00102A                      EVEN
    719.8  00102A                      IF      'DOCOLON'='DOCODE'
    719.9  00102A              SOURCE: DW     $+2
    719.10 00102A                      ELSE
    719.11 00102A ....         SOURCE: DW      DOCOLON
    719.12 00102C                      ENDIF
    719.13 00102C                      ENDM
    720    00102C ............         DW TICKSOURCE,TWOFETCH,EXIT
    721    001032              
    722    001032              ;X /STRING  a u n -- a+n u-n   trim string
    723    001032              ;   ROT OVER + ROT ROT - ;
    724    001032                  HEADER  SLASHSTRING,7,'/STRING',DOCOLON
    724.1  000000                      PUBLIC  SLASHSTRING
    724.2  001032 ....                 DW      link
    724.3  001034 FF                   DB      0FFh       ; not immediate
    724.4  001035              link    SET     $
    724.5  001035 07                   DB      7
    724.6  001036 2F535452494E*        DB      '/STRING'
    724.7  00103D 00                   EVEN
    724.8  00103E                      IF      'DOCOLON'='DOCODE'
    724.9  00103E              SLASHSTRING: DW     $+2
    724.10 00103E                      ELSE
    724.11 00103E ....         SLASHSTRING: DW      DOCOLON
    724.12 001040                      ENDIF
    724.13 001040                      ENDM
    725    001040 ............*        DW ROT,OVER,PLUS,ROT,ROT,MINUS,EXIT
    726    00104E              
    727    00104E              ;Z >counted  src n dst --     copy to counted
                                str
    728    00104E              ;   2DUP C! CHAR+ SWAP CMOVE ;
    729    00104E                  HEADER  TOCOUNTED,8,'>COUNTED',DOCOLON
    729.1  000000                      PUBLIC  TOCOUNTED
    729.2  00104E ....                 DW      link
    729.3  001050 FF                   DB      0FFh       ; not immediate
    729.4  001051              link    SET     $
    729.5  001051 08                   DB      8
    729.6  001052 3E434F554E54*        DB      '>COUNTED'
    729.7  00105A                      EVEN
    729.8  00105A                      IF      'DOCOLON'='DOCODE'
    729.9  00105A              TOCOUNTED: DW     $+2
    729.10 00105A                      ELSE
    729.11 00105A ....         TOCOUNTED: DW      DOCOLON
    729.12 00105C                      ENDIF
    729.13 00105C                      ENDM
    730    00105C ............*        DW TWODUP,CSTORE,CHARPLUS,SWAP,CMOVE,EXI
                                           T
    731    001068              
    732    001068              ;C WORD   char -- c-addr n   word delim'd by
                                char
    733    001068              ;   DUP  SOURCE >IN @ /STRING   -- c c adr
                                n
    734    001068              ;   DUP >R   ROT SKIP           -- c adr'
                                n'
    735    001068              ;   OVER >R  ROT SCAN           -- adr"
                                n"
    736    001068              ;   DUP IF CHAR- THEN        skip trailing
                                delim.
    737    001068              ;   R> R> ROT -   >IN +!        update >IN
                                offset
    738    001068              ;   TUCK -                      -- adr'
                                N
    739    001068              ;   HERE >counted               --
    740    001068              ;   HERE                        -- a
    741    001068              ;   BL OVER COUNT + C! ;    append trailing
                                blank
    742    001068                  HEADER  WORDD,4,'WORD',DOCOLON
    742.1  000000                      PUBLIC  WORDD
    742.2  001068 ....                 DW      link
    742.3  00106A FF                   DB      0FFh       ; not immediate
    742.4  00106B              link    SET     $
    742.5  00106B 04                   DB      4
    742.6  00106C 574F5244             DB      'WORD'
    742.7  001070                      EVEN
    742.8  001070                      IF      'DOCOLON'='DOCODE'
    742.9  001070              WORDD: DW     $+2
    742.10 001070                      ELSE
    742.11 001070 ....         WORDD: DW      DOCOLON
    742.12 001072                      ENDIF
    742.13 001072                      ENDM
    743    001072 ............*        DW DUP,SOURCE,TOIN,FETCH,SLASHSTRING
    744    00107C ............*        DW DUP,TOR,ROT,SKIP
    745    001084 ............*        DW OVER,TOR,ROT,SCAN
    746    00108C ........             DW DUP,qbran
    747    001090                      DEST  WORD1
    747.1  001090 0400                 DW      WORD1-$
    747.2  001092                      ENDM
    748    001092 ....                 DW ONEMINUS  ; char-
    749    001094 ............*WORD1:  DW RFROM,RFROM,ROT,MINUS,TOIN,PLUSSTORE
    750    0010A0 ........             DW TUCK,MINUS
    751    0010A4 ............         DW HERE,TOCOUNTED,HERE
    752    0010AA ............*        DW BLANK,OVER,COUNT,PLUS,CSTORE,EXIT
    753    0010B6              
    754    0010B6              ;Z NFA>LFA   nfa -- lfa    name adr -> link
                                field
    755    0010B6              ;   3 - ;
    756    0010B6                  HEADER  NFATOLFA,7,'NFA>LFA',DOCOLON
    756.1  000000                      PUBLIC  NFATOLFA
    756.2  0010B6 ....                 DW      link
    756.3  0010B8 FF                   DB      0FFh       ; not immediate
    756.4  0010B9              link    SET     $
    756.5  0010B9 07                   DB      7
    756.6  0010BA 4E46413E4C46*        DB      'NFA>LFA'
    756.7  0010C1 00                   EVEN
    756.8  0010C2                      IF      'DOCOLON'='DOCODE'
    756.9  0010C2              NFATOLFA: DW     $+2
    756.10 0010C2                      ELSE
    756.11 0010C2 ....         NFATOLFA: DW      DOCOLON
    756.12 0010C4                      ENDIF
    756.13 0010C4                      ENDM
    757    0010C4 ....0300....*        DW lit,3,MINUS,EXIT
    758    0010CC              
    759    0010CC              ;Z NFA>CFA   nfa -- cfa    name adr -> code
                                field
    760    0010CC              ;   HCOUNT 7F AND + ALIGNED ;   mask off
                                'smudge' bit
    761    0010CC                  HEADER  NFATOCFA,7,'NFA>CFA',DOCOLON
    761.1  000000                      PUBLIC  NFATOCFA
    761.2  0010CC ....                 DW      link
    761.3  0010CE FF                   DB      0FFh       ; not immediate
    761.4  0010CF              link    SET     $
    761.5  0010CF 07                   DB      7
    761.6  0010D0 4E46413E4346*        DB      'NFA>CFA'
    761.7  0010D7 00                   EVEN
    761.8  0010D8                      IF      'DOCOLON'='DOCODE'
    761.9  0010D8              NFATOCFA: DW     $+2
    761.10 0010D8                      ELSE
    761.11 0010D8 ....         NFATOCFA: DW      DOCOLON
    761.12 0010DA                      ENDIF
    761.13 0010DA                      ENDM
    762    0010DA ....                 DW HCOUNT
    763    0010DC ....7F00....*        DW lit,07FH,ANDD,PLUS,ALIGNED,EXIT
    764    0010E8              
    765    0010E8              ;Z IMMED?    nfa -- f      fetch immediate
                                flag
    766    0010E8              ;   1- HC@ 1 AND 0= ;   Flashable model, LSB=0
                                if immed
    767    0010E8                  HEADER  IMMEDQ,6,'IMMED?',DOCOLON
    767.1  000000                      PUBLIC  IMMEDQ
    767.2  0010E8 ....                 DW      link
    767.3  0010EA FF                   DB      0FFh       ; not immediate
    767.4  0010EB              link    SET     $
    767.5  0010EB 06                   DB      6
    767.6  0010EC 494D4D45443F         DB      'IMMED?'
    767.7  0010F2                      EVEN
    767.8  0010F2                      IF      'DOCOLON'='DOCODE'
    767.9  0010F2              IMMEDQ: DW     $+2
    767.10 0010F2                      ELSE
    767.11 0010F2 ....         IMMEDQ: DW      DOCOLON
    767.12 0010F4                      ENDIF
    767.13 0010F4                      ENDM
    768    0010F4 ............*        DW ONEMINUS,HCFETCH,lit,1,ANDD,ZEROEQUAL
                                           ,EXIT
    769    001102              
    770    001102              ;C FIND   c-addr -- c-addr 0   if not found
    771    001102              ;C FIND   c-addr -- xt  1      if immediate
    772    001102              ;C FIND   c-addr -- xt -1      if "normal"
    773    001102              ;   LATEST @ BEGIN             -- a nfa
    774    001102              ;       2DUP OVER C@ CHAR+     -- a nfa a nfa
                                n+1
    775    001102              ;       N=                     -- a nfa
                                f
    776    001102              ;       DUP IF
    777    001102              ;           DROP
    778    001102              ;           NFA>LFA H@ DUP     -- a link
                                link
    779    001102              ;       THEN
    780    001102              ;   0= UNTIL                   -- a nfa  OR  a
                                0
    781    001102              ;   DUP IF
    782    001102              ;       NIP DUP NFA>CFA        -- nfa xt
    783    001102              ;       SWAP IMMED?            -- xt iflag
    784    001102              ;       0= 1 OR                -- xt 1/-1
    785    001102              ;   THEN ;
    786    001102                  HEADER  FIND,4,'FIND',DOCOLON
    786.1  000000                      PUBLIC  FIND
    786.2  001102 ....                 DW      link
    786.3  001104 FF                   DB      0FFh       ; not immediate
    786.4  001105              link    SET     $
    786.5  001105 04                   DB      4
    786.6  001106 46494E44             DB      'FIND'
    786.7  00110A                      EVEN
    786.8  00110A                      IF      'DOCOLON'='DOCODE'
    786.9  00110A              FIND: DW     $+2
    786.10 00110A                      ELSE
    786.11 00110A ....         FIND: DW      DOCOLON
    786.12 00110C                      ENDIF
    786.13 00110C                      ENDM
    787    00110C ........             DW LATEST,FETCH
    788    001110 ............*FIND1:  DW TWODUP,OVER,CFETCH,CHARPLUS
    789    001118 ............         DW NEQUAL,DUP,qbran
    790    00111E                      DEST  FIND2
    790.1  00111E 0A00                 DW      FIND2-$
    790.2  001120                      ENDM
    791    001120 ............*        DW DROP,NFATOLFA,HFETCH,DUP
    792    001128 ........     FIND2:  DW ZEROEQUAL,qbran
    793    00112C                      DEST  FIND1
    793.1  00112C E4FF                 DW      FIND1-$
    793.2  00112E                      ENDM
    794    00112E ........             DW DUP,qbran
    795    001132                      DEST  FIND3
    795.1  001132 1400                 DW      FIND3-$
    795.2  001134                      ENDM
    796    001134 ............         DW NIP,DUP,NFATOCFA
    797    00113A ............*        DW SWAP,IMMEDQ,ZEROEQUAL,lit,1,ORR
    798    001146 ....         FIND3:  DW EXIT
    799    001148              
    800    001148              ;C UPC   char -- char  capitalize character
    801    001148              ;
    802    001148              ; DUP [CHAR] a < OVER [CHAR] z > OR IF EXIT THEN
                                 
    803    001148              ; [ CHAR A CHAR a - ] LITERAL + ; 
    804    001148              ;  HEADER  UPC,3,'UPC',DOCOLON
    805    001148                  HEADLESS UPC, DOCOLON
    805.1  000000                      PUBLIC  UPC
    805.2  001148                      IF      'DOCOLON'='DOCODE'
    805.3  001148              UPC: DW     $+2
    805.4  001148                      ELSE
    805.5  001148 ....         UPC: DW      DOCOLON
    805.6  00114A                      ENDIF
    805.7  00114A                      ENDM
    806    00114A ........6100*        DW DUP, lit, 'a', LESS, OVER, lit, 'z',
                                            GREATER
    807    00115A ........             DW ORR, qbran
    808    00115E                      DEST  UPC1
    808.1  00115E 0400                 DW      UPC1-$
    808.2  001160                      ENDM
    809    001160 ....                 DW EXIT
    810    001162 ....E0FF.... UPC1:   DW lit, 'A'-'a', PLUS
    811    001168 ....                 DW EXIT
    812    00116A              
    813    00116A              ;C CAPITALIZE c-addr -- c-addr  capitalize
                                string
    814    00116A              ;
    815    00116A              ; CAPS @ IF DUP COUNT OVER + SWAP ?DO  I c@ upc
                                I c! LOOP THEN
    816    00116A              ;   HEADER CAPITALIZE, 10, 'CAPITALIZE',
                                DOCOLON
    817    00116A                  HEADLESS CAPITALIZE, DOCOLON
    817.1  000000                      PUBLIC  CAPITALIZE
    817.2  00116A                      IF      'DOCOLON'='DOCODE'
    817.3  00116A              CAPITALIZE: DW     $+2
    817.4  00116A                      ELSE
    817.5  00116A ....         CAPITALIZE: DW      DOCOLON
    817.6  00116C                      ENDIF
    817.7  00116C                      ENDM
    818    00116C ............         DW CAPS, FETCH, qbran
    819    001172                      DEST CAPS2
    819.1  001172 1C00                 DW      CAPS2-$
    819.2  001174                      ENDM
    820    001174 ............*        DW DUP, COUNT, OVER, PLUS, SWAP,
                                            xdo
    821    001180 ............*CAPS1:  DW II, CFETCH, UPC, II, CSTORE
    822    00118A ....                 DW xloop
    823    00118C                      DEST CAPS1
    823.1  00118C F4FF                 DW      CAPS1-$
    823.2  00118E                      ENDM
    824    00118E ....         CAPS2:  DW EXIT
    825    001190              
    826    001190              ;C LITERAL  x --        append numeric
                                literal
    827    001190              ;   STATE @ IF ['] LIT ,XT I, THEN ; IMMEDIATE
    828    001190              ; This tests STATE so that it can also be
                                used
    829    001190              ; interpretively.  (ANSI doesn't require
                                this.)
    830    001190                  IMMED  LITERAL,7,'LITERAL',DOCOLON
    830.1  000000                      PUBLIC  LITERAL
    830.2  001190 ....                 DW      link
    830.3  001192 FE                   DB      0FEh      // ; immediate
                                                                       (LSB=0)
    830.4  001193              link    SET     $
    830.5  001193 07                   DB      7
    830.6  001194 4C4954455241*        DB      'LITERAL'
    830.7  00119B 00                   EVEN
    830.8  00119C                      IF      'DOCOLON'='DOCODE'
    830.9  00119C              LITERAL: DW     $+2
    830.10 00119C                      ELSE
    830.11 00119C ....         LITERAL: DW      DOCOLON
    830.12 00119E                      ENDIF
    830.13 00119E                      ENDM
    831    00119E ............         DW STATE,FETCH,qbran
    832    0011A4                      DEST  LITER1
    832.1  0011A4 0A00                 DW      LITER1-$
    832.2  0011A6                      ENDM
    833    0011A6 ............*        DW lit,lit,COMMAXT,ICOMMA
    834    0011AE ....         LITER1: DW EXIT
    835    0011B0              
    836    0011B0              ;Z DIGIT?   c -- n -1   if c is a valid
                                digit
    837    0011B0              ;Z DIGIT?   c -- x  0   otherwise
    838    0011B0              ;   [ HEX ] DUP 39 > 100 AND +     silly
                                looking
    839    0011B0              ;   DUP 140 > 107 AND -   30 -     but it
                                works!
    840    0011B0              ;   DUP BASE @ U< ;
    841    0011B0                  HEADER  DIGITQ,6,'DIGIT?',DOCOLON
    841.1  000000                      PUBLIC  DIGITQ
    841.2  0011B0 ....                 DW      link
    841.3  0011B2 FF                   DB      0FFh       ; not immediate
    841.4  0011B3              link    SET     $
    841.5  0011B3 06                   DB      6
    841.6  0011B4 44494749543F         DB      'DIGIT?'
    841.7  0011BA                      EVEN
    841.8  0011BA                      IF      'DOCOLON'='DOCODE'
    841.9  0011BA              DIGITQ: DW     $+2
    841.10 0011BA                      ELSE
    841.11 0011BA ....         DIGITQ: DW      DOCOLON
    841.12 0011BC                      ENDIF
    841.13 0011BC                      ENDM
    842    0011BC ........3900*        DW DUP,lit,39H,GREATER,lit,100H,ANDD,PLU
                                           S
    843    0011CC ........4001*        DW DUP,lit,140H,GREATER,lit,107H,ANDD
    844    0011DA ........3000*        DW MINUS,lit,30H,MINUS
    845    0011E2 ............*        DW DUP,BASE,FETCH,ULESS,EXIT
    846    0011EC              
    847    0011EC              ;Z ?SIGN   adr n -- adr' n' f      get optional
                                sign
    848    0011EC              ;  advance adr/n if sign; return NZ if
                                negative
    849    0011EC              ;   OVER C@                 -- adr n c
    850    0011EC              ;   2C - DUP ABS 1 = AND    -- +=-1, -=+1, else
                                0
    851    0011EC              ;   DUP IF 1+               -- +=0, -=+2
    852    0011EC              ;       >R 1 /STRING R>     -- adr' n'
                                f
    853    0011EC              ;   THEN ;
    854    0011EC                  HEADER  QSIGN,5,'?SIGN',DOCOLON
    854.1  000000                      PUBLIC  QSIGN
    854.2  0011EC ....                 DW      link
    854.3  0011EE FF                   DB      0FFh       ; not immediate
    854.4  0011EF              link    SET     $
    854.5  0011EF 05                   DB      5
    854.6  0011F0 3F5349474E           DB      '?SIGN'
    854.7  0011F5 00                   EVEN
    854.8  0011F6                      IF      'DOCOLON'='DOCODE'
    854.9  0011F6              QSIGN: DW     $+2
    854.10 0011F6                      ELSE
    854.11 0011F6 ....         QSIGN: DW      DOCOLON
    854.12 0011F8                      ENDIF
    854.13 0011F8                      ENDM
    855    0011F8 ............*        DW OVER,CFETCH,lit,2CH,MINUS,DUP,ABBS
    856    001206 ....0100....*        DW lit,1,EQUAL,ANDD,DUP,qbran
    857    001212                      DEST  QSIGN1
    857.1  001212 0E00                 DW      QSIGN1-$
    857.2  001214                      ENDM
    858    001214 ............*        DW ONEPLUS,TOR,lit,1,SLASHSTRING,RFROM
    859    001220 ....         QSIGN1: DW EXIT
    860    001222              
    861    001222              ;C >NUMBER  ud adr u -- ud' adr' u'       
                                convert string to number
    862    001222              ;   BEGIN
    863    001222              ;   DUP WHILE
    864    001222              ;       OVER C@ DIGIT?
    865    001222              ;       0= IF DROP EXIT THEN
    866    001222              ;       >R 2SWAP BASE @ UD*
    867    001222              ;       R> M+ 2SWAP
    868    001222              ;       1 /STRING
    869    001222              ;   REPEAT ;
    870    001222                  HEADER  TONUMBER,7,'>NUMBER',DOCOLON
    870.1  000000                      PUBLIC  TONUMBER
    870.2  001222 ....                 DW      link
    870.3  001224 FF                   DB      0FFh       ; not immediate
    870.4  001225              link    SET     $
    870.5  001225 07                   DB      7
    870.6  001226 3E4E554D4245*        DB      '>NUMBER'
    870.7  00122D 00                   EVEN
    870.8  00122E                      IF      'DOCOLON'='DOCODE'
    870.9  00122E              TONUMBER: DW     $+2
    870.10 00122E                      ELSE
    870.11 00122E ....         TONUMBER: DW      DOCOLON
    870.12 001230                      ENDIF
    870.13 001230                      ENDM
    871    001230 ........     TONUM1: DW DUP,qbran
    872    001234                      DEST  TONUM3
    872.1  001234 2C00                 DW      TONUM3-$
    872.2  001236                      ENDM
    873    001236 ............         DW OVER,CFETCH,DIGITQ
    874    00123C ........             DW ZEROEQUAL,qbran
    875    001240                      DEST  TONUM2
    875.1  001240 0600                 DW      TONUM2-$
    875.2  001242                      ENDM
    876    001242 ........             DW DROP,EXIT
    877    001246 ............*TONUM2: DW TOR,TWOSWAP,BASE,FETCH,UDSTAR
    878    001250 ............         DW RFROM,MPLUS,TWOSWAP
    879    001256 ....0100....*        DW lit,1,SLASHSTRING,bran
    880    00125E                      DEST  TONUM1
    880.1  00125E D2FF                 DW      TONUM1-$
    880.2  001260                      ENDM
    881    001260 ....         TONUM3: DW EXIT
    882    001262              
    883    001262              ;Z ?NUMBER  c-addr -- n -1        string->number
    884    001262              ;Z ?NUMBER  c-addr -- c-addr 0    if convert
                                error
    885    001262              ;   DUP  0 0 ROT COUNT      -- ca ud adr
                                n
    886    001262              ;   ?SIGN >R  >NUMBER       -- ca ud adr'
                                n'
    887    001262              ;   IF   R> 2DROP 2DROP 0   -- ca 0   (error)
    888    001262              ;   ELSE 2DROP NIP R>
    889    001262              ;       IF NEGATE THEN  -1  -- n -1   (ok)
    890    001262              ;   THEN ;
    891    001262                  HEADER  QNUMBER,7,'?NUMBER',DOCOLON
    891.1  000000                      PUBLIC  QNUMBER
    891.2  001262 ....                 DW      link
    891.3  001264 FF                   DB      0FFh       ; not immediate
    891.4  001265              link    SET     $
    891.5  001265 07                   DB      7
    891.6  001266 3F4E554D4245*        DB      '?NUMBER'
    891.7  00126D 00                   EVEN
    891.8  00126E                      IF      'DOCOLON'='DOCODE'
    891.9  00126E              QNUMBER: DW     $+2
    891.10 00126E                      ELSE
    891.11 00126E ....         QNUMBER: DW      DOCOLON
    891.12 001270                      ENDIF
    891.13 001270                      ENDM
    892    001270 ............*        DW DUP,ZERO,DUP,ROT,COUNT
    893    00127A ............*        DW QSIGN,TOR,TONUMBER,qbran
    894    001282                      DEST  QNUM1
    894.1  001282 1000                 DW      QNUM1-$
    894.2  001284                      ENDM
    895    001284 ............*        DW RFROM,TWODROP,TWODROP,lit,0
    896    00128E ....                 DW bran
    897    001290                      DEST  QNUM3
    897.1  001290 1200                 DW      QNUM3-$
    897.2  001292                      ENDM
    898    001292 ............*QNUM1:  DW TWODROP,NIP,RFROM,qbran
    899    00129A                      DEST  QNUM2
    899.1  00129A 0400                 DW      QNUM2-$
    899.2  00129C                      ENDM
    900    00129C ....                 DW NEGATE
    901    00129E ....FFFF     QNUM2:  DW lit,-1
    902    0012A2 ....         QNUM3:  DW EXIT
    903    0012A4              
    904    0012A4              ;Z INTERPRET    i*x c-addr u -- j*x             
                                   interpret given buffer
    905    0012A4              ; This is a common factor of EVALUATE and
                                QUIT.
    906    0012A4              ; ref. dpANS-6, 3.4 The Forth Text Interpreter
    907    0012A4              ;   'SOURCE 2!  0 >IN !
    908    0012A4              ;   BEGIN
    909    0012A4              ;   BL WORD DUP C@ WHILE        -- textadr
    910    0012A4              ;       CAPITALIZE
    911    0012A4              ;       FIND                    -- a 0/1/-1
    912    0012A4              ;       ?DUP IF                 -- xt 1/-1
    913    0012A4              ;           1+ STATE @ 0= OR    IMMED  or
                                interp?
    914    0012A4              ;           IF EXECUTE ELSE ,XT THEN
    915    0012A4              ;       ELSE                    -- textadr
    916    0012A4              ;           ?NUMBER
    917    0012A4              ;           IF POSTPONE LITERAL     converted
                                ok
    918    0012A4              ;           ELSE COUNT TYPE 3F EMIT CR ABORT 
                                err
    919    0012A4              ;           THEN
    920    0012A4              ;       THEN
    921    0012A4              ;   REPEAT DROP ;
    922    0012A4                  HEADER  INTERPRET,9,'INTERPRET',DOCOLON
    922.1  000000                      PUBLIC  INTERPRET
    922.2  0012A4 ....                 DW      link
    922.3  0012A6 FF                   DB      0FFh       ; not immediate
    922.4  0012A7              link    SET     $
    922.5  0012A7 09                   DB      9
    922.6  0012A8 494E54455250*        DB      'INTERPRET'
    922.7  0012B1 00                   EVEN
    922.8  0012B2                      IF      'DOCOLON'='DOCODE'
    922.9  0012B2              INTERPRET: DW     $+2
    922.10 0012B2                      ELSE
    922.11 0012B2 ....         INTERPRET: DW      DOCOLON
    922.12 0012B4                      ENDIF
    922.13 0012B4                      ENDM
    923    0012B4 ............*        DW TICKSOURCE,TWOSTORE,ZERO,TOIN,STORE
    924    0012BE ............*INTER1: DW BLANK,WORDD,DUP,CFETCH,qbran
    925    0012C8                      DEST  INTER9
    925.1  0012C8 4400                 DW      INTER9-$
    925.2  0012CA                      ENDM
    926    0012CA ....                 DW CAPITALIZE
    927    0012CC ............         DW FIND,QDUP,qbran
    928    0012D2                      DEST  INTER4
    928.1  0012D2 1C00                 DW      INTER4-$
    928.2  0012D4                      ENDM
    929    0012D4 ............*        DW ONEPLUS,STATE,FETCH,ZEROEQUAL,ORR
    930    0012DE ....                 DW qbran
    931    0012E0                      DEST  INTER2
    931.1  0012E0 0800                 DW      INTER2-$
    931.2  0012E2                      ENDM
    932    0012E2 ........             DW EXECUTE,bran
    933    0012E6                      DEST  INTER3
    933.1  0012E6 0400                 DW      INTER3-$
    933.2  0012E8                      ENDM
    934    0012E8 ....         INTER2: DW COMMAXT
    935    0012EA ....         INTER3: DW bran
    936    0012EC                      DEST  INTER8
    936.1  0012EC 1C00                 DW      INTER8-$
    936.2  0012EE                      ENDM
    937    0012EE ........     INTER4: DW QNUMBER,qbran
    938    0012F2                      DEST  INTER5
    938.1  0012F2 0800                 DW      INTER5-$
    938.2  0012F4                      ENDM
    939    0012F4 ........             DW LITERAL,bran
    940    0012F8                      DEST  INTER6
    940.1  0012F8 1000                 DW      INTER6-$
    940.2  0012FA                      ENDM
    941    0012FA ............*INTER5: DW COUNT,TYP,lit,3FH,EMIT,CR,ABORT
    942    001308              INTER6:
    943    001308 ....         INTER8: DW bran
    944    00130A                      DEST  INTER1
    944.1  00130A B4FF                 DW      INTER1-$
    944.2  00130C                      ENDM
    945    00130C ........     INTER9: DW DROP,EXIT
    946    001310              
    947    001310              ;C EVALUATE  i*x c-addr u -- j*x             
                                interprt string
    948    001310              ;   'SOURCE 2@ >R >R  >IN @ >R
    949    001310              ;   INTERPRET
    950    001310              ;   R> >IN !  R> R> 'SOURCE 2! ;
    951    001310                  HEADER  EVALUATE,8,'EVALUATE',DOCOLON
    951.1  000000                      PUBLIC  EVALUATE
    951.2  001310 ....                 DW      link
    951.3  001312 FF                   DB      0FFh       ; not immediate
    951.4  001313              link    SET     $
    951.5  001313 08                   DB      8
    951.6  001314 4556414C5541*        DB      'EVALUATE'
    951.7  00131C                      EVEN
    951.8  00131C                      IF      'DOCOLON'='DOCODE'
    951.9  00131C              EVALUATE: DW     $+2
    951.10 00131C                      ELSE
    951.11 00131C ....         EVALUATE: DW      DOCOLON
    951.12 00131E                      ENDIF
    951.13 00131E                      ENDM
    952    00131E ............*        DW TICKSOURCE,TWOFETCH,TOR,TOR
    953    001326 ............*        DW TOIN,FETCH,TOR,INTERPRET
    954    00132E ............*        DW RFROM,TOIN,STORE,RFROM,RFROM
    955    001338 ............         DW TICKSOURCE,TWOSTORE,EXIT
    956    00133E              
    957    00133E              #define PREFIXPROMPT 0
    958    00133E              
    959    00133E              ; C DOTSTATUS  --           display system
                                status
    960    00133E                 HEADLESS DOTSTATUS,DOCOLON
    960.1  000000                      PUBLIC  DOTSTATUS
    960.2  00133E                      IF      'DOCOLON'='DOCODE'
    960.3  00133E              DOTSTATUS: DW     $+2
    960.4  00133E                      ELSE
    960.5  00133E ....         DOTSTATUS: DW      DOCOLON
    960.6  001340                      ENDIF
    960.7  001340                      ENDM
    961    001340 ....1100....          DW lit,11H,EMIT  ; send XON
    962    001346 ....                  DW CR
    963    001348                       IF PREFIXPROMPT=1
    964    001348                         DW XISQUOTE
    965    001348                         DB 3,'OK '    ; for prefix prompt
                                style
    966    001348                         DW ITYPE
    967    001348                       ENDIF
    968    001348 ....                  DW EXIT   
    969    00134A              
    970    00134A              ; C PROMPT  --            prompt user
    971    00134A                  HEADLESS PROMPT,DOCOLON
    971.1  000000                      PUBLIC  PROMPT
    971.2  00134A                      IF      'DOCOLON'='DOCODE'
    971.3  00134A              PROMPT: DW     $+2
    971.4  00134A                      ELSE
    971.5  00134A ....         PROMPT: DW      DOCOLON
    971.6  00134C                      ENDIF
    971.7  00134C                      ENDM
    972    00134C                      IF PREFIXPROMPT!=1
    973    00134C ............*          DW STATE,FETCH,ZEROEQUAL,qbran
    974    001354                        DEST PROMPT1
    974.1  001354 0A00                 DW      PROMPT1-$
    974.2  001356                      ENDM
    975    001356 ....                   DW XISQUOTE
    976    001358 036F6B20               DB 3,'ok '    ; for traditional Forth
                                                        style
    977    00135C ....                   DW ITYPE
    978    00135E                      ENDIF
    979    00135E ....         PROMPT1:DW EXIT
    980    001360              
    981    001360              ;C QUIT     -- R: i*x --     interpret from
                                kbd
    982    001360              ;   L0 LP !  R0 RP!   0 STATE !
    983    001360              ;   BEGIN
    984    001360              ;       xon EMIT
    985    001360              ;       TIB DUP TIBSIZE ACCEPT
    986    001360              ;       xoff EMIT  SPACE
    987    001360              ;       INTERPRET
    988    001360              ;       CR STATE @ 0= IF ." OK" THEN
    989    001360              ;   AGAIN ;
    990    001360                  HEADER  QUIT,4,'QUIT',DOCOLON
    990.1  000000                      PUBLIC  QUIT
    990.2  001360 ....                 DW      link
    990.3  001362 FF                   DB      0FFh       ; not immediate
    990.4  001363              link    SET     $
    990.5  001363 04                   DB      4
    990.6  001364 51554954             DB      'QUIT'
    990.7  001368                      EVEN
    990.8  001368                      IF      'DOCOLON'='DOCODE'
    990.9  001368              QUIT: DW     $+2
    990.10 001368                      ELSE
    990.11 001368 ....         QUIT: DW      DOCOLON
    990.12 00136A                      ENDIF
    990.13 00136A                      ENDM
    991    00136A ............         DW L0,LP,STORE
    992    001370 ............*        DW RZERO,RPSTORE,ZERO,STATE,STORE
    993    00137A ....         QUIT1:  DW DOTSTATUS
    994    00137C ............*        DW TIB,DUP,TIBSIZE,ACCEPT
    995    001384                      ; DW lit,13H,EMIT         ; send
                                XOFF
    996    001384 ....                 DW SPACE
    997    001386 ....                 DW INTERPRET
    998    001388 ....                 DW PROMPT
    999    00138A ....                 DW bran
   1000    00138C                      DEST  QUIT1
   1000.1  00138C EEFF                 DW      QUIT1-$
   1000.2  00138E                      ENDM
   1001    000000              PUBLIC QUITIP
   1002    00138E              QUITIP  equ QUIT+2
   1003    00138E                      
   1004    00138E                      
   1005    00138E              
   1006    00138E              ;C ABORT    i*x -- R: j*x --    clear stk &
                                QUIT
   1007    00138E              ;   S0 SP!  QUIT ;
   1008    00138E                  HEADER  ABORT,5,'ABORT',DOCOLON
   1008.1  000000                      PUBLIC  ABORT
   1008.2  00138E ....                 DW      link
   1008.3  001390 FF                   DB      0FFh       ; not immediate
   1008.4  001391              link    SET     $
   1008.5  001391 05                   DB      5
   1008.6  001392 41424F5254           DB      'ABORT'
   1008.7  001397 00                   EVEN
   1008.8  001398                      IF      'DOCOLON'='DOCODE'
   1008.9  001398              ABORT: DW     $+2
   1008.10 001398                      ELSE
   1008.11 001398 ....         ABORT: DW      DOCOLON
   1008.12 00139A                      ENDIF
   1008.13 00139A                      ENDM
   1009    00139A ............         DW S0,SPSTORE,QUIT   ; QUIT never
                                                             returns
   1010    0013A0              
   1011    0013A0              ;Z ?ABORT   f c-addr u --      abort & print
                                msg
   1012    0013A0              ;   ROT IF ITYPE ABORT THEN 2DROP ;
   1013    0013A0                  HEADER  QABORT,6,'?ABORT',DOCOLON
   1013.1  000000                      PUBLIC  QABORT
   1013.2  0013A0 ....                 DW      link
   1013.3  0013A2 FF                   DB      0FFh       ; not immediate
   1013.4  0013A3              link    SET     $
   1013.5  0013A3 06                   DB      6
   1013.6  0013A4 3F41424F5254         DB      '?ABORT'
   1013.7  0013AA                      EVEN
   1013.8  0013AA                      IF      'DOCOLON'='DOCODE'
   1013.9  0013AA              QABORT: DW     $+2
   1013.10 0013AA                      ELSE
   1013.11 0013AA ....         QABORT: DW      DOCOLON
   1013.12 0013AC                      ENDIF
   1013.13 0013AC                      ENDM
   1014    0013AC ........             DW ROT,qbran
   1015    0013B0                      DEST  QABO1
   1015.1  0013B0 0600                 DW      QABO1-$
   1015.2  0013B2                      ENDM
   1016    0013B2 ........             DW ITYPE,ABORT
   1017    0013B6 ........     QABO1:  DW TWODROP,EXIT
   1018    0013BA              
   1019    0013BA              ;C ABORT"   i*x 0 -- i*x R: j*x -- j*x     
                                x1=0
   1020    0013BA              ;C ABORT"   i*x x1 -- R: j*x --            
                                x1<>0
   1021    0013BA              ;   POSTPONE IS" POSTPONE ?ABORT ; IMMEDIATE
   1022    0013BA                  IMMED  ABORTQUOTE,6,'ABORT"',DOCOLON
   1022.1  000000                      PUBLIC  ABORTQUOTE
   1022.2  0013BA ....                 DW      link
   1022.3  0013BC FE                   DB      0FEh      // ; immediate
                                                                         (LSB=0
                                                                        )
   1022.4  0013BD              link    SET     $
   1022.5  0013BD 06                   DB      6
   1022.6  0013BE 41424F525422         DB      'ABORT"'
   1022.7  0013C4                      EVEN
   1022.8  0013C4                      IF      'DOCOLON'='DOCODE'
   1022.9  0013C4              ABORTQUOTE: DW     $+2
   1022.10 0013C4                      ELSE
   1022.11 0013C4 ....         ABORTQUOTE: DW      DOCOLON
   1022.12 0013C6                      ENDIF
   1022.13 0013C6                      ENDM
   1023    0013C6 ....                 DW ISQUOTE
   1024    0013C8 ............         DW lit,QABORT,COMMAXT
   1025    0013CE ....                 DW EXIT
   1026    0013D0              
   1027    0013D0              ;C '    -- xt           find word in dictionary
   1028    0013D0              ;   BL WORD CAPITALIZE FIND
   1029    0013D0              ;   0= ABORT" ?" ;
   1030    0013D0                  HEADER  TICK,1,27h,DOCOLON
   1030.1  000000                      PUBLIC  TICK
   1030.2  0013D0 ....                 DW      link
   1030.3  0013D2 FF                   DB      0FFh       ; not immediate
   1030.4  0013D3              link    SET     $
   1030.5  0013D3 01                   DB      1
   1030.6  0013D4 27                   DB      27h
   1030.7  0013D5 00                   EVEN
   1030.8  0013D6                      IF      'DOCOLON'='DOCODE'
   1030.9  0013D6              TICK: DW     $+2
   1030.10 0013D6                      ELSE
   1030.11 0013D6 ....         TICK: DW      DOCOLON
   1030.12 0013D8                      ENDIF
   1030.13 0013D8                      ENDM
   1031    0013D8 ............*        DW BLANK,WORDD,CAPITALIZE,FIND,ZEROEQUAL
                                           ,XISQUOTE
   1032    0013E4 013F                 DB 1,'?'
   1033    0013E6 ........             DW QABORT,EXIT
   1034    0013EA              
   1035    0013EA              ;C CHAR   -- char           parse ASCII
                                character
   1036    0013EA              ;   BL WORD 1+ C@ ;
   1037    0013EA                  HEADER  CHARR,4,'CHAR',DOCOLON
   1037.1  000000                      PUBLIC  CHARR
   1037.2  0013EA ....                 DW      link
   1037.3  0013EC FF                   DB      0FFh       ; not immediate
   1037.4  0013ED              link    SET     $
   1037.5  0013ED 04                   DB      4
   1037.6  0013EE 43484152             DB      'CHAR'
   1037.7  0013F2                      EVEN
   1037.8  0013F2                      IF      'DOCOLON'='DOCODE'
   1037.9  0013F2              CHARR: DW     $+2
   1037.10 0013F2                      ELSE
   1037.11 0013F2 ....         CHARR: DW      DOCOLON
   1037.12 0013F4                      ENDIF
   1037.13 0013F4                      ENDM
   1038    0013F4 ............*        DW BLANK,WORDD,ONEPLUS,CFETCH,EXIT
   1039    0013FE              
   1040    0013FE              ;C [CHAR]   --          compile character
                                literal
   1041    0013FE              ;   CHAR  ['] LIT ,XT  I, ; IMMEDIATE
   1042    0013FE                  IMMED  BRACCHAR,6,'[CHAR]',DOCOLON
   1042.1  000000                      PUBLIC  BRACCHAR
   1042.2  0013FE ....                 DW      link
   1042.3  001400 FE                   DB      0FEh      // ; immediate
                                                                       (LSB=0)
   1042.4  001401              link    SET     $
   1042.5  001401 06                   DB      6
   1042.6  001402 5B434841525D         DB      '[CHAR]'
   1042.7  001408                      EVEN
   1042.8  001408                      IF      'DOCOLON'='DOCODE'
   1042.9  001408              BRACCHAR: DW     $+2
   1042.10 001408                      ELSE
   1042.11 001408 ....         BRACCHAR: DW      DOCOLON
   1042.12 00140A                      ENDIF
   1042.13 00140A                      ENDM
   1043    00140A ....                 DW CHARR
   1044    00140C ............         DW lit,lit,COMMAXT
   1045    001412 ........             DW ICOMMA,EXIT
   1046    001416              
   1047    001416              ;C (    --                     skip input until
                                )
   1048    001416              ;   [ HEX ] 29 WORD DROP ; IMMEDIATE
   1049    001416                  IMMED  PAREN,1,'(',DOCOLON
   1049.1  000000                      PUBLIC  PAREN
   1049.2  001416 ....                 DW      link
   1049.3  001418 FE                   DB      0FEh      // ; immediate
                                                               (LSB=0)
   1049.4  001419              link    SET     $
   1049.5  001419 01                   DB      1
   1049.6  00141A 28                   DB      '('
   1049.7  00141B 00                   EVEN
   1049.8  00141C                      IF      'DOCOLON'='DOCODE'
   1049.9  00141C              PAREN: DW     $+2
   1049.10 00141C                      ELSE
   1049.11 00141C ....         PAREN: DW      DOCOLON
   1049.12 00141E                      ENDIF
   1049.13 00141E                      ENDM
   1050    00141E ....2900....*        DW lit,29H,WORDD,DROP,EXIT
   1051    001428              
   1052    001428              ; COMPILER =====================================
                               =
   1053    001428              
   1054    001428              ;Z HEADER   --      create a Forth word
                                header
   1055    001428              ;   LATEST @ H, 0FF HC,         link & IMMED 
                                field
   1056    001428              ;   HHERE LATEST !            new "latest"
                                link
   1057    001428              ;   BL HWORD HC@ 1+ HALLOT    name field
   1058    001428              ;   ALIGN ;
   1059    001428              ; Separate headers model.
   1060    001428                  HEADER  HEADR,6,'HEADER',DOCOLON
   1060.1  000000                      PUBLIC  HEADR
   1060.2  001428 ....                 DW      link
   1060.3  00142A FF                   DB      0FFh       ; not immediate
   1060.4  00142B              link    SET     $
   1060.5  00142B 06                   DB      6
   1060.6  00142C 484541444552         DB      'HEADER'
   1060.7  001432                      EVEN
   1060.8  001432                      IF      'DOCOLON'='DOCODE'
   1060.9  001432              HEADR: DW     $+2
   1060.10 001432                      ELSE
   1060.11 001432 ....         HEADR: DW      DOCOLON
   1060.12 001434                      ENDIF
   1060.13 001434                      ENDM
   1061    001434 ............         DW LATEST,FETCH,HCOMMA      ; link
   1062    00143A ....FF00....         DW lit,0FFh,HCCOMMA         ; immediate
                                                                    flag - see
                                                                    note
                                                                    below
   1063    001440 ............         DW HHERE,LATEST,STORE
   1064    001446 ............*        DW BLANK,HWORD,HCFETCH,ONEPLUS,HALLOT
   1065    001450 ........             DW ALIGNN,EXIT   ; MSP430: headers in I
                                                         space must be
                                                         aligned
   1066    001454              ; Note for Flashable MSP430: when compiling to
                                RAM, we need to set
   1067    001454              ; the immediate byte to 0FFH.  When compiling to
                                Flash, the word IC!
   1068    001454              ; will not write 0FFH to erased Flash (because
                                the byte is already 0FFH).
   1069    001454              ; Thus we can write this byte at a later time
                                (with IMMEDIATE).
   1070    001454              
   1071    001454              ;Z <BUILDS  --      define a word with t.b.d.
                                action & no data
   1072    001454              ;   HEADER 2 IALLOT ;       Flashable: do not
                                store Code Field
   1073    001454                  HEADER  BUILDS,7,'<BUILDS',DOCOLON
   1073.1  000000                      PUBLIC  BUILDS
   1073.2  001454 ....                 DW      link
   1073.3  001456 FF                   DB      0FFh       ; not immediate
   1073.4  001457              link    SET     $
   1073.5  001457 07                   DB      7
   1073.6  001458 3C4255494C44*        DB      '<BUILDS'
   1073.7  00145F 00                   EVEN
   1073.8  001460                      IF      'DOCOLON'='DOCODE'
   1073.9  001460              BUILDS: DW     $+2
   1073.10 001460                      ELSE
   1073.11 001460 ....         BUILDS: DW      DOCOLON
   1073.12 001462                      ENDIF
   1073.13 001462                      ENDM
   1074    001462 ........0200*        DW HEADR,lit,2,IALLOT,EXIT
   1075    00146C              
   1076    00146C              ;C CREATE   --      create an empty definition
   1077    00146C              ;   HEADER
   1078    00146C              ;   docreate ,CF              code field
   1079    00146C              ;   HERE I, ;           store data adr
                                (Harvard)
   1080    00146C              ; Harvard model, separate Code and Data
                                spaces.
   1081    00146C              ; Separate headers model.
   1082    00146C                  HEADER  CREATE,6,'CREATE',DOCOLON
   1082.1  000000                      PUBLIC  CREATE
   1082.2  00146C ....                 DW      link
   1082.3  00146E FF                   DB      0FFh       ; not immediate
   1082.4  00146F              link    SET     $
   1082.5  00146F 06                   DB      6
   1082.6  001470 435245415445         DB      'CREATE'
   1082.7  001476                      EVEN
   1082.8  001476                      IF      'DOCOLON'='DOCODE'
   1082.9  001476              CREATE: DW     $+2
   1082.10 001476                      ELSE
   1082.11 001476 ....         CREATE: DW      DOCOLON
   1082.12 001478                      ENDIF
   1082.13 001478                      ENDM
   1083    001478 ....                 DW HEADR
   1084    00147A ............         DW lit,docreate,COMMACF
   1085    001480 ............         DW HERE,ICOMMA,EXIT
   1086    001486              
   1087    001486              ;Z (DOES>)  --      run-time action of
                                DOES>
   1088    001486              ;   R>              adrs of headless DOES>
                                def'n
   1089    001486              ;   LATEST @ NFA>CFA    code field to fix
                                up
   1090    001486              ;   !CF ;
   1091    001486                  HEADER  XDOES,7,'(DOES>)',DOCOLON
   1091.1  000000                      PUBLIC  XDOES
   1091.2  001486 ....                 DW      link
   1091.3  001488 FF                   DB      0FFh       ; not immediate
   1091.4  001489              link    SET     $
   1091.5  001489 07                   DB      7
   1091.6  00148A 28444F45533E*        DB      '(DOES>)'
   1091.7  001491 00                   EVEN
   1091.8  001492                      IF      'DOCOLON'='DOCODE'
   1091.9  001492              XDOES: DW     $+2
   1091.10 001492                      ELSE
   1091.11 001492 ....         XDOES: DW      DOCOLON
   1091.12 001494                      ENDIF
   1091.13 001494                      ENDM
   1092    001494 ............*        DW RFROM,LATEST,FETCH,NFATOCFA,STORECF
   1093    00149E ....                 DW EXIT
   1094    0014A0              
   1095    0014A0              ;C DOES>    --      change action of latest
                                def'n
   1096    0014A0              ;   COMPILE (DOES>)
   1097    0014A0              ;   dodoes ,JMP ; IMMEDIATE
   1098    0014A0              ; Note that MSP430 uses a JMP, not a CALL, to
                                DODOES.
   1099    0014A0                  IMMED  DOES,5,'DOES>',DOCOLON
   1099.1  000000                      PUBLIC  DOES
   1099.2  0014A0 ....                 DW      link
   1099.3  0014A2 FE                   DB      0FEh      // ; immediate
                                                                  (LSB=0)
   1099.4  0014A3              link    SET     $
   1099.5  0014A3 05                   DB      5
   1099.6  0014A4 444F45533E           DB      'DOES>'
   1099.7  0014A9 00                   EVEN
   1099.8  0014AA                      IF      'DOCOLON'='DOCODE'
   1099.9  0014AA              DOES: DW     $+2
   1099.10 0014AA                      ELSE
   1099.11 0014AA ....         DOES: DW      DOCOLON
   1099.12 0014AC                      ENDIF
   1099.13 0014AC                      ENDM
   1100    0014AC ............         DW lit,XDOES,COMMAXT
   1101    0014B2 ............*        DW lit,dodoes,COMMAJMP,EXIT
   1102    0014BA              
   1103    0014BA              ;C RECURSE  --      recurse current definition
   1104    0014BA              ;   LATEST @ NFA>CFA ,XT ; IMMEDIATE
   1105    0014BA              ;   NEWEST @ NFA>CFA ,XT ; IMMEDIATE  
                                Flashable
   1106    0014BA                  IMMED  RECURSE,7,'RECURSE',DOCOLON
   1106.1  000000                      PUBLIC  RECURSE
   1106.2  0014BA ....                 DW      link
   1106.3  0014BC FE                   DB      0FEh      // ; immediate
                                                                       (LSB=0)
   1106.4  0014BD              link    SET     $
   1106.5  0014BD 07                   DB      7
   1106.6  0014BE 524543555253*        DB      'RECURSE'
   1106.7  0014C5 00                   EVEN
   1106.8  0014C6                      IF      'DOCOLON'='DOCODE'
   1106.9  0014C6              RECURSE: DW     $+2
   1106.10 0014C6                      ELSE
   1106.11 0014C6 ....         RECURSE: DW      DOCOLON
   1106.12 0014C8                      ENDIF
   1106.13 0014C8                      ENDM
   1107    0014C8 ............*        DW NEWEST,FETCH,NFATOCFA,COMMAXT,EXIT
   1108    0014D2              
   1109    0014D2              ;C [        --      enter interpretive
                                state
   1110    0014D2              ;   0 STATE ! ; IMMEDIATE
   1111    0014D2                  IMMED  LEFTBRACKET,1,'[',DOCOLON
   1111.1  000000                      PUBLIC  LEFTBRACKET
   1111.2  0014D2 ....                 DW      link
   1111.3  0014D4 FE                   DB      0FEh      // ; immediate
                                                                     (LSB=0)
   1111.4  0014D5              link    SET     $
   1111.5  0014D5 01                   DB      1
   1111.6  0014D6 5B                   DB      '['
   1111.7  0014D7 00                   EVEN
   1111.8  0014D8                      IF      'DOCOLON'='DOCODE'
   1111.9  0014D8              LEFTBRACKET: DW     $+2
   1111.10 0014D8                      ELSE
   1111.11 0014D8 ....         LEFTBRACKET: DW      DOCOLON
   1111.12 0014DA                      ENDIF
   1111.13 0014DA                      ENDM
   1112    0014DA ............*        DW ZERO,STATE,STORE,EXIT
   1113    0014E2              
   1114    0014E2              ;C ]        --      enter compiling state
   1115    0014E2              ;   -1 STATE ! ;
   1116    0014E2                  HEADER  RIGHTBRACKET,1,']',DOCOLON
   1116.1  000000                      PUBLIC  RIGHTBRACKET
   1116.2  0014E2 ....                 DW      link
   1116.3  0014E4 FF                   DB      0FFh       ; not immediate
   1116.4  0014E5              link    SET     $
   1116.5  0014E5 01                   DB      1
   1116.6  0014E6 5D                   DB      ']'
   1116.7  0014E7 00                   EVEN
   1116.8  0014E8                      IF      'DOCOLON'='DOCODE'
   1116.9  0014E8              RIGHTBRACKET: DW     $+2
   1116.10 0014E8                      ELSE
   1116.11 0014E8 ....         RIGHTBRACKET: DW      DOCOLON
   1116.12 0014EA                      ENDIF
   1116.13 0014EA                      ENDM
   1117    0014EA ....FFFF....*        DW lit,-1,STATE,STORE,EXIT
   1118    0014F4              
   1119    0014F4              ;Z HIDE     --      "hide" latest definition   
                                Flashable
   1120    0014F4              ;   LATEST @ DUP NEWEST !  NFA>LFA H@ LATEST !
                                ;
   1121    0014F4                  HEADER  HIDE,4,'HIDE',DOCOLON
   1121.1  000000                      PUBLIC  HIDE
   1121.2  0014F4 ....                 DW      link
   1121.3  0014F6 FF                   DB      0FFh       ; not immediate
   1121.4  0014F7              link    SET     $
   1121.5  0014F7 04                   DB      4
   1121.6  0014F8 48494445             DB      'HIDE'
   1121.7  0014FC                      EVEN
   1121.8  0014FC                      IF      'DOCOLON'='DOCODE'
   1121.9  0014FC              HIDE: DW     $+2
   1121.10 0014FC                      ELSE
   1121.11 0014FC ....         HIDE: DW      DOCOLON
   1121.12 0014FE                      ENDIF
   1121.13 0014FE                      ENDM
   1122    0014FE ............*        DW LATEST,FETCH,DUP,NEWEST,STORE
   1123    001508 ............*        DW NFATOLFA,HFETCH,LATEST,STORE,EXIT
   1124    001512              
   1125    001512              ;Z REVEAL   --      "reveal" latest definition 
                                Flashable
   1126    001512              ;   NEWEST @ LATEST ! ;
   1127    001512                  HEADER  REVEAL,6,'REVEAL',DOCOLON
   1127.1  000000                      PUBLIC  REVEAL
   1127.2  001512 ....                 DW      link
   1127.3  001514 FF                   DB      0FFh       ; not immediate
   1127.4  001515              link    SET     $
   1127.5  001515 06                   DB      6
   1127.6  001516 52455645414C         DB      'REVEAL'
   1127.7  00151C                      EVEN
   1127.8  00151C                      IF      'DOCOLON'='DOCODE'
   1127.9  00151C              REVEAL: DW     $+2
   1127.10 00151C                      ELSE
   1127.11 00151C ....         REVEAL: DW      DOCOLON
   1127.12 00151E                      ENDIF
   1127.13 00151E                      ENDM
   1128    00151E ............*        DW NEWEST,FETCH,LATEST,STORE,EXIT
   1129    001528              
   1130    001528              ;C IMMEDIATE   --   make last def'n immediate
   1131    001528              ;   0FE LATEST @ 1- HC! ;   set Flashable
                                immediate flag
   1132    001528                  HEADER  IMMEDIATE,9,'IMMEDIATE',DOCOLON
   1132.1  000000                      PUBLIC  IMMEDIATE
   1132.2  001528 ....                 DW      link
   1132.3  00152A FF                   DB      0FFh       ; not immediate
   1132.4  00152B              link    SET     $
   1132.5  00152B 09                   DB      9
   1132.6  00152C 494D4D454449*        DB      'IMMEDIATE'
   1132.7  001535 00                   EVEN
   1132.8  001536                      IF      'DOCOLON'='DOCODE'
   1132.9  001536              IMMEDIATE: DW     $+2
   1132.10 001536                      ELSE
   1132.11 001536 ....         IMMEDIATE: DW      DOCOLON
   1132.12 001538                      ENDIF
   1132.13 001538                      ENDM
   1133    001538 ....FE00....*        DW lit,0FEh,LATEST,FETCH,ONEMINUS,HCSTOR
                                           E
   1134    001544 ....                 DW EXIT
   1135    001546              
   1136    001546              ;C :        --      begin a colon definition 
                                
   1137    001546              ;   <BUILDS HIDE ] !COLON ;      Flashable
                                version
   1138    001546                  HEADER  COLON,1,':',DOCOLON
   1138.1  000000                      PUBLIC  COLON
   1138.2  001546 ....                 DW      link
   1138.3  001548 FF                   DB      0FFh       ; not immediate
   1138.4  001549              link    SET     $
   1138.5  001549 01                   DB      1
   1138.6  00154A 3A                   DB      ':'
   1138.7  00154B 00                   EVEN
   1138.8  00154C                      IF      'DOCOLON'='DOCODE'
   1138.9  00154C              COLON: DW     $+2
   1138.10 00154C                      ELSE
   1138.11 00154C ....         COLON: DW      DOCOLON
   1138.12 00154E                      ENDIF
   1138.13 00154E                      ENDM
   1139    00154E ............*        DW BUILDS,HIDE,RIGHTBRACKET,STORCOLON
   1140    001556 ....                 DW EXIT
   1141    001558              
   1142    001558              ;C ;       --       end a colon definition
                                
   1143    001558              ;   REVEAL  ,EXIT
   1144    001558              ;   POSTPONE [  ; IMMEDIATE
   1145    001558                  IMMED  SEMICOLON,1,';',DOCOLON
   1145.1  000000                      PUBLIC  SEMICOLON
   1145.2  001558 ....                 DW      link
   1145.3  00155A FE                   DB      0FEh      // ; immediate
                                                             (LSB=0)
   1145.4  00155B              link    SET     $
   1145.5  00155B 01                   DB      1
   1145.6  00155C 3B                   DB      ';'
   1145.7  00155D 00                   EVEN
   1145.8  00155E                      IF      'DOCOLON'='DOCODE'
   1145.9  00155E              SEMICOLON: DW     $+2
   1145.10 00155E                      ELSE
   1145.11 00155E ....         SEMICOLON: DW      DOCOLON
   1145.12 001560                      ENDIF
   1145.13 001560                      ENDM
   1146    001560 ........             DW REVEAL,CEXIT
   1147    001564 ........             DW LEFTBRACKET,EXIT
   1148    001568              
   1149    001568              ;C [']  --         find word & compile as
                                literal
   1150    001568              ;   '  ['] LIT ,XT  I, ; IMMEDIATE
   1151    001568              ; When encountered in a colon definition,
                                the
   1152    001568              ; phrase  ['] xxx  will cause   LIT,xxt  to
                                be
   1153    001568              ; compiled into the colon definition (where
   1154    001568              ; (where xxt is the execution token of word
                                xxx).
   1155    001568              ; When the colon definition executes, xxt
                                will
   1156    001568              ; be put on the stack.  (All xt's are one
                                cell.)
   1157    001568                  IMMED  BRACTICK,3,'[\']',DOCOLON
   1157.1  000000                      PUBLIC  BRACTICK
   1157.2  001568 ....                 DW      link
   1157.3  00156A FE                   DB      0FEh      // ; immediate
                                                                     (LSB=0)
   1157.4  00156B              link    SET     $
   1157.5  00156B 03                   DB      3
   1157.6  00156C 5B275D               DB      '[\']'
   1157.7  00156F 00                   EVEN
   1157.8  001570                      IF      'DOCOLON'='DOCODE'
   1157.9  001570              BRACTICK: DW     $+2
   1157.10 001570                      ELSE
   1157.11 001570 ....         BRACTICK: DW      DOCOLON
   1157.12 001572                      ENDIF
   1157.13 001572                      ENDM
   1158    001572 ....                 DW TICK               ; get xt of
                                                              'xxx'
   1159    001574 ............         DW lit,lit,COMMAXT    ; append LIT
                                                              action
   1160    00157A ........             DW ICOMMA,EXIT        ; append xt
                                                              literal
   1161    00157E              
   1162    00157E              ;C POSTPONE  --   postpone compile action of
                                word
   1163    00157E              ;   BL WORD FIND
   1164    00157E              ;   DUP 0= ABORT" ?"
   1165    00157E              ;   0< IF   -- xt  non immed: add code to
                                current
   1166    00157E              ;                  def'n to compile xt
                                later.
   1167    00157E              ;       ['] LIT ,XT  I,     add "LIT,xt,COMMAXT"
   1168    00157E              ;       ['] ,XT ,XT         to current
                                definition
   1169    00157E              ;   ELSE  ,XT      immed: compile into cur.
                                def'n
   1170    00157E              ;   THEN ; IMMEDIATE
   1171    00157E                  IMMED  POSTPONE,8,'POSTPONE',DOCOLON
   1171.1  000000                      PUBLIC  POSTPONE
   1171.2  00157E ....                 DW      link
   1171.3  001580 FE                   DB      0FEh      // ; immediate
                                                                         (LSB=0
                                                                        )
   1171.4  001581              link    SET     $
   1171.5  001581 08                   DB      8
   1171.6  001582 504F5354504F*        DB      'POSTPONE'
   1171.7  00158A                      EVEN
   1171.8  00158A                      IF      'DOCOLON'='DOCODE'
   1171.9  00158A              POSTPONE: DW     $+2
   1171.10 00158A                      ELSE
   1171.11 00158A ....         POSTPONE: DW      DOCOLON
   1171.12 00158C                      ENDIF
   1171.13 00158C                      ENDM
   1172    00158C ............*        DW BLANK,WORDD,FIND,DUP,ZEROEQUAL,XISQUO
                                           TE
   1173    001598 013F                 DB 1,'?'
   1174    00159A ............         DW QABORT,ZEROLESS,qbran
   1175    0015A0                      DEST  POST1
   1175.1  0015A0 1400                 DW      POST1-$
   1175.2  0015A2                      ENDM
   1176    0015A2 ............*        DW lit,lit,COMMAXT,ICOMMA
   1177    0015AA ............*        DW lit,COMMAXT,COMMAXT,bran
   1178    0015B2                      DEST  POST2
   1178.1  0015B2 0400                 DW      POST2-$
   1178.2  0015B4                      ENDM
   1179    0015B4 ....         POST1:  DW COMMAXT
   1180    0015B6 ....         POST2:  DW EXIT
   1181    0015B8              
   1182    0015B8              ;Z COMPILE   --   append inline execution
                                token
   1183    0015B8              ;   R> DUP CELL+ >R @ ,XT ;
   1184    0015B8              ; The phrase ['] xxx ,XT appears so often
                                that
   1185    0015B8              ; this word was created to combine the
                                actions
   1186    0015B8              ; of LIT and ,XT.  It takes an inline literal
   1187    0015B8              ; execution token and appends it to the
                                dict.
   1188    0015B8              ;    HEADER  COMPILE,7,'COMPILE',DOCOLON
   1189    0015B8              ;        DW RFROM,DUP,CELLPLUS,TOR
   1190    0015B8              ;        DW FETCH,COMMAXT,EXIT
   1191    0015B8              ; N.B.: not used in the current implementation
   1192    0015B8              
   1193    0015B8              ; CONTROL STRUCTURES ===========================
                               =
   1194    0015B8              
   1195    0015B8              ;C IF       -- adrs    conditional forward
                                branch
   1196    0015B8              ;   ['] qbran ,BRANCH  IHERE ,NONE ;     
                                Flashable
   1197    0015B8              ;   IMMEDIATE
   1198    0015B8                  IMMED  IFF,2,'IF',DOCOLON
   1198.1  000000                      PUBLIC  IFF
   1198.2  0015B8 ....                 DW      link
   1198.3  0015BA FE                   DB      0FEh      // ; immediate
                                                               (LSB=0)
   1198.4  0015BB              link    SET     $
   1198.5  0015BB 02                   DB      2
   1198.6  0015BC 4946                 DB      'IF'
   1198.7  0015BE                      EVEN
   1198.8  0015BE                      IF      'DOCOLON'='DOCODE'
   1198.9  0015BE              IFF: DW     $+2
   1198.10 0015BE                      ELSE
   1198.11 0015BE ....         IFF: DW      DOCOLON
   1198.12 0015C0                      ENDIF
   1198.13 0015C0                      ENDM
   1199    0015C0 ............         DW lit,qbran,COMMABRANCH
   1200    0015C6 ............         DW IHERE,COMMANONE,EXIT
   1201    0015CC              
   1202    0015CC              ;C THEN     adrs --        resolve forward
                                branch
   1203    0015CC              ;   IHERE SWAP !DEST ; IMMEDIATE
   1204    0015CC                  IMMED  THEN,4,'THEN',DOCOLON
   1204.1  000000                      PUBLIC  THEN
   1204.2  0015CC ....                 DW      link
   1204.3  0015CE FE                   DB      0FEh      // ; immediate
                                                                 (LSB=0)
   1204.4  0015CF              link    SET     $
   1204.5  0015CF 04                   DB      4
   1204.6  0015D0 5448454E             DB      'THEN'
   1204.7  0015D4                      EVEN
   1204.8  0015D4                      IF      'DOCOLON'='DOCODE'
   1204.9  0015D4              THEN: DW     $+2
   1204.10 0015D4                      ELSE
   1204.11 0015D4 ....         THEN: DW      DOCOLON
   1204.12 0015D6                      ENDIF
   1204.13 0015D6                      ENDM
   1205    0015D6 ............*        DW IHERE,SWAP,STOREDEST,EXIT
   1206    0015DE              
   1207    0015DE              ;C ELSE     adrs1 -- adrs2    branch for
                                IF..ELSE
   1208    0015DE              ;   ['] branch ,BRANCH  IHERE ,NONE      
                                Flashable
   1209    0015DE              ;   SWAP  POSTPONE THEN ; IMMEDIATE
   1210    0015DE                  IMMED  ELSS,4,'ELSE',DOCOLON
   1210.1  000000                      PUBLIC  ELSS
   1210.2  0015DE ....                 DW      link
   1210.3  0015E0 FE                   DB      0FEh      // ; immediate
                                                                 (LSB=0)
   1210.4  0015E1              link    SET     $
   1210.5  0015E1 04                   DB      4
   1210.6  0015E2 454C5345             DB      'ELSE'
   1210.7  0015E6                      EVEN
   1210.8  0015E6                      IF      'DOCOLON'='DOCODE'
   1210.9  0015E6              ELSS: DW     $+2
   1210.10 0015E6                      ELSE
   1210.11 0015E6 ....         ELSS: DW      DOCOLON
   1210.12 0015E8                      ENDIF
   1210.13 0015E8                      ENDM
   1211    0015E8 ............         DW lit,bran,COMMABRANCH
   1212    0015EE ........             DW IHERE,COMMANONE
   1213    0015F2 ............         DW SWAP,THEN,EXIT
   1214    0015F8              
   1215    0015F8              ;C BEGIN    -- adrs        target for bwd.
                                branch
   1216    0015F8              ;   IHERE ; IMMEDIATE
   1217    0015F8                  IMMED  BEGIN,5,'BEGIN',DOCOLON
   1217.1  000000                      PUBLIC  BEGIN
   1217.2  0015F8 ....                 DW      link
   1217.3  0015FA FE                   DB      0FEh      // ; immediate
                                                                   (LSB=0)
   1217.4  0015FB              link    SET     $
   1217.5  0015FB 05                   DB      5
   1217.6  0015FC 424547494E           DB      'BEGIN'
   1217.7  001601 00                   EVEN
   1217.8  001602                      IF      'DOCOLON'='DOCODE'
   1217.9  001602              BEGIN: DW     $+2
   1217.10 001602                      ELSE
   1217.11 001602 ....         BEGIN: DW      DOCOLON
   1217.12 001604                      ENDIF
   1217.13 001604                      ENDM
   1218    001604 ........             DW IHERE,EXIT
   1219    001608              
   1220    001608              ;C UNTIL    adrs --   conditional backward
                                branch
   1221    001608              ;   ['] qbran ,BRANCH  ,DEST ; IMMEDIATE
   1222    001608              ;   conditional backward branch
   1223    001608                  IMMED  UNTIL,5,'UNTIL',DOCOLON
   1223.1  000000                      PUBLIC  UNTIL
   1223.2  001608 ....                 DW      link
   1223.3  00160A FE                   DB      0FEh      // ; immediate
                                                                   (LSB=0)
   1223.4  00160B              link    SET     $
   1223.5  00160B 05                   DB      5
   1223.6  00160C 554E54494C           DB      'UNTIL'
   1223.7  001611 00                   EVEN
   1223.8  001612                      IF      'DOCOLON'='DOCODE'
   1223.9  001612              UNTIL: DW     $+2
   1223.10 001612                      ELSE
   1223.11 001612 ....         UNTIL: DW      DOCOLON
   1223.12 001614                      ENDIF
   1223.13 001614                      ENDM
   1224    001614 ............         DW lit,qbran,COMMABRANCH
   1225    00161A ........             DW COMMADEST,EXIT
   1226    00161E              
   1227    00161E              ;X AGAIN    adrs --      uncond'l backward
                                branch
   1228    00161E              ;   ['] branch ,BRANCH  ,DEST ; IMMEDIATE
   1229    00161E              ;   unconditional backward branch
   1230    00161E                  IMMED  AGAIN,5,'AGAIN',DOCOLON
   1230.1  000000                      PUBLIC  AGAIN
   1230.2  00161E ....                 DW      link
   1230.3  001620 FE                   DB      0FEh      // ; immediate
                                                                   (LSB=0)
   1230.4  001621              link    SET     $
   1230.5  001621 05                   DB      5
   1230.6  001622 414741494E           DB      'AGAIN'
   1230.7  001627 00                   EVEN
   1230.8  001628                      IF      'DOCOLON'='DOCODE'
   1230.9  001628              AGAIN: DW     $+2
   1230.10 001628                      ELSE
   1230.11 001628 ....         AGAIN: DW      DOCOLON
   1230.12 00162A                      ENDIF
   1230.13 00162A                      ENDM
   1231    00162A ............         DW lit,bran,COMMABRANCH
   1232    001630 ........             DW COMMADEST,EXIT
   1233    001634              
   1234    001634              ;C WHILE    adrs1 -- adrs2 adrs1          
                                branch for WHILE loop
   1235    001634              ;   POSTPONE IF SWAP ; IMMEDIATE
   1236    001634                  IMMED  WHILE,5,'WHILE',DOCOLON
   1236.1  000000                      PUBLIC  WHILE
   1236.2  001634 ....                 DW      link
   1236.3  001636 FE                   DB      0FEh      // ; immediate
                                                                   (LSB=0)
   1236.4  001637              link    SET     $
   1236.5  001637 05                   DB      5
   1236.6  001638 5748494C45           DB      'WHILE'
   1236.7  00163D 00                   EVEN
   1236.8  00163E                      IF      'DOCOLON'='DOCODE'
   1236.9  00163E              WHILE: DW     $+2
   1236.10 00163E                      ELSE
   1236.11 00163E ....         WHILE: DW      DOCOLON
   1236.12 001640                      ENDIF
   1236.13 001640                      ENDM
   1237    001640 ............         DW IFF,SWAP,EXIT
   1238    001646              
   1239    001646              ;C REPEAT   adrs2 adrs1 --            resolve
                                WHILE loop
   1240    001646              ;   POSTPONE AGAIN POSTPONE THEN ; IMMEDIATE
   1241    001646                  IMMED  REPEAT,6,'REPEAT',DOCOLON
   1241.1  000000                      PUBLIC  REPEAT
   1241.2  001646 ....                 DW      link
   1241.3  001648 FE                   DB      0FEh      // ; immediate
                                                                     (LSB=0)
   1241.4  001649              link    SET     $
   1241.5  001649 06                   DB      6
   1241.6  00164A 524550454154         DB      'REPEAT'
   1241.7  001650                      EVEN
   1241.8  001650                      IF      'DOCOLON'='DOCODE'
   1241.9  001650              REPEAT: DW     $+2
   1241.10 001650                      ELSE
   1241.11 001650 ....         REPEAT: DW      DOCOLON
   1241.12 001652                      ENDIF
   1241.13 001652                      ENDM
   1242    001652 ............         DW AGAIN,THEN,EXIT
   1243    001658              
   1244    001658              ;Z >L   x -- L: -- x        move to leave
                                stack
   1245    001658              ;   CELL LP +!  LP @ ! ;      (L stack grows
                                up)
   1246    001658                  HEADER  TOL,2,'>L',DOCOLON
   1246.1  000000                      PUBLIC  TOL
   1246.2  001658 ....                 DW      link
   1246.3  00165A FF                   DB      0FFh       ; not immediate
   1246.4  00165B              link    SET     $
   1246.5  00165B 02                   DB      2
   1246.6  00165C 3E4C                 DB      '>L'
   1246.7  00165E                      EVEN
   1246.8  00165E                      IF      'DOCOLON'='DOCODE'
   1246.9  00165E              TOL: DW     $+2
   1246.10 00165E                      ELSE
   1246.11 00165E ....         TOL: DW      DOCOLON
   1246.12 001660                      ENDIF
   1246.13 001660                      ENDM
   1247    001660 ............*        DW CELL,LP,PLUSSTORE,LP,FETCH,STORE,EXIT
   1248    00166E              
   1249    00166E              ;Z L>   -- x L: x --      move from leave
                                stack
   1250    00166E              ;   LP @ @  CELL NEGATE LP +! ;
   1251    00166E                  HEADER  LFROM,2,'L>',DOCOLON
   1251.1  000000                      PUBLIC  LFROM
   1251.2  00166E ....                 DW      link
   1251.3  001670 FF                   DB      0FFh       ; not immediate
   1251.4  001671              link    SET     $
   1251.5  001671 02                   DB      2
   1251.6  001672 4C3E                 DB      'L>'
   1251.7  001674                      EVEN
   1251.8  001674                      IF      'DOCOLON'='DOCODE'
   1251.9  001674              LFROM: DW     $+2
   1251.10 001674                      ELSE
   1251.11 001674 ....         LFROM: DW      DOCOLON
   1251.12 001676                      ENDIF
   1251.13 001676                      ENDM
   1252    001676 ............         DW LP,FETCH,FETCH
   1253    00167C ............*        DW CELL,NEGATE,LP,PLUSSTORE,EXIT
   1254    001686              
   1255    001686              ;C DO       -- adrs L: -- 0       start a loop
                                
   1256    001686              ;   ['] xdo ,XT   IHERE     target for bwd
                                branch
   1257    001686              ;   0 >L ; IMMEDIATE           marker for
                                LEAVEs
   1258    001686                  IMMED  DO,2,'DO',DOCOLON
   1258.1  000000                      PUBLIC  DO
   1258.2  001686 ....                 DW      link
   1258.3  001688 FE                   DB      0FEh      // ; immediate
                                                             (LSB=0)
   1258.4  001689              link    SET     $
   1258.5  001689 02                   DB      2
   1258.6  00168A 444F                 DB      'DO'
   1258.7  00168C                      EVEN
   1258.8  00168C                      IF      'DOCOLON'='DOCODE'
   1258.9  00168C              DO: DW     $+2
   1258.10 00168C                      ELSE
   1258.11 00168C ....         DO: DW      DOCOLON
   1258.12 00168E                      ENDIF
   1258.13 00168E                      ENDM
   1259    00168E ............*        DW lit,xdo,COMMAXT,IHERE
   1260    001696 ............         DW ZERO,TOL,EXIT
   1261    00169C              
   1262    00169C              ;Z ENDLOOP   adrs xt -- L: 0 a1 a2 .. aN --  
                                common factor of LOOP and +LOOP
   1263    00169C              ;   ,BRANCH  ,DEST                backward
                                loop
   1264    00169C              ;   BEGIN L> ?DUP WHILE POSTPONE THEN REPEAT
                                ;
   1265    00169C              ;                                 resolve
                                LEAVEs
   1266    00169C              ; This is a common factor of LOOP and +LOOP.
   1267    00169C                  HEADER  ENDLOOP,7,'ENDLOOP',DOCOLON
   1267.1  000000                      PUBLIC  ENDLOOP
   1267.2  00169C ....                 DW      link
   1267.3  00169E FF                   DB      0FFh       ; not immediate
   1267.4  00169F              link    SET     $
   1267.5  00169F 07                   DB      7
   1267.6  0016A0 454E444C4F4F*        DB      'ENDLOOP'
   1267.7  0016A7 00                   EVEN
   1267.8  0016A8                      IF      'DOCOLON'='DOCODE'
   1267.9  0016A8              ENDLOOP: DW     $+2
   1267.10 0016A8                      ELSE
   1267.11 0016A8 ....         ENDLOOP: DW      DOCOLON
   1267.12 0016AA                      ENDIF
   1267.13 0016AA                      ENDM
   1268    0016AA ........             DW COMMABRANCH,COMMADEST
   1269    0016AE ............ LOOP1:  DW LFROM,QDUP,qbran
   1270    0016B4                      DEST  LOOP2
   1270.1  0016B4 0800                 DW      LOOP2-$
   1270.2  0016B6                      ENDM
   1271    0016B6 ........             DW THEN,bran
   1272    0016BA                      DEST  LOOP1
   1272.1  0016BA F4FF                 DW      LOOP1-$
   1272.2  0016BC                      ENDM
   1273    0016BC ....         LOOP2:  DW EXIT
   1274    0016BE              
   1275    0016BE              ;C LOOP    adrs -- L: 0 a1 a2 .. aN --    finish
                                a loop
   1276    0016BE              ;   ['] xloop ENDLOOP ;  IMMEDIATE
   1277    0016BE                  IMMED  LOO,4,'LOOP',DOCOLON
   1277.1  000000                      PUBLIC  LOO
   1277.2  0016BE ....                 DW      link
   1277.3  0016C0 FE                   DB      0FEh      // ; immediate
                                                                (LSB=0)
   1277.4  0016C1              link    SET     $
   1277.5  0016C1 04                   DB      4
   1277.6  0016C2 4C4F4F50             DB      'LOOP'
   1277.7  0016C6                      EVEN
   1277.8  0016C6                      IF      'DOCOLON'='DOCODE'
   1277.9  0016C6              LOO: DW     $+2
   1277.10 0016C6                      ELSE
   1277.11 0016C6 ....         LOO: DW      DOCOLON
   1277.12 0016C8                      ENDIF
   1277.13 0016C8                      ENDM
   1278    0016C8 ............*        DW lit,xloop,ENDLOOP,EXIT
   1279    0016D0              
   1280    0016D0              ;C +LOOP   adrs -- L: 0 a1 a2 .. aN --    finish
                                a loop
   1281    0016D0              ;   ['] xplusloop ENDLOOP ;  IMMEDIATE
   1282    0016D0                  IMMED  PLUSLOOP,5,'+LOOP',DOCOLON
   1282.1  000000                      PUBLIC  PLUSLOOP
   1282.2  0016D0 ....                 DW      link
   1282.3  0016D2 FE                   DB      0FEh      // ; immediate
                                                                      (LSB=0)
   1282.4  0016D3              link    SET     $
   1282.5  0016D3 05                   DB      5
   1282.6  0016D4 2B4C4F4F50           DB      '+LOOP'
   1282.7  0016D9 00                   EVEN
   1282.8  0016DA                      IF      'DOCOLON'='DOCODE'
   1282.9  0016DA              PLUSLOOP: DW     $+2
   1282.10 0016DA                      ELSE
   1282.11 0016DA ....         PLUSLOOP: DW      DOCOLON
   1282.12 0016DC                      ENDIF
   1282.13 0016DC                      ENDM
   1283    0016DC ............*        DW lit,xplusloop,ENDLOOP,EXIT
   1284    0016E4              
   1285    0016E4              ;C LEAVE    -- L: -- adrs
   1286    0016E4              ;   ['] UNLOOP ,XT
   1287    0016E4              ;   ['] branch ,BRANCH   IHERE ,NONE  >L
   1288    0016E4              ;   ; IMMEDIATE      unconditional forward
                                branch
   1289    0016E4                  IMMED  LEAV,5,'LEAVE',DOCOLON
   1289.1  000000                      PUBLIC  LEAV
   1289.2  0016E4 ....                 DW      link
   1289.3  0016E6 FE                   DB      0FEh      // ; immediate
                                                                  (LSB=0)
   1289.4  0016E7              link    SET     $
   1289.5  0016E7 05                   DB      5
   1289.6  0016E8 4C45415645           DB      'LEAVE'
   1289.7  0016ED 00                   EVEN
   1289.8  0016EE                      IF      'DOCOLON'='DOCODE'
   1289.9  0016EE              LEAV: DW     $+2
   1289.10 0016EE                      ELSE
   1289.11 0016EE ....         LEAV: DW      DOCOLON
   1289.12 0016F0                      ENDIF
   1289.13 0016F0                      ENDM
   1290    0016F0 ............         DW lit,UNLOOP,COMMAXT
   1291    0016F6 ............         DW lit,bran,COMMABRANCH
   1292    0016FC ............*        DW IHERE,COMMANONE,TOL,EXIT
   1293    001704              
   1294    001704              ; OTHER OPERATIONS =============================
                               =
   1295    001704              
   1296    001704              ;X WITHIN   n1|u1 n2|u2 n3|u3 -- f        
                                n2<=n1<n3?
   1297    001704              ;  OVER - >R - R> U< ;          per ANS
                                document
   1298    001704                  HEADER  WITHIN,6,'WITHIN',DOCOLON
   1298.1  000000                      PUBLIC  WITHIN
   1298.2  001704 ....                 DW      link
   1298.3  001706 FF                   DB      0FFh       ; not immediate
   1298.4  001707              link    SET     $
   1298.5  001707 06                   DB      6
   1298.6  001708 57495448494E         DB      'WITHIN'
   1298.7  00170E                      EVEN
   1298.8  00170E                      IF      'DOCOLON'='DOCODE'
   1298.9  00170E              WITHIN: DW     $+2
   1298.10 00170E                      ELSE
   1298.11 00170E ....         WITHIN: DW      DOCOLON
   1298.12 001710                      ENDIF
   1298.13 001710                      ENDM
   1299    001710 ............*        DW OVER,MINUS,TOR,MINUS,RFROM,ULESS,EXIT
   1300    00171E              
   1301    00171E              ;C MOVE    addr1 addr2 u --     smart move
   1302    00171E              ;             VERSION FOR 1 ADDRESS UNIT = 1
                                CHAR
   1303    00171E              ;  >R 2DUP SWAP DUP R@ +     -- ... dst src
                                src+n
   1304    00171E              ;  WITHIN IF  R> CMOVE>        src <= dst <
                                src+n
   1305    00171E              ;       ELSE  R> CMOVE  THEN ;         
                                otherwise
   1306    00171E                  HEADER  MOVE,4,'MOVE',DOCOLON
   1306.1  000000                      PUBLIC  MOVE
   1306.2  00171E ....                 DW      link
   1306.3  001720 FF                   DB      0FFh       ; not immediate
   1306.4  001721              link    SET     $
   1306.5  001721 04                   DB      4
   1306.6  001722 4D4F5645             DB      'MOVE'
   1306.7  001726                      EVEN
   1306.8  001726                      IF      'DOCOLON'='DOCODE'
   1306.9  001726              MOVE: DW     $+2
   1306.10 001726                      ELSE
   1306.11 001726 ....         MOVE: DW      DOCOLON
   1306.12 001728                      ENDIF
   1306.13 001728                      ENDM
   1307    001728 ............*        DW TOR,TWODUP,SWAP,DUP,RFETCH,PLUS
   1308    001734 ........             DW WITHIN,qbran
   1309    001738                      DEST  MOVE1
   1309.1  001738 0A00                 DW      MOVE1-$
   1309.2  00173A                      ENDM
   1310    00173A ............         DW RFROM,CMOVEUP,bran
   1311    001740                      DEST  MOVE2
   1311.1  001740 0600                 DW      MOVE2-$
   1311.2  001742                      ENDM
   1312    001742 ........     MOVE1:  DW RFROM,CMOVE
   1313    001746 ....         MOVE2:  DW EXIT
   1314    001748              
   1315    001748              ;C DEPTH    -- +n        number of items on
                                stack
   1316    001748              ;   SP@ S0 SWAP - 2/ ;   16-BIT VERSION!
   1317    001748                  HEADER  DEPTH,5,'DEPTH',DOCOLON
   1317.1  000000                      PUBLIC  DEPTH
   1317.2  001748 ....                 DW      link
   1317.3  00174A FF                   DB      0FFh       ; not immediate
   1317.4  00174B              link    SET     $
   1317.5  00174B 05                   DB      5
   1317.6  00174C 4445505448           DB      'DEPTH'
   1317.7  001751 00                   EVEN
   1317.8  001752                      IF      'DOCOLON'='DOCODE'
   1317.9  001752              DEPTH: DW     $+2
   1317.10 001752                      ELSE
   1317.11 001752 ....         DEPTH: DW      DOCOLON
   1317.12 001754                      ENDIF
   1317.13 001754                      ENDM
   1318    001754 ............*        DW SPFETCH,S0,SWAP,MINUS,TWOSLASH,EXIT
   1319    001760              
   1320    001760              ;C ENVIRONMENT?  c-addr u -- false       system
                                query
   1321    001760              ;                         -- i*x true
   1322    001760              ;   2DROP 0 ;       the minimal definition!
   1323    001760                  HEADER  ENVIRONMENTQ,12,'ENVIRONMENT?',DOCOL
                               ON
   1323.1  000000                      PUBLIC  ENVIRONMENTQ
   1323.2  001760 ....                 DW      link
   1323.3  001762 FF                   DB      0FFh       ; not immediate
   1323.4  001763              link    SET     $
   1323.5  001763 0C                   DB      12
   1323.6  001764 454E5649524F*        DB      'ENVIRONMENT?'
   1323.7  001770                      EVEN
   1323.8  001770                      IF      'DOCOLON'='DOCODE'
   1323.9  001770              ENVIRONMENTQ: DW     $+2
   1323.10 001770                      ELSE
   1323.11 001770 ....         ENVIRONMENTQ: DW      DOCOLON
   1323.12 001772                      ENDIF
   1323.13 001772                      ENDM
   1324    001772 ............         DW TWODROP,ZERO,EXIT
   1325    001778              
   1326    001778              ;U UTILITY WORDS =====================
   1327    001778              
   1328    001778              ;Z NOOP       --    do nothing
   1329    001778                  HEADER  NOOP,4,'NOOP',DOCOLON
   1329.1  000000                      PUBLIC  NOOP
   1329.2  001778 ....                 DW      link
   1329.3  00177A FF                   DB      0FFh       ; not immediate
   1329.4  00177B              link    SET     $
   1329.5  00177B 04                   DB      4
   1329.6  00177C 4E4F4F50             DB      'NOOP'
   1329.7  001780                      EVEN
   1329.8  001780                      IF      'DOCOLON'='DOCODE'
   1329.9  001780              NOOP: DW     $+2
   1329.10 001780                      ELSE
   1329.11 001780 ....         NOOP: DW      DOCOLON
   1329.12 001782                      ENDIF
   1329.13 001782                      ENDM
   1330    001782 ....               DW EXIT
   1331    001784              
   1332    001784              ;Z FLALIGNED   a -- a'      align IDP to flash
                                boundary
   1333    001784              ;   $200 OVER - $1FF AND + ;
   1334    001784                  HEADER  FLALIGNED,9,'FLALIGNED',DOCOLON
   1334.1  000000                      PUBLIC  FLALIGNED
   1334.2  001784 ....                 DW      link
   1334.3  001786 FF                   DB      0FFh       ; not immediate
   1334.4  001787              link    SET     $
   1334.5  001787 09                   DB      9
   1334.6  001788 464C414C4947*        DB      'FLALIGNED'
   1334.7  001791 00                   EVEN
   1334.8  001792                      IF      'DOCOLON'='DOCODE'
   1334.9  001792              FLALIGNED: DW     $+2
   1334.10 001792                      ELSE
   1334.11 001792 ....         FLALIGNED: DW      DOCOLON
   1334.12 001794                      ENDIF
   1334.13 001794                      ENDM
   1335    001794 ....0002....*        DW lit,0200h,OVER,MINUS,lit,01FFh,ANDD,P
                                           LUS,EXIT
   1336    0017A6              
   1337    0017A6              ;X MARKER   --      create word to restore
                                dictionary
   1338    0017A6              ;   LATEST @ IHERE HERE
   1339    0017A6              ;   IHERE FLALIGNED IDP !     align new word to
                                flash boundary
   1340    0017A6              ;   <BUILDS I, I, I,        save dp,idp,latest
   1341    0017A6              ;   DOES>  DUP I@  
   1342    0017A6              ;   SWAP CELL+ DUP I@
   1343    0017A6              ;   SWAP CELL+ I@           fetch saved   -- dp
                                idp latest 
   1344    0017A6              ;   OVER FLALIGNED IHERE OVER - FLERASE    erase
                                Flash from saved to IHERE
   1345    0017A6              ;   LATEST ! IDP ! DP ! ;
   1346    0017A6                  HEADER  MARKER,6,'MARKER',DOCOLON
   1346.1  000000                      PUBLIC  MARKER
   1346.2  0017A6 ....                 DW      link
   1346.3  0017A8 FF                   DB      0FFh       ; not immediate
   1346.4  0017A9              link    SET     $
   1346.5  0017A9 06                   DB      6
   1346.6  0017AA 4D41524B4552         DB      'MARKER'
   1346.7  0017B0                      EVEN
   1346.8  0017B0                      IF      'DOCOLON'='DOCODE'
   1346.9  0017B0              MARKER: DW     $+2
   1346.10 0017B0                      ELSE
   1346.11 0017B0 ....         MARKER: DW      DOCOLON
   1346.12 0017B2                      ENDIF
   1346.13 0017B2                      ENDM
   1347    0017B2 ............*        DW LATEST,FETCH,IHERE,HERE
   1348    0017BA ............*        DW IHERE,FLALIGNED,IDP,STORE
   1349    0017C2 ............*        DW BUILDS,ICOMMA,ICOMMA,ICOMMA,XDOES
   1350    0017CC 3040....             MOV #dodoes,PC      ; long direct jump
                                                            to DODOES
   1351    0017D0 ........             DW DUP,IFETCH
   1352    0017D4 ............*        DW SWAP,CELLPLUS,DUP,IFETCH
   1353    0017DC ............         DW SWAP,CELLPLUS,IFETCH
   1354    0017E2 ............*        DW OVER,FLALIGNED,IHERE,OVER,MINUS,FLERA
                                           SE
   1355    0017EE ............*        DW LATEST,STORE,IDP,STORE,DDP,STORE,EXIT
   1356    0017FC              
   1357    0017FC              ;X WORDS    --          list all words in
                                dict.
   1358    0017FC              ;   LATEST @ BEGIN
   1359    0017FC              ;       DUP HCOUNT 7F AND HTYPE SPACE
   1360    0017FC              ;       NFA>LFA H@
   1361    0017FC              ;   DUP 0= UNTIL
   1362    0017FC              ;   DROP ;
   1363    0017FC                  HEADER  WORDS,5,'WORDS',DOCOLON
   1363.1  000000                      PUBLIC  WORDS
   1363.2  0017FC ....                 DW      link
   1363.3  0017FE FF                   DB      0FFh       ; not immediate
   1363.4  0017FF              link    SET     $
   1363.5  0017FF 05                   DB      5
   1363.6  001800 574F524453           DB      'WORDS'
   1363.7  001805 00                   EVEN
   1363.8  001806                      IF      'DOCOLON'='DOCODE'
   1363.9  001806              WORDS: DW     $+2
   1363.10 001806                      ELSE
   1363.11 001806 ....         WORDS: DW      DOCOLON
   1363.12 001808                      ENDIF
   1363.13 001808                      ENDM
   1364    001808 ........             DW LATEST,FETCH
   1365    00180C ............*WDS1:   DW DUP,HCOUNT,lit,07FH,ANDD,HTYPE,SPACE
   1366    00181A ........             DW NFATOLFA,HFETCH
   1367    00181E ............         DW DUP,ZEROEQUAL,qbran
   1368    001824                      DEST  WDS1
   1368.1  001824 E8FF                 DW      WDS1-$
   1368.2  001826                      ENDM
   1369    001826 ........             DW DROP,EXIT
   1370    00182A              
   1371    00182A              ;X U.R    u n --           display u unsigned in
                                n width
   1372    00182A              ;   >R  <# 0 #S #>  R> OVER - 0 MAX SPACES  TYPE
                                ;
   1373    00182A                  HEADER  UDOTR,3,'U.R',DOCOLON
   1373.1  000000                      PUBLIC  UDOTR
   1373.2  00182A ....                 DW      link
   1373.3  00182C FF                   DB      0FFh       ; not immediate
   1373.4  00182D              link    SET     $
   1373.5  00182D 03                   DB      3
   1373.6  00182E 552E52               DB      'U.R'
   1373.7  001831 00                   EVEN
   1373.8  001832                      IF      'DOCOLON'='DOCODE'
   1373.9  001832              UDOTR: DW     $+2
   1373.10 001832                      ELSE
   1373.11 001832 ....         UDOTR: DW      DOCOLON
   1373.12 001834                      ENDIF
   1373.13 001834                      ENDM
   1374    001834 ............*        DW TOR,LESSNUM,ZERO,NUMS,NUMGREATER
   1375    00183E ............*        DW RFROM,OVER,MINUS,ZERO,MAX,SPACES,TYP,
                                           EXIT
   1376    00184E              
   1377    00184E              ;X DUMP  adr n --         dump memory
   1378    00184E              ;  OVER + SWAP DO
   1379    00184E              ;    CR I 4 U.R SPACE SPACE
   1380    00184E              ;    I $10 + I DO I C@ 3 U.R LOOP  SPACE
                                SPACE
   1381    00184E              ;    I $10 + I DO I C@ $7F AND $7E MIN BL MAX
                                EMIT LOOP
   1382    00184E              ;  10 +LOOP ;
   1383    00184E                  HEADER  DUMP,4,'DUMP',DOCOLON
   1383.1  000000                      PUBLIC  DUMP
   1383.2  00184E ....                 DW      link
   1383.3  001850 FF                   DB      0FFh       ; not immediate
   1383.4  001851              link    SET     $
   1383.5  001851 04                   DB      4
   1383.6  001852 44554D50             DB      'DUMP'
   1383.7  001856                      EVEN
   1383.8  001856                      IF      'DOCOLON'='DOCODE'
   1383.9  001856              DUMP: DW     $+2
   1383.10 001856                      ELSE
   1383.11 001856 ....         DUMP: DW      DOCOLON
   1383.12 001858                      ENDIF
   1383.13 001858                      ENDM
   1384    001858 ............*        DW OVER,PLUS,SWAP,xdo
   1385    001860 ............*LDUMP1: DW CR,II,lit,4,UDOTR,SPACE,SPACE
   1386    00186E ........1000*        DW II,lit,10h,PLUS,II,xdo
   1387    00187A ............*LDUMP2: DW II,CFETCH,lit,3,UDOTR,xloop
   1388    001886                      DEST  LDUMP2
   1388.1  001886 F4FF                 DW      LDUMP2-$
   1388.2  001888                      ENDM
   1389    001888 ........             DW SPACE,SPACE
   1390    00188C ........1000*        DW II,lit,10h,PLUS,II,xdo
   1391    001898 ............*LDUMP3: DW II,CFETCH,lit,7Fh,ANDD,lit,7Eh,MIN,BL
                                           ANK,MAX,EMIT,xloop
   1392    0018B0                      DEST  LDUMP3
   1392.1  0018B0 E8FF                 DW      LDUMP3-$
   1392.2  0018B2                      ENDM
   1393    0018B2 ....1000....         DW lit,10h,xplusloop
   1394    0018B8                      DEST  LDUMP1
   1394.1  0018B8 A8FF                 DW      LDUMP1-$
   1394.2  0018BA                      ENDM
   1395    0018BA ....                 DW EXIT
   1396    0018BC              
   1397    0018BC              ;X .S      --           print stack contents
   1398    0018BC              ;   [char] < EMIT   DEPTH . BS [char] > EMIT 
                                
   1399    0018BC              ;   SP@ S0 < IF
   1400    0018BC              ;       SP@ S0 2 - DO I @ U. -2 +LOOP
   1401    0018BC              ;   THEN ;
   1402    0018BC                  HEADER  DOTS,2,'.S',DOCOLON
   1402.1  000000                      PUBLIC  DOTS
   1402.2  0018BC ....                 DW      link
   1402.3  0018BE FF                   DB      0FFh       ; not immediate
   1402.4  0018BF              link    SET     $
   1402.5  0018BF 02                   DB      2
   1402.6  0018C0 2E53                 DB      '.S'
   1402.7  0018C2                      EVEN
   1402.8  0018C2                      IF      'DOCOLON'='DOCODE'
   1402.9  0018C2              DOTS: DW     $+2
   1402.10 0018C2                      ELSE
   1402.11 0018C2 ....         DOTS: DW      DOCOLON
   1402.12 0018C4                      ENDIF
   1402.13 0018C4                      ENDM
   1403    0018C4                      ;mk gforth style 
   1404    0018C4 ....3C00....         DW lit,$3C,EMIT
   1405    0018CA ........             DW DEPTH,DOT
   1406    0018CE ....0800....*        DW lit,$08,EMIT,lit,$3E,EMIT,SPACE
                                            
   1407    0018DC                      ;/mk
   1408    0018DC ............*        DW SPFETCH,S0,LESS,qbran
   1409    0018E4                      DEST  DOTS2
   1409.1  0018E4 1C00                 DW      DOTS2-$
   1409.2  0018E6                      ENDM
   1410    0018E6 ............*        DW SPFETCH,S0,lit,2,MINUS,xdo
   1411    0018F2 ............*DOTS1:  DW II,FETCH,UDOT,lit,-2,xplusloop
   1412    0018FE                      DEST  DOTS1
   1412.1  0018FE F4FF                 DW      DOTS1-$
   1412.2  001900                      ENDM
   1413    001900 ....         DOTS2:  DW EXIT
   1414    001902              
   1415    001902              
   1416    001902              ;U ccrc      n c -- n'     crc process
                                byte
   1417    001902              ;   8 LSHIFT XOR
   1418    001902              ;   8 0 DO ( n' )
   1419    001902              ;     DUP 1 LSHIFT  SWAP 8000 AND 0= INVERT 1021
                                ( CRC-16 )  AND  XOR 
   1420    001902              ;   LOOP 
   1421    001902              ;   FFFF AND ;
   1422    001902                  HEADER  CCRC,4,'ccrc',DOCOLON
   1422.1  000000                      PUBLIC  CCRC
   1422.2  001902 ....                 DW      link
   1422.3  001904 FF                   DB      0FFh       ; not immediate
   1422.4  001905              link    SET     $
   1422.5  001905 04                   DB      4
   1422.6  001906 63637263             DB      'ccrc'
   1422.7  00190A                      EVEN
   1422.8  00190A                      IF      'DOCOLON'='DOCODE'
   1422.9  00190A              CCRC: DW     $+2
   1422.10 00190A                      ELSE
   1422.11 00190A ....         CCRC: DW      DOCOLON
   1422.12 00190C                      ENDIF
   1422.13 00190C                      ENDM
   1423    00190C ....0800....*          DW lit,8,LSHIFT,XORR
   1424    001914 ....0800....*          DW lit,8,ZERO,xdo
   1425    00191C ........0100*ccrc1:    DW DUP,lit,1,LSHIFT,SWAP,lit,08000h,AN
                                             DD,ZEROEQUAL
   1426    00192E ........2110*          DW INVERT,lit,01021h,ANDD,XORR
   1427    001938 ....                   DW xloop
   1428    00193A                        DEST ccrc1
   1428.1  00193A E2FF                 DW      ccrc1-$
   1428.2  00193C                      ENDM
   1429    00193C ....                   DW EXIT 
   1430    00193E              
   1431    00193E              ;U (crc     n addr len -- n'     crc process
                                string including previous crc-byte
   1432    00193E              ;   dup IF over + swap DO  ( n ) I C@ ccrc LOOP
                                ELSE 2drop THEN ;
   1433    00193E                  HEADER  PCRC,4,'(crc',DOCOLON
   1433.1  000000                      PUBLIC  PCRC
   1433.2  00193E ....                 DW      link
   1433.3  001940 FF                   DB      0FFh       ; not immediate
   1433.4  001941              link    SET     $
   1433.5  001941 04                   DB      4
   1433.6  001942 28637263             DB      '(crc'
   1433.7  001946                      EVEN
   1433.8  001946                      IF      'DOCOLON'='DOCODE'
   1433.9  001946              PCRC: DW     $+2
   1433.10 001946                      ELSE
   1433.11 001946 ....         PCRC: DW      DOCOLON
   1433.12 001948                      ENDIF
   1433.13 001948                      ENDM
   1434    001948 ........               DW DUP,qbran
   1435    00194C                        DEST pcrc2
   1435.1  00194C 1800                 DW      pcrc2-$
   1435.2  00194E                      ENDM
   1436    00194E ............*          DW OVER,PLUS,SWAP,xdo
   1437    001956 ............*pcrc1:    DW II,CFETCH,CCRC, xloop
   1438    00195E                        DEST pcrc1
   1438.1  00195E F8FF                 DW      pcrc1-$
   1438.2  001960                      ENDM
   1439    001960 ....                   DW bran
   1440    001962                        DEST pcrc3
   1440.1  001962 0400                 DW      pcrc3-$
   1440.2  001964                      ENDM
   1441    001964 ....         pcrc2:    DW TWODROP
   1442    001966 ....         pcrc3:    DW EXIT
   1443    001968              
   1444    001968              ;U crc      addr len -- n       crc process
                                string 
   1445    001968                  HEADER  CRC,3,'crc',DOCOLON
   1445.1  000000                      PUBLIC  CRC
   1445.2  001968 ....                 DW      link
   1445.3  00196A FF                   DB      0FFh       ; not immediate
   1445.4  00196B              link    SET     $
   1445.5  00196B 03                   DB      3
   1445.6  00196C 637263               DB      'crc'
   1445.7  00196F 00                   EVEN
   1445.8  001970                      IF      'DOCOLON'='DOCODE'
   1445.9  001970              CRC: DW     $+2
   1445.10 001970                      ELSE
   1445.11 001970 ....         CRC: DW      DOCOLON
   1445.12 001972                      ENDIF
   1445.13 001972                      ENDM
   1446    001972 ............*          DW ZERO,ROT,ROT,PCRC,EXIT
   1447    00197C              
   1448    00197C              
   1449    00197C              ;U STARTUP WORDS ===============================
                               ================================
   1450    00197C              
   1451    00197C              ;Z ITHERE      -- adr      find first free flash
                                cell
   1452    00197C              ;  MEMTOP BEGIN 1- 
   1453    00197C              ;  DUP C@ FF <> 
   1454    00197C              ;  OVER FL0 < OR UNTIL 1+ ;
   1455    00197C                  HEADER  ITHERE,6,'ITHERE',DOCOLON
   1455.1  000000                      PUBLIC  ITHERE
   1455.2  00197C ....                 DW      link
   1455.3  00197E FF                   DB      0FFh       ; not immediate
   1455.4  00197F              link    SET     $
   1455.5  00197F 06                   DB      6
   1455.6  001980 495448455245         DB      'ITHERE'
   1455.7  001986                      EVEN
   1455.8  001986                      IF      'DOCOLON'='DOCODE'
   1455.9  001986              ITHERE: DW     $+2
   1455.10 001986                      ELSE
   1455.11 001986 ....         ITHERE: DW      DOCOLON
   1455.12 001988                      ENDIF
   1455.13 001988                      ENDM
   1456    001988 ....               DW MEMTOP
   1457    00198A ............*ih1   DW ONEMINUS,DUP,CFETCH,lit,$FF,NOTEQUAL
   1458    001996 ........00C0*      DW OVER,lit,FLASHSTART,LESS,ORR,qbran
   1459    0019A2                      DEST  ih1
   1459.1  0019A2 E8FF                 DW      ih1-$
   1459.2  0019A4                      ENDM
   1460    0019A4 ........           DW ONEPLUS,EXIT
   1461    0019A8              
   1462    0019A8              ;U APPCRC    -- crc      CRC of APP-dictionary
   1463    0019A8              ;    0 MEMBOT ITHERE OVER - (crc  APPU0 #INIT
                                (crc ;
   1464    0019A8                  HEADER   APPCRC,6,'APPCRC',DOCOLON
   1464.1  000000                      PUBLIC  APPCRC
   1464.2  0019A8 ....                 DW      link
   1464.3  0019AA FF                   DB      0FFh       ; not immediate
   1464.4  0019AB              link    SET     $
   1464.5  0019AB 06                   DB      6
   1464.6  0019AC 415050435243         DB      'APPCRC'
   1464.7  0019B2                      EVEN
   1464.8  0019B2                      IF      'DOCOLON'='DOCODE'
   1464.9  0019B2              APPCRC: DW     $+2
   1464.10 0019B2                      ELSE
   1464.11 0019B2 ....         APPCRC: DW      DOCOLON
   1464.12 0019B4                      ENDIF
   1464.13 0019B4                      ENDM
   1465    0019B4 ....0000             DW lit,0
   1466    0019B8 ....00C0....*        DW lit,FLASHSTART,ITHERE,OVER,MINUS,PCRC
   1467    0019C4 ............*        DW APPU0,NINIT,PCRC,EXIT
   1468    0019CC              
   1469    000000              EXTERN crcval 
   1470    0019CC              
   1471    0019CC              ;U VALID?     -- f       check if user app crc
                                matches infoB
   1472    0019CC              ;     APPCRC crcval I@ = ;
   1473    0019CC                  HEADER   VALIDQ,6,'VALID?',DOCOLON
   1473.1  000000                      PUBLIC  VALIDQ
   1473.2  0019CC ....                 DW      link
   1473.3  0019CE FF                   DB      0FFh       ; not immediate
   1473.4  0019CF              link    SET     $
   1473.5  0019CF 06                   DB      6
   1473.6  0019D0 56414C49443F         DB      'VALID?'
   1473.7  0019D6                      EVEN
   1473.8  0019D6                      IF      'DOCOLON'='DOCODE'
   1473.9  0019D6              VALIDQ: DW     $+2
   1473.10 0019D6                      ELSE
   1473.11 0019D6 ....         VALIDQ: DW      DOCOLON
   1473.12 0019D8                      ENDIF
   1473.13 0019D8                      ENDM
   1474    0019D8 ............*        DW APPCRC,lit,crcval,IFETCH,EQUAL,EXIT
   1475    0019E4              
   1476    0019E4              ;U SAVE   --      save user area to infoB
   1477    0019E4              ;  InfoB [ 63 2 + ] Literal FLERASE
   1478    0019E4              ;  U0 APPU0 #INIT D->I
   1479    0019E4              ;  APPCRC [ crcval ] Literal I! ;
   1480    0019E4                  HEADER  SAVE,4,'SAVE',DOCOLON
   1480.1  000000                      PUBLIC  SAVE
   1480.2  0019E4 ....                 DW      link
   1480.3  0019E6 FF                   DB      0FFh       ; not immediate
   1480.4  0019E7              link    SET     $
   1480.5  0019E7 04                   DB      4
   1480.6  0019E8 53415645             DB      'SAVE'
   1480.7  0019EC                      EVEN
   1480.8  0019EC                      IF      'DOCOLON'='DOCODE'
   1480.9  0019EC              SAVE: DW     $+2
   1480.10 0019EC                      ELSE
   1480.11 0019EC ....         SAVE: DW      DOCOLON
   1480.12 0019EE                      ENDIF
   1480.13 0019EE                      ENDM
   1481    0019EE ........4100*        DW INFOB,lit,63+2,FLERASE
   1482    0019F6 ............*        DW U0,APPU0,NINIT,DTOI
   1483    0019FE ............*        DW APPCRC,lit,crcval,ISTORE
   1484    001A06 ....                 DW EXIT
   1485    001A08              
   1486    00018E              CORREST    EQU 018Eh 
   1487    000186              CORPOWERON EQU 0186h 
   1488    001A08              
   1489    001A08              ;Z BOOT     --        boot system
   1490    001A08                  HEADER  BOOT,4,'BOOT',DOCOLON
   1490.1  000000                      PUBLIC  BOOT
   1490.2  001A08 ....                 DW      link
   1490.3  001A0A FF                   DB      0FFh       ; not immediate
   1490.4  001A0B              link    SET     $
   1490.5  001A0B 04                   DB      4
   1490.6  001A0C 424F4F54             DB      'BOOT'
   1490.7  001A10                      EVEN
   1490.8  001A10                      IF      'DOCOLON'='DOCODE'
   1490.9  001A10              BOOT: DW     $+2
   1490.10 001A10                      ELSE
   1490.11 001A10 ....         BOOT: DW      DOCOLON
   1490.12 001A12                      ENDIF
   1490.13 001A12                      ENDM
   1491    001A12 ....                 DW DOTVER
   1492    001A14 ............         DW S2,cget,qbran
   1493    001A1A                      DEST  boot1
   1493.1  001A1A 2A00                 DW      boot1-$
   1493.2  001A1C                      ENDM
   1494    001A1C ........             DW VALIDQ,qbran
   1495    001A20                      DEST invalid
   1495.1  001A20 0400                 DW      invalid-$
   1495.2  001A22                      ENDM
   1496    001A22 ....         valid:  DW COLD   ; valid infoB and dictionary
   1497    001A24 ............*invalid:DW COR,FETCH,lit,CORPOWERON,NOTEQUAL,qbr
                                           an
   1498    001A30                      DEST boot1
   1498.1  001A30 1400                 DW      boot1-$
   1498.2  001A32                      ENDM
   1499    001A32              reset:  ; reset and invalid infoB
   1500    001A32 ............*        DW LATEST,FETCH,lit,FLASHSTART,ITHERE,WI
                                           THIN,qbran  ; check RAM latest
                                            
   1501    001A40                      DEST boot1
   1501.1  001A40 0400                 DW      boot1-$
   1501.2  001A42                      ENDM
   1502    001A42 ....                 DW WARM   ; invalid infoB but seemingly
                                                  valid RAM
   1503    001A44 ....         boot1:  DW WIPE   ; invalid infoB but power on
                                                  or RAM invalid
   1504    001A46              
   1505    000000              PUBLIC BOOTIP ; used to init IP register.
   1506    001A46              BOOTIP   equ BOOT+2
   1507    001A46              
   1508    001A46              ;Z WARM     --        use user area from RAM
                                (hopefully intact)
   1509    001A46                  HEADER  WARM,4,'WARM',DOCOLON
   1509.1  000000                      PUBLIC  WARM
   1509.2  001A46 ....                 DW      link
   1509.3  001A48 FF                   DB      0FFh       ; not immediate
   1509.4  001A49              link    SET     $
   1509.5  001A49 04                   DB      4
   1509.6  001A4A 5741524D             DB      'WARM'
   1509.7  001A4E                      EVEN
   1509.8  001A4E                      IF      'DOCOLON'='DOCODE'
   1509.9  001A4E              WARM: DW     $+2
   1509.10 001A4E                      ELSE
   1509.11 001A4E ....         WARM: DW      DOCOLON
   1509.12 001A50                      ENDIF
   1509.13 001A50                      ENDM
   1510    001A50 ....                 DW XISQUOTE
   1511    001A52 05                   DB (warm1-warm0)
   1512    001A53 5761726D     warm0:  DB 'Warm'
   1513    001A57 00                   EVEN
   1514    001A58 ....         warm1:  DW ITYPE
   1515    001A5A ....                 DW ABORT
   1516    001A5C              
   1517    001A5C              ;U .COLD  --  display COLD message
   1518    001A5C                  HEADLESS DOTCOLD,DOCOLON
   1518.1  000000                      PUBLIC  DOTCOLD
   1518.2  001A5C                      IF      'DOCOLON'='DOCODE'
   1518.3  001A5C              DOTCOLD: DW     $+2
   1518.4  001A5C                      ELSE
   1518.5  001A5C ....         DOTCOLD: DW      DOCOLON
   1518.6  001A5E                      ENDIF
   1518.7  001A5E                      ENDM
   1519    001A5E ....                 DW XISQUOTE
   1520    001A60 05                   DB (dotcold1-dotcold0)
   1521    001A61 436F6C64     dotcold0:DB 'Cold'
   1522    001A65 00                   EVEN
   1523    001A66 ....         dotcold1:DW ITYPE
   1524    001A68 ....                 DW EXIT
   1525    001A6A              
   1526    001A6A              PUBLIC DOTCOLD
   1527    001A6A              
   1528    001A6A              ;Z COLD     --        set user area to latest
                                application
   1529    001A6A                  HEADER  COLD,4,'COLD',DOCOLON
   1529.1  000000                      PUBLIC  COLD
   1529.2  001A6A ....                 DW      link
   1529.3  001A6C FF                   DB      0FFh       ; not immediate
   1529.4  001A6D              link    SET     $
   1529.5  001A6D 04                   DB      4
   1529.6  001A6E 434F4C44             DB      'COLD'
   1529.7  001A72                      EVEN
   1529.8  001A72                      IF      'DOCOLON'='DOCODE'
   1529.9  001A72              COLD: DW     $+2
   1529.10 001A72                      ELSE
   1529.11 001A72 ....         COLD: DW      DOCOLON
   1529.12 001A74                      ENDIF
   1529.13 001A74                      ENDM
   1530    001A74 ............*      DW APPU0,U0,NINIT,ITOD  ; use application
                                                              user area
   1531    001A7C ............       DW APP,FETCH,EXECUTE ; AUTOSTART
                                                           Application
   1532    001A82 ....               DW ABORT
   1533    001A84              
   1534    001A84              ;Z FACTORY     --      set user area to delivery
                                condition
   1535    001A84              ;   UINIT U0 #INIT I->D SAVE   init user
                                area
   1536    001A84              ;   ABORT ;
   1537    001A84                  HEADER  FACTORY,7,'FACTORY',DOCOLON
   1537.1  000000                      PUBLIC  FACTORY
   1537.2  001A84 ....                 DW      link
   1537.3  001A86 FF                   DB      0FFh       ; not immediate
   1537.4  001A87              link    SET     $
   1537.5  001A87 07                   DB      7
   1537.6  001A88 464143544F52*        DB      'FACTORY'
   1537.7  001A8F 00                   EVEN
   1537.8  001A90                      IF      'DOCOLON'='DOCODE'
   1537.9  001A90              FACTORY: DW     $+2
   1537.10 001A90                      ELSE
   1537.11 001A90 ....         FACTORY: DW      DOCOLON
   1537.12 001A92                      ENDIF
   1537.13 001A92                      ENDM
   1538    001A92 ............*        DW UINIT,U0,NINIT,ITOD    ; use kernel
                                                                  user
                                                                  area
   1539    001A9A ....                 DW SAVE
   1540    001A9C ....                 DW ABORT      ; ABORT never returns
   1541    001A9E              
   1542    000000              PUBLIC FACTORYIP ; used to init IP register.
   1543    001A9E              FACTORYIP equ FACTORY+2
   1544    001A9E              
   1545    001A9E              ;U WIPE    --      erase flash but not kernel,
                                reset user area.
   1546    001A9E                  HEADER  WIPE,4,'WIPE',DOCOLON
   1546.1  000000                      PUBLIC  WIPE
   1546.2  001A9E ....                 DW      link
   1546.3  001AA0 FF                   DB      0FFh       ; not immediate
   1546.4  001AA1              link    SET     $
   1546.5  001AA1 04                   DB      4
   1546.6  001AA2 57495045             DB      'WIPE'
   1546.7  001AA6                      EVEN
   1546.8  001AA6                      IF      'DOCOLON'='DOCODE'
   1546.9  001AA6              WIPE: DW     $+2
   1546.10 001AA6                      ELSE
   1546.11 001AA6 ....         WIPE: DW      DOCOLON
   1546.12 001AA8                      ENDIF
   1546.13 001AA8                      ENDM
   1547    001AA8 ....                 DW XISQUOTE
   1548    001AAA 07                   DB (wipmsg1-wipmsg0)
   1549    001AAB 576970696E67 wipmsg0:DB 'Wiping'
   1550    001AB1 00                   EVEN
   1551    001AB2 ....         wipmsg1:DW ITYPE
   1552    001AB4 ....00C0....*        DW lit,FLASHSTART,lit,FLASHEND-FLASHSTAR
                                           T+1,FLERASE
   1553    001ABE ....                 DW FACTORY ; EXIT
   1554    001AC0              
   1555    001AC0              ;U MISC ========================================
                               ================================
   1556    001AC0              
   1557    001AC0              ;C 2CONSTANT   --            define a Forth
                                double constant
   1558    001AC0              ;   <BUILDS  I, I,           Flashable Harvard
                                model
   1559    001AC0              ;   DOES> (machine code fragment)
   1560    001AC0              ; Note that the constant is stored in Code
                                space.
   1561    001AC0                      HEADER TWOCONSTANT,9,'2CONSTANT',DOCOLON
   1561.1  000000                      PUBLIC  TWOCONSTANT
   1561.2  001AC0 ....                 DW      link
   1561.3  001AC2 FF                   DB      0FFh       ; not immediate
   1561.4  001AC3              link    SET     $
   1561.5  001AC3 09                   DB      9
   1561.6  001AC4 32434F4E5354*        DB      '2CONSTANT'
   1561.7  001ACD 00                   EVEN
   1561.8  001ACE                      IF      'DOCOLON'='DOCODE'
   1561.9  001ACE              TWOCONSTANT: DW     $+2
   1561.10 001ACE                      ELSE
   1561.11 001ACE ....         TWOCONSTANT: DW      DOCOLON
   1561.12 001AD0                      ENDIF
   1561.13 001AD0                      ENDM
   1562    001AD0 ............*        DW BUILDS,ICOMMA,ICOMMA,XDOES
   1563    000000                      PUBLIC DOTWOCON
   1564    001AD8              DOTWOCON:  ; ( -- w1 w2 )
   1565    001AD8 2482               SUB #4,PSP       ; make room on stack
   1566    001ADA 84470200           MOV TOS,2(PSP)
   1567    001ADE 3746               MOV @W+,TOS      ; fetch from parameter
                                                       field to TOS
   1568    001AE0 A4460000           MOV @W,0(PSP)    ; fetch secon word from
                                                       parameter field to
                                                       NOS
   1569    001AE4                    NEXT
   1569.1  001AE4 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
   1569.2  001AE6 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
   1569.3  001AE8                      ENDM
   1570    001AE8              
   1571    001AE8              ;U \         --      backslash 
   1572    001AE8              ; everything up to the end of the current line
                                is a comment. 
   1573    001AE8              ;   SOURCE >IN ! DROP ; 
   1574    001AE8                  IMMED BACKSLASH,1,'\\',DOCOLON
   1574.1  000000                      PUBLIC  BACKSLASH
   1574.2  001AE8 ....                 DW      link
   1574.3  001AEA FE                   DB      0FEh      // ; immediate
                                                                   (LSB=0)
   1574.4  001AEB              link    SET     $
   1574.5  001AEB 01                   DB      1
   1574.6  001AEC 5C                   DB      '\\'
   1574.7  001AED 00                   EVEN
   1574.8  001AEE                      IF      'DOCOLON'='DOCODE'
   1574.9  001AEE              BACKSLASH: DW     $+2
   1574.10 001AEE                      ELSE
   1574.11 001AEE ....         BACKSLASH: DW      DOCOLON
   1574.12 001AF0                      ENDIF
   1574.13 001AF0                      ENDM
   1575    001AF0 ............*        DW SOURCE,TOIN,STORE,DROP,EXIT
                                            
   1576    001AFA              
   1577    001AFA              ;Z .VER     --     type message   
   1578    001AFA                      HEADER  DOTVER,4,'.VER',DOCOLON     
                                
   1578.1  000000                      PUBLIC  DOTVER
   1578.2  001AFA ....                 DW      link
   1578.3  001AFC FF                   DB      0FFh       ; not immediate
   1578.4  001AFD              link    SET     $
   1578.5  001AFD 04                   DB      4
   1578.6  001AFE 2E564552             DB      '.VER'
   1578.7  001B02                      EVEN
   1578.8  001B02                      IF      'DOCOLON'='DOCODE'
   1578.9  001B02              DOTVER: DW     $+2
   1578.10 001B02                      ELSE
   1578.11 001B02 ....         DOTVER: DW      DOCOLON
   1578.12 001B04                      ENDIF
   1578.13 001B04                      ENDM
   1579    001B04 ............*        DW lit,version,COUNT,ITYPE
   1580    001B0C ............         DW BASE,FETCH,BIN
   1581    001B12 ............         DW COR,FETCH,DOT
   1582    001B18 ........             DW BASE,STORE
   1583    001B1C ....                 DW EXIT ; print cause of reset
   1584    001B1E              
   1585    001B1E              ;U BELL     --                send $07 to
                                Terminal
   1586    001B1E                   HEADER BELL,4,'BELL',DOCOLON
   1586.1  000000                      PUBLIC  BELL
   1586.2  001B1E ....                 DW      link
   1586.3  001B20 FF                   DB      0FFh       ; not immediate
   1586.4  001B21              link    SET     $
   1586.5  001B21 04                   DB      4
   1586.6  001B22 42454C4C             DB      'BELL'
   1586.7  001B26                      EVEN
   1586.8  001B26                      IF      'DOCOLON'='DOCODE'
   1586.9  001B26              BELL: DW     $+2
   1586.10 001B26                      ELSE
   1586.11 001B26 ....         BELL: DW      DOCOLON
   1586.12 001B28                      ENDIF
   1586.13 001B28                      ENDM
   1587    001B28 ....0700....*         DW lit,7,EMIT,EXIT
   1588    001B30              
   1589    001B30              ;U ESC[     --                start esc-sequence
   1590    001B30              ; 27 emit 91 emit ;
   1591    001B30                   HEADERLESS  ESCPAR,4,'ESC[',DOCOLON
   1591.1  000000                      PUBLIC  ESCPAR
   1591.2  001B30                      IF      'DOCOLON'='DOCODE'
   1591.3  001B30              ESCPAR: DW     $+2
   1591.4  001B30                      ELSE
   1591.5  001B30 ....         ESCPAR: DW      DOCOLON
   1591.6  001B32                      ENDIF
   1591.7  001B32                      ENDM
   1592    001B32 ....1B00....*         DW lit,27,EMIT, lit,91,EMIT
   1593    001B3E ....                  DW EXIT
   1594    001B40              
   1595    001B40              ;U PN      --                 send parameter of
                                esc-sequence
   1596    001B40              ; base @  swap decimal 0 u.r  base ! ;
                                
   1597    001B40                   HEADERLESS  PN,2,'PN',DOCOLON
   1597.1  000000                      PUBLIC  PN
   1597.2  001B40                      IF      'DOCOLON'='DOCODE'
   1597.3  001B40              PN: DW     $+2
   1597.4  001B40                      ELSE
   1597.5  001B40 ....         PN: DW      DOCOLON
   1597.6  001B42                      ENDIF
   1597.7  001B42                      ENDM
   1598    001B42 ........              DW BASE,FETCH
   1599    001B46 ............*         DW SWAP,DECIMAL,ZERO,UDOTR
   1600    001B4E ........              DW BASE,STORE
   1601    001B52 ....                  DW EXIT
   1602    001B54              
   1603    001B54              ;U ;PN    --                  send delimiter ;
                                followed by parameter
   1604    001B54              ; 59 emit pn ;
   1605    001B54                   HEADERLESS SEMIPN,3,';PN',DOCOLON
   1605.1  000000                      PUBLIC  SEMIPN
   1605.2  001B54                      IF      'DOCOLON'='DOCODE'
   1605.3  001B54              SEMIPN: DW     $+2
   1605.4  001B54                      ELSE
   1605.5  001B54 ....         SEMIPN: DW      DOCOLON
   1605.6  001B56                      ENDIF
   1605.7  001B56                      ENDM
   1606    001B56 ....3B00....*         DW lit,59,EMIT,PN
   1607    001B5E ....                  DW EXIT
   1608    001B60              
   1609    001B60              ;U AT-XY   x y --          send esc-sequence to
                                terminal
   1610    001B60              ; 1+ swap 1+ swap ESC[ pn ;pn 72 emit ;
                                
   1611    001B60                   HEADER ATXY,5,'AT-XY',DOCOLON
   1611.1  000000                      PUBLIC  ATXY
   1611.2  001B60 ....                 DW      link
   1611.3  001B62 FF                   DB      0FFh       ; not immediate
   1611.4  001B63              link    SET     $
   1611.5  001B63 05                   DB      5
   1611.6  001B64 41542D5859           DB      'AT-XY'
   1611.7  001B69 00                   EVEN
   1611.8  001B6A                      IF      'DOCOLON'='DOCODE'
   1611.9  001B6A              ATXY: DW     $+2
   1611.10 001B6A                      ELSE
   1611.11 001B6A ....         ATXY: DW      DOCOLON
   1611.12 001B6C                      ENDIF
   1611.13 001B6C                      ENDM
   1612    001B6C ............*         DW ONEPLUS,SWAP,ONEPLUS,SWAP
   1613    001B74 ........              DW ESCPAR,PN
   1614    001B78 ........4800*         DW SEMIPN, lit,72,EMIT
   1615    001B80 ....                  DW EXIT
   1616    001B82              
   1617    001B82              ;U PAGE    --              send "page" command
                                to terminal to clear screen.
   1618    001B82              ; esc[  ." 2J" 0 0 at-xy ;
   1619    001B82                   HEADER PAGEE,4,'PAGE',DOCOLON
   1619.1  000000                      PUBLIC  PAGEE
   1619.2  001B82 ....                 DW      link
   1619.3  001B84 FF                   DB      0FFh       ; not immediate
   1619.4  001B85              link    SET     $
   1619.5  001B85 04                   DB      4
   1619.6  001B86 50414745             DB      'PAGE'
   1619.7  001B8A                      EVEN
   1619.8  001B8A                      IF      'DOCOLON'='DOCODE'
   1619.9  001B8A              PAGEE: DW     $+2
   1619.10 001B8A                      ELSE
   1619.11 001B8A ....         PAGEE: DW      DOCOLON
   1619.12 001B8C                      ENDIF
   1619.13 001B8C                      ENDM
   1620    001B8C ....                 DW ESCPAR
   1621    001B8E ....                 DW XISQUOTE
   1622    001B90 03                   DB (ESC1-ESC0)
   1623    001B91 324A         ESC0:   DB '2J'
   1624    001B93 00                   EVEN
   1625    001B94 ....         ESC1:   DW ITYPE
   1626    001B96 ............         DW ZERO,ZERO,ATXY
   1627    001B9C ....                 DW EXIT
   1628    001B9E              
   1629    001B9E              ;U BIN   --                set number base to
                                binary
   1630    001B9E                   HEADER BIN,3,'BIN',DOCOLON
   1630.1  000000                      PUBLIC  BIN
   1630.2  001B9E ....                 DW      link
   1630.3  001BA0 FF                   DB      0FFh       ; not immediate
   1630.4  001BA1              link    SET     $
   1630.5  001BA1 03                   DB      3
   1630.6  001BA2 42494E               DB      'BIN'
   1630.7  001BA5 00                   EVEN
   1630.8  001BA6                      IF      'DOCOLON'='DOCODE'
   1630.9  001BA6              BIN: DW     $+2
   1630.10 001BA6                      ELSE
   1630.11 001BA6 ....         BIN: DW      DOCOLON
   1630.12 001BA8                      ENDIF
   1630.13 001BA8                      ENDM
   1631    001BA8 ....0200....*         DW lit,2,BASE,STORE,EXIT
   1632    001BB2              
   1633    001BB2              
   1634    001BB2              
   1635    001BB2              ;U MCU specific words ==========================
                               ================================
   1636    001BB2              
   1637    001BB2              ;U 1MS  --   wait about 1 millisecond
   1638    001BB2              ;  xx 0 DO yy 0 DO LOOP LOOP ;  adjust xx and yy
                                to get a msec.
   1639    001BB2                   HEADER ONEMS,3,'1MS',DOCOLON
   1639.1  000000                      PUBLIC  ONEMS
   1639.2  001BB2 ....                 DW      link
   1639.3  001BB4 FF                   DB      0FFh       ; not immediate
   1639.4  001BB5              link    SET     $
   1639.5  001BB5 03                   DB      3
   1639.6  001BB6 314D53               DB      '1MS'
   1639.7  001BB9 00                   EVEN
   1639.8  001BBA                      IF      'DOCOLON'='DOCODE'
   1639.9  001BBA              ONEMS: DW     $+2
   1639.10 001BBA                      ELSE
   1639.11 001BBA ....         ONEMS: DW      DOCOLON
   1639.12 001BBC                      ENDIF
   1639.13 001BBC                      ENDM
   1640    001BBC ....2900....*         DW lit,41,ZERO,xdo 
   1641    001BC4 ....0B00....*onems1:  DW lit,11,ZERO,xdo
   1642    001BCC ....         onems2:  DW xloop
   1643    001BCE                       DEST onems2
   1643.1  001BCE FEFF                 DW      onems2-$
   1643.2  001BD0                      ENDM
   1644    001BD0 ....                  DW xloop
   1645    001BD2                       DEST onems1
   1645.1  001BD2 F2FF                 DW      onems1-$
   1645.2  001BD4                      ENDM
   1646    001BD4 ....                  DW EXIT
   1647    001BD6              
   1648    001BD6              ;U MS  n --                wait about n
                                milliseconds
   1649    001BD6              ;  0 DO 1MS LOOP ;
   1650    001BD6                   HEADER MS,2,'MS',DOCOLON
   1650.1  000000                      PUBLIC  MS
   1650.2  001BD6 ....                 DW      link
   1650.3  001BD8 FF                   DB      0FFh       ; not immediate
   1650.4  001BD9              link    SET     $
   1650.5  001BD9 02                   DB      2
   1650.6  001BDA 4D53                 DB      'MS'
   1650.7  001BDC                      EVEN
   1650.8  001BDC                      IF      'DOCOLON'='DOCODE'
   1650.9  001BDC              MS: DW     $+2
   1650.10 001BDC                      ELSE
   1650.11 001BDC ....         MS: DW      DOCOLON
   1650.12 001BDE                      ENDIF
   1650.13 001BDE                      ENDM
   1651    001BDE ........              DW ZERO,xdo
   1652    001BE2 ........     ms1:     DW ONEMS,xloop
   1653    001BE6                       DEST ms1
   1653.1  001BE6 FCFF                 DW      ms1-$
   1653.2  001BE8                      ENDM
   1654    001BE8 ....                  DW EXIT
   1655    001BEA                       
   1656    001BEA                       
   1657    001BEA                       
   1658    001BEA              ;U Bit manipulation words ----------------------
                               --------------------------------
   1659    001BEA              ;  based on http://www.forth.org/svfig/Len/bits.
                               htm
   1660    001BEA              
   1661    001BEA              ;U SET    mask addr --      set bit from mask in
                                addr (cell); use even adr!
   1662    001BEA                  HEADER  wset,3,'SET',DOCODE
   1662.1  000000                      PUBLIC  wset
   1662.2  001BEA ....                 DW      link
   1662.3  001BEC FF                   DB      0FFh       ; not immediate
   1662.4  001BED              link    SET     $
   1662.5  001BED 03                   DB      3
   1662.6  001BEE 534554               DB      'SET'
   1662.7  001BF1 00                   EVEN
   1662.8  001BF2                      IF      'DOCODE'='DOCODE'
   1662.9  001BF2 ....         wset: DW     $+2
   1662.10 001BF4                      ELSE
   1662.11 001BF4              wset: DW      DOCODE
   1662.12 001BF4                      ENDIF
   1662.13 001BF4                      ENDM
   1663    001BF4 A7D40000           BIS     @PSP,0(TOS)
   1664    001BF8 2453               ADD     #2,PSP
   1665    001BFA 3744               MOV     @PSP+,TOS
   1666    001BFC                    NEXT
   1666.1  001BFC 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
   1666.2  001BFE 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
   1666.3  001C00                      ENDM
   1667    001C00              
   1668    001C00              ;U CSET    mask addr --      set bit from mask
                                in addr (byte)
   1669    001C00                  HEADER  cset,4,'CSET',DOCODE
   1669.1  000000                      PUBLIC  cset
   1669.2  001C00 ....                 DW      link
   1669.3  001C02 FF                   DB      0FFh       ; not immediate
   1669.4  001C03              link    SET     $
   1669.5  001C03 04                   DB      4
   1669.6  001C04 43534554             DB      'CSET'
   1669.7  001C08                      EVEN
   1669.8  001C08                      IF      'DOCODE'='DOCODE'
   1669.9  001C08 ....         cset: DW     $+2
   1669.10 001C0A                      ELSE
   1669.11 001C0A              cset: DW      DOCODE
   1669.12 001C0A                      ENDIF
   1669.13 001C0A                      ENDM
   1670    001C0A E7D40000           BIS.B   @PSP,0(TOS)
   1671    001C0E 2453               ADD     #2,PSP
   1672    001C10 3744               MOV     @PSP+,TOS
   1673    001C12                    NEXT
   1673.1  001C12 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
   1673.2  001C14 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
   1673.3  001C16                      ENDM
   1674    001C16              
   1675    001C16              ;U CLR  mask addr --      reset bit from mask in
                                addr (cell); use even adr!
   1676    001C16                  HEADER  wclr,3,'CLR',DOCODE
   1676.1  000000                      PUBLIC  wclr
   1676.2  001C16 ....                 DW      link
   1676.3  001C18 FF                   DB      0FFh       ; not immediate
   1676.4  001C19              link    SET     $
   1676.5  001C19 03                   DB      3
   1676.6  001C1A 434C52               DB      'CLR'
   1676.7  001C1D 00                   EVEN
   1676.8  001C1E                      IF      'DOCODE'='DOCODE'
   1676.9  001C1E ....         wclr: DW     $+2
   1676.10 001C20                      ELSE
   1676.11 001C20              wclr: DW      DOCODE
   1676.12 001C20                      ENDIF
   1676.13 001C20                      ENDM
   1677    001C20 A7C40000           BIC     @PSP,0(TOS)
   1678    001C24 2453               ADD     #2,PSP
   1679    001C26 3744               MOV     @PSP+,TOS
   1680    001C28                    NEXT
   1680.1  001C28 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
   1680.2  001C2A 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
   1680.3  001C2C                      ENDM
   1681    001C2C              
   1682    001C2C              ;U CCLR  mask addr --      reset bit from mask
                                in addr (byte)
   1683    001C2C                  HEADER  cclr,4,'CCLR',DOCODE
   1683.1  000000                      PUBLIC  cclr
   1683.2  001C2C ....                 DW      link
   1683.3  001C2E FF                   DB      0FFh       ; not immediate
   1683.4  001C2F              link    SET     $
   1683.5  001C2F 04                   DB      4
   1683.6  001C30 43434C52             DB      'CCLR'
   1683.7  001C34                      EVEN
   1683.8  001C34                      IF      'DOCODE'='DOCODE'
   1683.9  001C34 ....         cclr: DW     $+2
   1683.10 001C36                      ELSE
   1683.11 001C36              cclr: DW      DOCODE
   1683.12 001C36                      ENDIF
   1683.13 001C36                      ENDM
   1684    001C36 E7C40000           BIC.B   @PSP,0(TOS)
   1685    001C3A 2453               ADD     #2,PSP
   1686    001C3C 3744               MOV     @PSP+,TOS
   1687    001C3E                    NEXT
   1687.1  001C3E 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
   1687.2  001C40 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
   1687.3  001C42                      ENDM
   1688    001C42              
   1689    001C42              ;U CTOGGLE    mask addr --        flip bit from
                                mask in addr (byte)
   1690    001C42                  HEADER  ctoggle,7,'CTOGGLE',DOCODE
   1690.1  000000                      PUBLIC  ctoggle
   1690.2  001C42 ....                 DW      link
   1690.3  001C44 FF                   DB      0FFh       ; not immediate
   1690.4  001C45              link    SET     $
   1690.5  001C45 07                   DB      7
   1690.6  001C46 43544F47474C*        DB      'CTOGGLE'
   1690.7  001C4D 00                   EVEN
   1690.8  001C4E                      IF      'DOCODE'='DOCODE'
   1690.9  001C4E ....         ctoggle: DW     $+2
   1690.10 001C50                      ELSE
   1690.11 001C50              ctoggle: DW      DOCODE
   1690.12 001C50                      ENDIF
   1690.13 001C50                      ENDM
   1691    001C50 E7E40000           XOR.B   @PSP,0(TOS)
   1692    001C54 2453               ADD     #2,PSP
   1693    001C56 3744               MOV     @PSP+,TOS
   1694    001C58                    NEXT
   1694.1  001C58 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
   1694.2  001C5A 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
   1694.3  001C5C                      ENDM
   1695    001C5C              
   1696    001C5C              ;U CGET       mask addr -- flag    test bit from
                                mask in addr (byte)
   1697    001C5C                  HEADER  cget,4,'CGET',DOCODE
   1697.1  000000                      PUBLIC  cget
   1697.2  001C5C ....                 DW      link
   1697.3  001C5E FF                   DB      0FFh       ; not immediate
   1697.4  001C5F              link    SET     $
   1697.5  001C5F 04                   DB      4
   1697.6  001C60 43474554             DB      'CGET'
   1697.7  001C64                      EVEN
   1697.8  001C64                      IF      'DOCODE'='DOCODE'
   1697.9  001C64 ....         cget: DW     $+2
   1697.10 001C66                      ELSE
   1697.11 001C66              cget: DW      DOCODE
   1697.12 001C66                      ENDIF
   1697.13 001C66                      ENDM
   1698    001C66 E7B40000           BIT.B   @PSP,0(TOS)
   1699    001C6A 0224               JZ cget1
   1700    001C6C 3743               MOV #-1,TOS
   1701    001C6E 013C               JMP cget2
   1702    001C70 0743         cget1:MOV #0, TOS
   1703    001C72 2453         cget2:ADD     #2,PSP
   1704    001C74                    NEXT
   1704.1  001C74 3645                 MOV @IP+,W     // ; fetch word address
                                                          into W
   1704.2  001C76 3046                 MOV @W+,PC     // ; fetch code address
                                                          into PC, W=PFA
   1704.3  001C78                      ENDM
   1705    001C78              
   1706    001C78              
   1707    001C78              ;U Memory info ---------------------------------
                               --------------------------------
   1708    001C78              
   1709    001C78              ;Z MEMBOT   -- adr       begining of flash      
                                  
   1710    001C78                  HEADER  MEMBOT,6,'MEMBOT',DOCON
   1710.1  000000                      PUBLIC  MEMBOT
   1710.2  001C78 ....                 DW      link
   1710.3  001C7A FF                   DB      0FFh       ; not immediate
   1710.4  001C7B              link    SET     $
   1710.5  001C7B 06                   DB      6
   1710.6  001C7C 4D454D424F54         DB      'MEMBOT'
   1710.7  001C82                      EVEN
   1710.8  001C82                      IF      'DOCON'='DOCODE'
   1710.9  001C82              MEMBOT: DW     $+2
   1710.10 001C82                      ELSE
   1710.11 001C82 ....         MEMBOT: DW      DOCON
   1710.12 001C84                      ENDIF
   1710.13 001C84                      ENDM
   1711    001C84 00C0                 DW FLASHSTART 
   1712    001C86              
   1713    001C86              ;Z MEMTOP   -- adr       end of flash        
                                
   1714    001C86                  HEADER  MEMTOP,6,'MEMTOP',DOCON
   1714.1  000000                      PUBLIC  MEMTOP
   1714.2  001C86 ....                 DW      link
   1714.3  001C88 FF                   DB      0FFh       ; not immediate
   1714.4  001C89              link    SET     $
   1714.5  001C89 06                   DB      6
   1714.6  001C8A 4D454D544F50         DB      'MEMTOP'
   1714.7  001C90                      EVEN
   1714.8  001C90                      IF      'DOCON'='DOCODE'
   1714.9  001C90              MEMTOP: DW     $+2
   1714.10 001C90                      ELSE
   1714.11 001C90 ....         MEMTOP: DW      DOCON
   1714.12 001C92                      ENDIF
   1714.13 001C92                      ENDM
   1715    001C92 FFDF                 DW FLASHEND 
   1716    001C94              
   1717    001C94              ;U MEM       -- u    bytes left in flash
   1718    001C94                  HEADER  MEM,3,'MEM',DOCOLON
   1718.1  000000                      PUBLIC  MEM
   1718.2  001C94 ....                 DW      link
   1718.3  001C96 FF                   DB      0FFh       ; not immediate
   1718.4  001C97              link    SET     $
   1718.5  001C97 03                   DB      3
   1718.6  001C98 4D454D               DB      'MEM'
   1718.7  001C9B 00                   EVEN
   1718.8  001C9C                      IF      'DOCOLON'='DOCODE'
   1718.9  001C9C              MEM: DW     $+2
   1718.10 001C9C                      ELSE
   1718.11 001C9C ....         MEM: DW      DOCOLON
   1718.12 001C9E                      ENDIF
   1718.13 001C9E                      ENDM
   1719    001C9E ....FFDF....*        DW lit,FLASHEND,IHERE,MINUS
   1720    001CA6 ....                 DW EXIT
   1721    001CA8                      
   1722    001CA8              ;U UNUSED    -- u    bytes left in RAM
   1723    001CA8                  HEADER UNUSED,6,'UNUSED',DOCOLON
   1723.1  000000                      PUBLIC  UNUSED
   1723.2  001CA8 ....                 DW      link
   1723.3  001CAA FF                   DB      0FFh       ; not immediate
   1723.4  001CAB              link    SET     $
   1723.5  001CAB 06                   DB      6
   1723.6  001CAC 554E55534544         DB      'UNUSED'
   1723.7  001CB2                      EVEN
   1723.8  001CB2                      IF      'DOCOLON'='DOCODE'
   1723.9  001CB2              UNUSED: DW     $+2
   1723.10 001CB2                      ELSE
   1723.11 001CB2 ....         UNUSED: DW      DOCOLON
   1723.12 001CB4                      ENDIF
   1723.13 001CB4                      ENDM
   1724    001CB4 ....FF03....*        DW lit,RAMEND,HERE,MINUS
   1725    001CBC ....                 DW EXIT
   1726    001CBE              
   1727    001CBE              ;U MCU Peripherie ------------------------------
                               --------------------------------
   1728    001CBE              
   1729    001CBE              ;Z P1    --  adr       address of port1 output
                                register 
   1730    001CBE                  HEADER  P1,2,'P1',DOCON
   1730.1  000000                      PUBLIC  P1
   1730.2  001CBE ....                 DW      link
   1730.3  001CC0 FF                   DB      0FFh       ; not immediate
   1730.4  001CC1              link    SET     $
   1730.5  001CC1 02                   DB      2
   1730.6  001CC2 5031                 DB      'P1'
   1730.7  001CC4                      EVEN
   1730.8  001CC4                      IF      'DOCON'='DOCODE'
   1730.9  001CC4              P1: DW     $+2
   1730.10 001CC4                      ELSE
   1730.11 001CC4 ....         P1: DW      DOCON
   1730.12 001CC6                      ENDIF
   1730.13 001CC6                      ENDM
   1731    001CC6 2100                 DW P1OUT
   1732    001CC8              
   1733    001CC8              ;Z P2    --  adr       address of port2 output
                                register 
   1734    001CC8                  HEADER  P2,2,'P2',DOCON
   1734.1  000000                      PUBLIC  P2
   1734.2  001CC8 ....                 DW      link
   1734.3  001CCA FF                   DB      0FFh       ; not immediate
   1734.4  001CCB              link    SET     $
   1734.5  001CCB 02                   DB      2
   1734.6  001CCC 5032                 DB      'P2'
   1734.7  001CCE                      EVEN
   1734.8  001CCE                      IF      'DOCON'='DOCODE'
   1734.9  001CCE              P2: DW     $+2
   1734.10 001CCE                      ELSE
   1734.11 001CCE ....         P2: DW      DOCON
   1734.12 001CD0                      ENDIF
   1734.13 001CD0                      ENDM
   1735    001CD0 2900                 DW P2OUT
   1736    001CD2              
   1737    001CD2              ;Z P3    --  adr       address of port2 output
                                register 
   1738    001CD2                  HEADER  P3,2,'P3',DOCON
   1738.1  000000                      PUBLIC  P3
   1738.2  001CD2 ....                 DW      link
   1738.3  001CD4 FF                   DB      0FFh       ; not immediate
   1738.4  001CD5              link    SET     $
   1738.5  001CD5 02                   DB      2
   1738.6  001CD6 5033                 DB      'P3'
   1738.7  001CD8                      EVEN
   1738.8  001CD8                      IF      'DOCON'='DOCODE'
   1738.9  001CD8              P3: DW     $+2
   1738.10 001CD8                      ELSE
   1738.11 001CD8 ....         P3: DW      DOCON
   1738.12 001CDA                      ENDIF
   1738.13 001CDA                      ENDM
   1739    001CDA 1900                 DW P3OUT
   1740    001CDC              
   1741    001CDC              ; Note: the first character sent from the MSP430
                                seems to get
   1742    001CDC              ; scrambled.  I conjecture this is because the
                                baud rate generator
   1743    001CDC              ; has not reset to the new rate when we attempt
                                to send a character.
   1744    001CDC              ; See init430f1611.s43 for delay after
                                initialization.
    905    001CDC              #include "4e-LaunchPad.s43"
      1    001CDC              ; ----------------------------------------------
                               ------------------------
      2    001CDC              ; 4e4th is a Forth based on CamelForth
                                
      3    001CDC              ; for the Texas Instruments MSP430 
      4    001CDC              ; 
      5    001CDC              ; This program is free software; you can
                                redistribute it and/or modify
      6    001CDC              ; it under the terms of the GNU General Public
                                License as published by
      7    001CDC              ; the Free Software Foundation; either version 3
                                of the License, or
      8    001CDC              ; (at your option) any later version.
      9    001CDC              ; 
     10    001CDC              ; This program is distributed in the hope that
                                it will be useful,
     11    001CDC              ; but WITHOUT ANY WARRANTY; without even the
                                implied warranty of
     12    001CDC              ; MERCHANTABILITY or FITNESS FOR A PARTICULAR
                                PURPOSE.  See the
     13    001CDC              ; GNU General Public License for more details.
     14    001CDC              ;
     15    001CDC              ; You should have received a copy of the GNU
                                General Public License
     16    001CDC              ; along with this program.  If not, see
                                <http://www.gnu.org/licenses/>.
     17    001CDC              ; 
     18    001CDC              ; See LICENSE TERMS in Brads file readme.txt as
                                well.
     19    001CDC              
     20    001CDC              ; ----------------------------------------------
                               ------------------------
     21    001CDC              ; 4e-LaunchPad.s43 - LaunchPad Suporting Words -
                                MSP430G2553 
     22    001CDC              ; ----------------------------------------------
                               ------------------------
     23    001CDC              
     24    001CDC              
     25    001CDC              ;U PORTS ---------------------------------------
                               ------------------------
     26    001CDC              
     27    001CDC              ; TI document SLAU144I - December 2004 - Revised
                                January 2012 
     28    001CDC              ; The digital I/O registers are listed in Table
                                8-2. 
     29    001CDC              
     30    001CDC              ;U \ P1in = $20
     31    001CDC              ;U \ P1out = $21
     32    001CDC              ;U \ P1dir = $22
     33    001CDC              
     34    001CDC              ;U \ P2in = $28
     35    001CDC              ;U \ P2out = $29
     36    001CDC              ;U \ P2dir = $2A
     37    001CDC              
     38    001CDC              ;U \ LED - portpinX->---resistor---LED---GND
     39    001CDC              ;U \ P1.0 - red LED
     40    001CDC              ;U \ P1.6 - green LED
     41    001CDC              
     42    001CDC              ;U RED      -- mask port         red LED mask
                                and port address
     43    001CDC                  HEADER red,3,'RED',DOTWOCON
     43.1  000000                      PUBLIC  red
     43.2  001CDC ....                 DW      link
     43.3  001CDE FF                   DB      0FFh       ; not immediate
     43.4  001CDF              link    SET     $
     43.5  001CDF 03                   DB      3
     43.6  001CE0 524544               DB      'RED'
     43.7  001CE3 00                   EVEN
     43.8  001CE4                      IF      'DOTWOCON'='DOCODE'
     43.9  001CE4              red: DW     $+2
     43.10 001CE4                      ELSE
     43.11 001CE4 ....         red: DW      DOTWOCON
     43.12 001CE6                      ENDIF
     43.13 001CE6                      ENDM
     44    001CE6 2100                   DW P1OUT
     45    001CE8 0100                   DW 00000001b
     46    001CEA              
     47    001CEA              ;U GREEN     -- mask port        green LED mask
                                and port address
     48    001CEA                  HEADER green,5,'GREEN',DOTWOCON
     48.1  000000                      PUBLIC  green
     48.2  001CEA ....                 DW      link
     48.3  001CEC FF                   DB      0FFh       ; not immediate
     48.4  001CED              link    SET     $
     48.5  001CED 05                   DB      5
     48.6  001CEE 475245454E           DB      'GREEN'
     48.7  001CF3 00                   EVEN
     48.8  001CF4                      IF      'DOTWOCON'='DOCODE'
     48.9  001CF4              green: DW     $+2
     48.10 001CF4                      ELSE
     48.11 001CF4 ....         green: DW      DOTWOCON
     48.12 001CF6                      ENDIF
     48.13 001CF6                      ENDM
     49    001CF6 2100               DW P1OUT
     50    001CF8 4000               DW 01000000b
     51    001CFA              
     52    001CFA              ;U \ Switch S2
     53    001CFA              ;U portpin P1.3 --->0_0----GND
     54    001CFA              ;U S2        -- mask port        second button
                                mask and port address
     55    001CFA                  HEADER S2,2,'S2',DOTWOCON
     55.1  000000                      PUBLIC  S2
     55.2  001CFA ....                 DW      link
     55.3  001CFC FF                   DB      0FFh       ; not immediate
     55.4  001CFD              link    SET     $
     55.5  001CFD 02                   DB      2
     55.6  001CFE 5332                 DB      'S2'
     55.7  001D00                      EVEN
     55.8  001D00                      IF      'DOTWOCON'='DOCODE'
     55.9  001D00              S2: DW     $+2
     55.10 001D00                      ELSE
     55.11 001D00 ....         S2: DW      DOTWOCON
     55.12 001D02                      ENDIF
     55.13 001D02                      ENDM
     56    001D02 2000               DW P1IN
     57    001D04 0800               DW 00001000b
     58    001D06              
     59    001D06              ;U S2?     -- f    test button S2, true is
                                pressed 
     60    001D06                  HEADER SQEST,3,'S2?',DOCOLON
     60.1  000000                      PUBLIC  SQEST
     60.2  001D06 ....                 DW      link
     60.3  001D08 FF                   DB      0FFh       ; not immediate
     60.4  001D09              link    SET     $
     60.5  001D09 03                   DB      3
     60.6  001D0A 53323F               DB      'S2?'
     60.7  001D0D 00                   EVEN
     60.8  001D0E                      IF      'DOCOLON'='DOCODE'
     60.9  001D0E              SQEST: DW     $+2
     60.10 001D0E                      ELSE
     60.11 001D0E ....         SQEST: DW      DOCOLON
     60.12 001D10                      ENDIF
     60.13 001D10                      ENDM
     61    001D10 ............*        DW S2, cget, ZEROEQUAL, EXIT
     62    001D18              
     63    001D18              ; ----------------------------------------------
                               ------------------------
    906    001D18              
    907    001D18              
    908    001D18              /*
    909    001D18              ; DEBUG FORTH EXECUTION 
    910    001D18              ; debug serieal
    911    001D18                PUBLIC DEBUGIP
    912    001D18              DEBUGIP: 
    913    001D18              ;  DW  DOTID
    914    001D18              DEBUG1: 
    915    001D18              ;   DW TASK
    916    001D18                 DW  KEY  ; 1@A0 test 1=rot,@=grn,A=beide,0=a
                               us
    917    001D18                 DW  DUP  ;,DOTS,CR
    918    001D18                 DW  STORELEDS
    919    001D18              ;   DW  COLD
    920    001D18                 DW  EMIT 
    921    001D18                 DW  lit,0,qbran
    922    001D18                 DW  DEBUG1-$
    923    001D18                 DW  bran,-2
    924    001D18              
    925    001D18              /*
    926    001D18              ; debugging only
    927    001D18                HEADLESS CREATE,DOCOLON
    928    001D18                HEADLESS ALLOT,DOCOLON
    929    001D18                HEADLESS BUILDS,DOCOLON
    930    001D18                HEADLESS ICOMMA,DOCOLON
    931    001D18                HEADLESS XDOES,DOCOLON
    932    001D18                HEADLESS IHERE,DOCOLON
    933    001D18                HEADLESS IALLOT,DOCOLON
    934    001D18                HEADLESS CELL,DOCOLON
    935    001D18                HEADLESS PJOUT,DOCOLON
    936    001D18              */
    937    001D18              
    938    001D18              
    939    000000              PUBLIC lastword
    940    001D18              lastword equ link
    941    001D18              
    942    001D18              ; for debug map only:
    943    001D18              CF430FRend:
    944    001D18              #define CFlength = CF430FRend-CF430FRstart
    945    001D18              
    946    001D18                      END


ACCVIE               #define, value: (0x20), line:     132:2  
ACCVIFG              #define, value: (0x0004u), line:     448:2  
ADC10AE0_            #define, value: (0x004Au), line:     167:2      168:2
ADC10B1              #define, value: (0x002), line:     271:2  
ADC10BUSY            #define, value: (0x0001u), line:     211:2  
ADC10CT              #define, value: (0x004), line:     272:2  
ADC10CTL0_           #define, value: (0x01B0u), line:     170:2      171:2
ADC10CTL1_           #define, value: (0x01B2u), line:     172:2      173:2
ADC10DF              #define, value: (0x0200u), line:     220:2  
ADC10DISABLE         #define, value: (0x000), line:     274:2  
ADC10DIV0            #define, value: (0x0020u), line:     216:2  
ADC10DIV1            #define, value: (0x0040u), line:     217:2  
ADC10DIV2            #define, value: (0x0080u), line:     218:2  
ADC10DIV_0           #define, value: (0*0x20u), line:     238:2  
ADC10DIV_1           #define, value: (1*0x20u), line:     239:2  
ADC10DIV_2           #define, value: (2*0x20u), line:     240:2  
ADC10DIV_3           #define, value: (3*0x20u), line:     241:2  
ADC10DIV_4           #define, value: (4*0x20u), line:     242:2  
ADC10DIV_5           #define, value: (5*0x20u), line:     243:2  
ADC10DIV_6           #define, value: (6*0x20u), line:     244:2  
ADC10DIV_7           #define, value: (7*0x20u), line:     245:2  
ADC10DTC0_           #define, value: (0x0048u), line:     163:2      164:2
ADC10DTC1_           #define, value: (0x0049u), line:     165:2      166:2
ADC10FETCH           #define, value: (0x001), line:     270:2  
ADC10IE              #define, value: (0x008), line:     183:2  
ADC10IFG             #define, value: (0x004), line:     182:2  
ADC10MEM_            #define, value: (0x01B4u), line:     174:2      175:2
ADC10ON              #define, value: (0x010), line:     184:2  
ADC10SA_             #define, value: (0x01BCu), line:     176:2      177:2
ADC10SC              #define, value: (0x001), line:     180:2  
ADC10SHT0            #define, value: (0x800), line:     191:2  
ADC10SHT1            #define, value: (0x1000u), line:     192:2  
ADC10SHT_0           #define, value: (0*0x800u), line:     196:2  
ADC10SHT_1           #define, value: (1*0x800u), line:     197:2  
ADC10SHT_2           #define, value: (2*0x800u), line:     198:2  
ADC10SHT_3           #define, value: (3*0x800u), line:     199:2  
ADC10SR              #define, value: (0x400), line:     190:2  
ADC10SSEL0           #define, value: (0x0008u), line:     214:2  
ADC10SSEL1           #define, value: (0x0010u), line:     215:2  
ADC10SSEL_0          #define, value: (0*8u), line:     233:2  
ADC10SSEL_1          #define, value: (1*8u), line:     234:2  
ADC10SSEL_2          #define, value: (2*8u), line:     235:2  
ADC10SSEL_3          #define, value: (3*8u), line:     236:2  
ADC10TB              #define, value: (0x008), line:     273:2  
ADC10_VECTOR         #define, value: (5 * 2u), line:     965:2  
BCSCTL1_             #define, value: (0x0057u), line:     283:2      284:2
BCSCTL2_             #define, value: (0x0058u), line:     285:2      286:2
BCSCTL3_             #define, value: (0x0053u), line:     287:2      288:2
BIT0                 #define, value: (0x0001u), line:      57:2  
BIT1                 #define, value: (0x0002u), line:      58:2  
BIT2                 #define, value: (0x0004u), line:      59:2  
BIT3                 #define, value: (0x0008u), line:      60:2  
BIT4                 #define, value: (0x0010u), line:      61:2  
BIT5                 #define, value: (0x0020u), line:      62:2  
BIT6                 #define, value: (0x0040u), line:      63:2  
BIT7                 #define, value: (0x0080u), line:      64:2  
BIT8                 #define, value: (0x0100u), line:      65:2  
BIT9                 #define, value: (0x0200u), line:      66:2  
BITA                 #define, value: (0x0400u), line:      67:2  
BITB                 #define, value: (0x0800u), line:      68:2  
BITC                 #define, value: (0x1000u), line:      69:2  
BITD                 #define, value: (0x2000u), line:      70:2  
BITE                 #define, value: (0x4000u), line:      71:2  
BITF                 #define, value: (0x8000u), line:      72:2  
BLKWRT               #define, value: (0x0080u), line:     423:2  
BUSY                 #define, value: (0x0001u), line:     446:2  
C                    #define, value: (0x0001u), line:      78:2  
CACTL1_              #define, value: (0x0059u), line:     365:2      366:2
CACTL2_              #define, value: (0x005Au), line:     367:2      368:2
CAEX                 #define, value: (0x80), line:     379:2  
CAF                  #define, value: (0x02), line:     387:2  
CAIE                 #define, value: (0x02), line:     373:2  
CAIES                #define, value: (0x04), line:     374:2  
CAIFG                #define, value: (0x01), line:     372:2  
CALBC1_12MHZ_        #define, value: (0x10FBu), line:     946:2      947:2
CALBC1_16MHZ_        #define, value: (0x10F9u), line:     942:2      943:2
CALBC1_1MHZ_         #define, value: (0x10FFu), line:     954:2      955:2
CALBC1_8MHZ_         #define, value: (0x10FDu), line:     950:2      951:2
CALDCO_12MHZ_        #define, value: (0x10FAu), line:     944:2      945:2
CALDCO_16MHZ_        #define, value: (0x10F8u), line:     940:2      941:2
CALDCO_1MHZ_         #define, value: (0x10FEu), line:     952:2      953:2
CALDCO_8MHZ_         #define, value: (0x10FCu), line:     948:2      949:2
CAON                 #define, value: (0x08), line:     375:2  
CAOUT                #define, value: (0x01), line:     386:2  
CAP                  #define, value: (0x0100u), line:     604:2  
CAPD0                #define, value: (0x01), line:     395:2  
CAPD1                #define, value: (0x02), line:     396:2  
CAPD2                #define, value: (0x04), line:     397:2  
CAPD3                #define, value: (0x08), line:     398:2  
CAPD4                #define, value: (0x10), line:     399:2  
CAPD5                #define, value: (0x20), line:     400:2  
CAPD6                #define, value: (0x40), line:     401:2  
CAPD7                #define, value: (0x80), line:     402:2  
CAPD_                #define, value: (0x005Bu), line:     369:2      370:2
CAREF0               #define, value: (0x10), line:     376:2  
CAREF1               #define, value: (0x20), line:     377:2  
CAREF_0              #define, value: (0x00), line:     381:2  
CAREF_1              #define, value: (0x10), line:     382:2  
CAREF_2              #define, value: (0x20), line:     383:2  
CAREF_3              #define, value: (0x30), line:     384:2  
CARSEL               #define, value: (0x40), line:     378:2  
CASHORT              #define, value: (0x80), line:     393:2  
CCI                  #define, value: (0x0008u), line:     609:2  
CCIE                 #define, value: (0x0010u), line:     608:2  
CCIFG                #define, value: (0x0001u), line:     612:2  
CCIS0                #define, value: (0x1000u), line:     601:2  
CCIS1                #define, value: (0x2000u), line:     600:2  
CCIS_0               #define, value: (0*0x1000u), line:     622:2  
CCIS_1               #define, value: (1*0x1000u), line:     623:2  
CCIS_2               #define, value: (2*0x1000u), line:     624:2  
CCIS_3               #define, value: (3*0x1000u), line:     625:2  
CCR0                 #define, value: TACCR0, line:     565:2  
CCR0_                #define, value: TACCR0_, line:     571:2  
CCR1                 #define, value: TACCR1, line:     566:2  
CCR1_                #define, value: TACCR1_, line:     572:2  
CCR2                 #define, value: TACCR2, line:     567:2  
CCR2_                #define, value: TACCR2_, line:     573:2  
CCTL0                #define, value: TACCTL0, line:     562:2  
CCTL0_               #define, value: TACCTL0_, line:     568:2  
CCTL1                #define, value: TACCTL1, line:     563:2  
CCTL1_               #define, value: TACCTL1_, line:     569:2  
CCTL2                #define, value: TACCTL2, line:     564:2  
CCTL2_               #define, value: TACCTL2_, line:     570:2  
CFlength             #define, value: = CF430FRend-CF430FRstart, line:       944  
CM0                  #define, value: (0x4000u), line:     599:2  
CM1                  #define, value: (0x8000u), line:     598:2  
CM_0                 #define, value: (0*0x4000u), line:     626:2  
CM_1                 #define, value: (1*0x4000u), line:     627:2  
CM_2                 #define, value: (2*0x4000u), line:     628:2  
CM_3                 #define, value: (3*0x4000u), line:     629:2  
COMPARATORA_VECTOR   #define, value: (11 * 2u), line:     971:2  
CONSEQ0              #define, value: (0x0002u), line:     212:2  
CONSEQ1              #define, value: (0x0004u), line:     213:2  
CONSEQ_0             #define, value: (0*2u), line:     228:2  
CONSEQ_1             #define, value: (1*2u), line:     229:2  
CONSEQ_2             #define, value: (2*2u), line:     230:2  
CONSEQ_3             #define, value: (3*2u), line:     231:2  
COV                  #define, value: (0x0002u), line:     611:2  
CPUOFF               #define, value: (0x0010u), line:      83:2  
DCO0                 #define, value: (0x20), line:     295:2  
DCO1                 #define, value: (0x40), line:     296:2  
DCO2                 #define, value: (0x80), line:     297:2  
DCOCTL_              #define, value: (0x0056u), line:     281:2      282:2
DEFC                 #define,            line:      42:2      128:2    135:2    143:2    151:2
                                                                    164:2    166:2    168:2    282:2
                                                                    284:2    286:2    288:2    366:2
                                                                    368:2    370:2    462:2    464:2
                                                                    466:2    468:2    470:2    472:2
                                                                    474:2    476:2    478:2    481:2
                                                                    483:2    485:2    487:2    489:2
                                                                    491:2    493:2    495:2    497:2
                                                                    505:2    507:2    509:2    511:2
                                                                    513:2    515:2    677:2    679:2
                                                                    681:2    683:2    685:2    687:2
                                                                    689:2    691:2    693:2    695:2
                                                                    697:2    702:2    704:2    706:2
                                                                    708:2    710:2    712:2    714:2
                                                                    716:2    941:2    943:2    945:2
                                                                    947:2    949:2    951:2    953:2
                                                                    955:2
DEFW                 #define,            line:      43:2      171:2    173:2    175:2    177:2
                                                                    410:2    412:2    414:2    523:2
                                                                    525:2    527:2    529:2    531:2
                                                                    533:2    535:2    537:2    539:2
                                                                    645:2    647:2    649:2    651:2
                                                                    653:2    655:2    657:2    659:2
                                                                    661:2    718:2    720:2    893:2
DIVA0                #define, value: (0x10), line:     303:2  
DIVA1                #define, value: (0x20), line:     304:2  
DIVA_0               #define, value: (0x00), line:     308:2  
DIVA_1               #define, value: (0x10), line:     309:2  
DIVA_2               #define, value: (0x20), line:     310:2  
DIVA_3               #define, value: (0x30), line:     311:2  
DIVM0                #define, value: (0x10), line:     316:2  
DIVM1                #define, value: (0x20), line:     317:2  
DIVM_0               #define, value: (0x00), line:     326:2  
DIVM_1               #define, value: (0x10), line:     327:2  
DIVM_2               #define, value: (0x20), line:     328:2  
DIVM_3               #define, value: (0x30), line:     329:2  
DIVS0                #define, value: (0x02), line:     313:2  
DIVS1                #define, value: (0x04), line:     314:2  
DIVS_0               #define, value: (0x00), line:     321:2  
DIVS_1               #define, value: (0x02), line:     322:2  
DIVS_2               #define, value: (0x04), line:     323:2  
DIVS_3               #define, value: (0x06), line:     324:2  
EMEX                 #define, value: (0x0020u), line:     451:2  
ENC                  #define, value: (0x002), line:     181:2  
ERASE                #define, value: (0x0002u), line:     420:2        322
FAIL                 #define, value: (0x0080u), line:     453:2  
FCTL1_               #define, value: (0x0128u), line:     409:2      410:2
FCTL2_               #define, value: (0x012Au), line:     411:2      412:2
FCTL3_               #define, value: (0x012Cu), line:     413:2      414:2
FLASHEND             #define, value: (0xDFFF), line:      32:3        309      331      351      382
                                                                   1552:5   1715:5   1719:5
FLASHSTART           #define, value: (0xC000), line:      31:3        307      329      349      380
                                                                    156:5   1458:5   1466:5   1500:5
                                                                   1552:5   1552:5   1711:5
FN0                  #define, value: (0x0001u), line:     426:2  
FN1                  #define, value: (0x0002u), line:     427:2  
FN2                  #define, value: (0x0004u), line:     429:2  
FN3                  #define, value: (0x0008u), line:     432:2  
FN4                  #define, value: (0x0010u), line:     435:2  
FN5                  #define, value: (0x0020u), line:     437:2  
FRKEY                #define, value: (0x9600u), line:     416:2  
FSSEL0               #define, value: (0x0040u), line:     438:2  
FSSEL1               #define, value: (0x0080u), line:     439:2  
FSSEL_0              #define, value: (0x0000u), line:     441:2  
FSSEL_1              #define, value: (0x0040u), line:     442:2  
FSSEL_2              #define, value: (0x0080u), line:     443:2  
FSSEL_3              #define, value: (0x00C0u), line:     444:2  
FWKEY                #define, value: (0xA500u), line:     417:2        321      322      324      325
                                                                      364      365      368      369
                                                                      395      396      399      400
                                                                      428      429      447      448
FXKEY                #define, value: (0x3300u), line:     418:2  
GIE                  #define, value: (0x0008u), line:      82:2  
HALLOT               #define, value: IALLOT, line:     703:5     1064:5
HCCOMMA              #define, value: ICCOMMA, line:     705:5     1062:5
HCFETCH              #define, value: ICFETCH, line:     706:5      768:5   1064:5
HCOMMA               #define, value: ICOMMA, line:     704:5     1061:5
HCOUNT               #define, value: ICOUNT, line:     550:5      762:5   1365:5
HCSTORE              #define, value: ICSTORE, line:     708:5     1133:5
HFETCH               #define, value: IFETCH, line:     707:5      791:5   1123:5   1366:5
HHERE                #define, value: IHERE, line:     702:5     1063:5
HSTORE               #define, value: ISTORE, line:     709:5  
HTYPE                #define, value: ITYPE, line:     551:5     1365:5
HWORD                #define, value: IWORDC, line:     552:5     1064:5
ICFETCH              #define, value: CFETCH, line:       412      495:5    507:5    768:5   1064:5
ICOUNT               #define, value: COUNT, line:     450:5      482:5    762:5   1365:5
ID0                  #define, value: (0x0040u), line:     578:2  
ID1                  #define, value: (0x0080u), line:     577:2  
ID_0                 #define, value: (0*0x40u), line:     589:2  
ID_1                 #define, value: (1*0x40u), line:     590:2  
ID_2                 #define, value: (2*0x40u), line:     591:2  
ID_3                 #define, value: (3*0x40u), line:     592:2  
IE1_                 #define, value: (0x0000u), line:     127:2      128:2
IE2_                 #define, value: (0x0001u), line:     142:2      143:2
IFETCH               #define, value: FETCH, line:       411      494:5    791:5   1123:5   1351:5
                                                                   1352:5   1353:5   1366:5   1474:5
IFG1_                #define, value: (0x0002u), line:     134:2      135:2
IFG2_                #define, value: (0x0003u), line:     150:2      151:2
INCH0                #define, value: (0x1000u), line:     223:2  
INCH1                #define, value: (0x2000u), line:     224:2  
INCH2                #define, value: (0x4000u), line:     225:2  
INCH3                #define, value: (0x8000u), line:     226:2  
INCH_0               #define, value: (0*0x1000u), line:     252:2  
INCH_1               #define, value: (1*0x1000u), line:     253:2  
INCH_10              #define, value: (10*0x1000u), line:     262:2  
INCH_11              #define, value: (11*0x1000u), line:     263:2  
INCH_12              #define, value: (12*0x1000u), line:     264:2  
INCH_13              #define, value: (13*0x1000u), line:     265:2  
INCH_14              #define, value: (14*0x1000u), line:     266:2  
INCH_15              #define, value: (15*0x1000u), line:     267:2  
INCH_2               #define, value: (2*0x1000u), line:     254:2  
INCH_3               #define, value: (3*0x1000u), line:     255:2  
INCH_4               #define, value: (4*0x1000u), line:     256:2  
INCH_5               #define, value: (5*0x1000u), line:     257:2  
INCH_6               #define, value: (6*0x1000u), line:     258:2  
INCH_7               #define, value: (7*0x1000u), line:     259:2  
INCH_8               #define, value: (8*0x1000u), line:     260:2  
INCH_9               #define, value: (9*0x1000u), line:     261:2  
INDEX                #define, value: R8, line:      46:3        635      638      639      648
                                                                      652      660      665      673
                                                                      687
INFOEND              #define, value: (0x10FF), line:      28:3        314      356      387
INFOSEG              #define, value: (128), line:      34:3        333      334
INFOSTART            #define, value: (0x1000), line:      27:3        312      354      385
IP                   #define, value: R5, line:      41:3         62       63       67       68
                                                                       77       78       79      107
                                                                      117      129      157      158
                                                                      159      160      177      183
                                                                      188      195      203      211
                                                                      216      222      229      236
                                                                      243      249      256      262
                                                                      274      280      285      292
                                                                      337      372      453      461
                                                                      467      474      481      486
                                                                      491      496      501      507
                                                                      512      517      522      527
                                                                      532      543      555      564
                                                                      571      579      591      614
                                                                      614      615      622      623
                                                                      641      651      654      664
                                                                      667      675      683      689
                                                                      718      749      765      782
                                                                      799      822      837      857
                                                                      875      886   1569:5   1666:5
                                                                   1673:5   1680:5   1687:5   1694:5
                                                                   1704:5
IRACL                #define, value: R12, line:      59:3        700      708      716      729
                                                                      734      748
IRACM                #define, value: R13, line:      60:3        701      709      717
IRBT                 #define, value: W, line:      61:3        705      706      713      730
                                                                      736
IROP1                #define, value: TOS, line:      56:3        706      731      733      741
IROP2L               #define, value: R10, line:      57:3        697      708      710      724
                                                                      738
IROP2M               #define, value: R11, line:      58:3        704      709      711      723
                                                                      731      733      739      741
                                                                      747
ISSH                 #define, value: (0x0100u), line:     219:2  
ITYPE                #define, value: TYP, line:     449:5      529:5    977:5   1016:5   1365:5
                                                                   1514:5   1523:5   1551:5   1579:5
                                                                   1625:5
KEYV                 #define, value: (0x0002u), line:     447:2  
LFXT1OF              #define, value: (0x01), line:     336:2  
LFXT1S0              #define, value: (0x10), line:     340:2  
LFXT1S1              #define, value: (0x20), line:     341:2  
LFXT1S_0             #define, value: (0x00), line:     350:2  
LFXT1S_1             #define, value: (0x10), line:     351:2  
LFXT1S_2             #define, value: (0x20), line:     352:2  
LFXT1S_3             #define, value: (0x30), line:     353:2  
LIMIT                #define, value: R9, line:      47:3        634      636      637      639
                                                                      653      666      674      688
LOCK                 #define, value: (0x0010u), line:     450:2        325      369      400      448
LOCKA                #define, value: (0x0040u), line:     452:2  
LPM0                 #define, value: (CPUOFF), line:      91:2  
LPM1                 #define, value: (SCG0+CPUOFF), line:      92:2  
LPM2                 #define, value: (SCG1+CPUOFF), line:      93:2  
LPM3                 #define, value: (SCG1+SCG0+CPUOFF), line:      94:2  
LPM4                 #define, value: (SCG1+SCG0+OSCOFF+CPUOFF), line:      95:2  
MAINSEG              #define, value: (512), line:      33:3        333
MC0                  #define, value: (0x0010u), line:     580:2  
MC1                  #define, value: (0x0020u), line:     579:2  
MC_0                 #define, value: (0*0x10u), line:     585:2  
MC_1                 #define, value: (1*0x10u), line:     586:2  
MC_2                 #define, value: (2*0x10u), line:     587:2  
MC_3                 #define, value: (3*0x10u), line:     588:2  
MERAS                #define, value: (0x0004u), line:     421:2  
MOD0                 #define, value: (0x01), line:     290:2  
MOD1                 #define, value: (0x02), line:     291:2  
MOD2                 #define, value: (0x04), line:     292:2  
MOD3                 #define, value: (0x08), line:     293:2  
MOD4                 #define, value: (0x10), line:     294:2  
MSC                  #define, value: (0x080), line:     187:2  
N                    #define, value: (0x0004u), line:      80:2  
NMIIE                #define, value: (0x10), line:     131:2  
NMIIFG               #define, value: (0x10), line:     140:2  
NMI_VECTOR           #define, value: (14 * 2u), line:     974:2  
OFIE                 #define, value: (0x02), line:     130:2  
OFIFG                #define, value: (0x02), line:     137:2  
OSCOFF               #define, value: (0x0020u), line:      84:2  
OUT                  #define, value: (0x0004u), line:     610:2  
OUTMOD0              #define, value: (0x0020u), line:     607:2  
OUTMOD1              #define, value: (0x0040u), line:     606:2  
OUTMOD2              #define, value: (0x0080u), line:     605:2  
OUTMOD_0             #define, value: (0*0x20u), line:     614:2  
OUTMOD_1             #define, value: (1*0x20u), line:     615:2  
OUTMOD_2             #define, value: (2*0x20u), line:     616:2  
OUTMOD_3             #define, value: (3*0x20u), line:     617:2  
OUTMOD_4             #define, value: (4*0x20u), line:     618:2  
OUTMOD_5             #define, value: (5*0x20u), line:     619:2  
OUTMOD_6             #define, value: (6*0x20u), line:     620:2  
OUTMOD_7             #define, value: (7*0x20u), line:     621:2  
P1DIR_               #define, value: (0x0022u), line:     465:2      466:2
P1IES_               #define, value: (0x0024u), line:     469:2      470:2
P1IE_                #define, value: (0x0025u), line:     471:2      472:2
P1IFG_               #define, value: (0x0023u), line:     467:2      468:2
P1IN_                #define, value: (0x0020u), line:     461:2      462:2
P1OUT_               #define, value: (0x0021u), line:     463:2      464:2
P1REN_               #define, value: (0x0027u), line:     477:2      478:2
P1SEL2_              #define, value: (0x0041u), line:     475:2      476:2
P1SEL_               #define, value: (0x0026u), line:     473:2      474:2
P2CA0                #define, value: (0x04), line:     388:2  
P2CA1                #define, value: (0x08), line:     389:2  
P2CA2                #define, value: (0x10), line:     390:2  
P2CA3                #define, value: (0x20), line:     391:2  
P2CA4                #define, value: (0x40), line:     392:2  
P2DIR_               #define, value: (0x002Au), line:     484:2      485:2
P2IES_               #define, value: (0x002Cu), line:     488:2      489:2
P2IE_                #define, value: (0x002Du), line:     490:2      491:2
P2IFG_               #define, value: (0x002Bu), line:     486:2      487:2
P2IN_                #define, value: (0x0028u), line:     480:2      481:2
P2OUT_               #define, value: (0x0029u), line:     482:2      483:2
P2REN_               #define, value: (0x002Fu), line:     496:2      497:2
P2SEL2_              #define, value: (0x0042u), line:     494:2      495:2
P2SEL_               #define, value: (0x002Eu), line:     492:2      493:2
P3DIR_               #define, value: (0x001Au), line:     508:2      509:2
P3IN_                #define, value: (0x0018u), line:     504:2      505:2
P3OUT_               #define, value: (0x0019u), line:     506:2      507:2
P3REN_               #define, value: (0x0010u), line:     514:2      515:2
P3SEL2_              #define, value: (0x0043u), line:     512:2      513:2
P3SEL_               #define, value: (0x001Bu), line:     510:2      511:2
PORIFG               #define, value: (0x04), line:     138:2  
PORT1_VECTOR         #define, value: (2 * 2u), line:     963:2  
PORT2_VECTOR         #define, value: (3 * 2u), line:     964:2  
PREFIXPROMPT         #define, value: 0, line:     957:5      963:5    972:5
PSP                  #define, value: R4, line:      40:3         54       60       61      104
                                                                      105      114      115      125
                                                                      126      154      155      175
                                                                      176      187      192      193
                                                                      199      200      201      207
                                                                      208      209      210      215
                                                                      221      226      227      233
                                                                      234      240      241      242
                                                                      247      248      253      254
                                                                      261      278      279      289
                                                                      291      301      336      343
                                                                      371      376      422      423
                                                                      452      460      465      466
                                                                      471      472      473      478
                                                                      485      490      495      536
                                                                      547      575      587      599
                                                                      620      637      640      661
                                                                      671      672      679      680
                                                                      697      716      723      724
                                                                      747      756      757      764
                                                                      773      774      781      787
                                                                      788      798      811      812
                                                                      820      826      827      835
                                                                      842      843      874      882
                                                                      883      890      891   1565:5
                                                                   1566:5   1568:5   1663:5   1664:5
                                                                   1665:5   1670:5   1671:5   1672:5
                                                                   1677:5   1678:5   1679:5   1684:5
                                                                   1685:5   1686:5   1691:5   1692:5
                                                                   1693:5   1698:5   1703:5
Q                    #define, value: R12, line:      52:3        437      438      439
RAMEND               #define, value: (0x03FF), line:      30:3     1724:5
RAMSTART             #define, value: (0x0200), line:      29:3  
READ_ONLY            #define, value: const, line:      50:2      462:2    481:2    505:2    523:2
                                                                    645:2    689:2    714:2    941:2
                                                                    943:2    945:2    947:2    949:2
                                                                    951:2    953:2    955:2
REF2_5V              #define, value: (0x040), line:     186:2  
REFBURST             #define, value: (0x100), line:     188:2  
REFON                #define, value: (0x020), line:     185:2  
REFOUT               #define, value: (0x200), line:     189:2  
RESET_VECTOR         #define, value: (15 * 2u), line:     975:2  
RSEL0                #define, value: (0x01), line:     299:2  
RSEL1                #define, value: (0x02), line:     300:2  
RSEL2                #define, value: (0x04), line:     301:2  
RSEL3                #define, value: (0x08), line:     302:2  
RSP                  #define, value: SP, line:      39:3         67      228      235      255
                                                                      260      633      634      635
                                                                      652      653      665      666
                                                                      681      682      687      688
RSTIFG               #define, value: (0x08), line:     139:2  
SCCI                 #define, value: (0x0400u), line:     603:2  
SCG0                 #define, value: (0x0040u), line:      85:2  
SCG1                 #define, value: (0x0080u), line:      86:2  
SCS                  #define, value: (0x0800u), line:     602:2  
SEGWRT               #define, value: (0x0080u), line:     424:2  
SELM0                #define, value: (0x40), line:     318:2  
SELM1                #define, value: (0x80), line:     319:2  
SELM_0               #define, value: (0x00), line:     331:2  
SELM_1               #define, value: (0x40), line:     332:2  
SELM_2               #define, value: (0x80), line:     333:2  
SELM_3               #define, value: (0xC0), line:     334:2  
SELS                 #define, value: (0x08), line:     315:2  
SHS0                 #define, value: (0x0400u), line:     221:2  
SHS1                 #define, value: (0x0800u), line:     222:2  
SHS_0                #define, value: (0*0x400u), line:     247:2  
SHS_1                #define, value: (1*0x400u), line:     248:2  
SHS_2                #define, value: (2*0x400u), line:     249:2  
SHS_3                #define, value: (3*0x400u), line:     250:2  
SREF0                #define, value: (0x2000u), line:     193:2  
SREF1                #define, value: (0x4000u), line:     194:2  
SREF2                #define, value: (0x8000u), line:     195:2  
SREF_0               #define, value: (0*0x2000u), line:     201:2  
SREF_1               #define, value: (1*0x2000u), line:     202:2  
SREF_2               #define, value: (2*0x2000u), line:     203:2  
SREF_3               #define, value: (3*0x2000u), line:     204:2  
SREF_4               #define, value: (4*0x2000u), line:     205:2  
SREF_5               #define, value: (5*0x2000u), line:     206:2  
SREF_6               #define, value: (6*0x2000u), line:     207:2  
SREF_7               #define, value: (7*0x2000u), line:     208:2  
T                    #define, value: R13, line:      53:3  
TA0CCR0_             #define, value: (0x0172u), line:     534:2      535:2
TA0CCR1_             #define, value: (0x0174u), line:     536:2      537:2
TA0CCR2_             #define, value: (0x0176u), line:     538:2      539:2
TA0CCTL0_            #define, value: (0x0162u), line:     526:2      527:2
TA0CCTL1_            #define, value: (0x0164u), line:     528:2      529:2
TA0CCTL2_            #define, value: (0x0166u), line:     530:2      531:2
TA0CTL_              #define, value: (0x0160u), line:     524:2      525:2
TA0IV_               #define, value: (0x012Eu), line:     522:2      523:2
TA0IV_6              #define, value: (0x0006u), line:     635:2  
TA0IV_8              #define, value: (0x0008u), line:     636:2  
TA0IV_NONE           #define, value: (0x0000u), line:     632:2  
TA0IV_TACCR1         #define, value: (0x0002u), line:     633:2  
TA0IV_TACCR2         #define, value: (0x0004u), line:     634:2  
TA0IV_TAIFG          #define, value: (0x000Au), line:     637:2  
TA0R_                #define, value: (0x0170u), line:     532:2      533:2
TA1CCR0_             #define, value: (0x0192u), line:     656:2      657:2
TA1CCR1_             #define, value: (0x0194u), line:     658:2      659:2
TA1CCR2_             #define, value: (0x0196u), line:     660:2      661:2
TA1CCTL0_            #define, value: (0x0182u), line:     648:2      649:2
TA1CCTL1_            #define, value: (0x0184u), line:     650:2      651:2
TA1CCTL2_            #define, value: (0x0186u), line:     652:2      653:2
TA1CTL_              #define, value: (0x0180u), line:     646:2      647:2
TA1IV_               #define, value: (0x011Eu), line:     644:2      645:2
TA1IV_NONE           #define, value: (0x0000u), line:     666:2  
TA1IV_TACCR1         #define, value: (0x0002u), line:     667:2  
TA1IV_TACCR2         #define, value: (0x0004u), line:     668:2  
TA1IV_TAIFG          #define, value: (0x000Au), line:     669:2  
TA1R_                #define, value: (0x0190u), line:     654:2      655:2
TACCR0               #define, value: TA0CCR0, line:     548:2  
TACCR0_              #define, value: TA0CCR0_, line:     557:2  
TACCR1               #define, value: TA0CCR1, line:     549:2  
TACCR1_              #define, value: TA0CCR1_, line:     558:2  
TACCR2               #define, value: TA0CCR2, line:     550:2  
TACCR2_              #define, value: TA0CCR2_, line:     559:2  
TACCTL0              #define, value: TA0CCTL0, line:     544:2  
TACCTL0_             #define, value: TA0CCTL0_, line:     553:2  
TACCTL1              #define, value: TA0CCTL1, line:     545:2  
TACCTL1_             #define, value: TA0CCTL1_, line:     554:2  
TACCTL2              #define, value: TA0CCTL2, line:     546:2  
TACCTL2_             #define, value: TA0CCTL2_, line:     555:2  
TACLR                #define, value: (0x0004u), line:     581:2  
TACTL                #define, value: TA0CTL, line:     543:2  
TACTL_               #define, value: TA0CTL_, line:     552:2  
TAIE                 #define, value: (0x0002u), line:     582:2  
TAIFG                #define, value: (0x0001u), line:     583:2  
TAIV                 #define, value: TA0IV, line:     542:2  
TAIV_                #define, value: TA0IV_, line:     551:2  
TAR                  #define, value: TA0R, line:     547:2  
TAR_                 #define, value: TA0R_, line:     556:2  
TASSEL0              #define, value: (0x0100u), line:     576:2  
TASSEL1              #define, value: (0x0200u), line:     575:2  
TASSEL_0             #define, value: (0*0x100u), line:     593:2  
TASSEL_1             #define, value: (1*0x100u), line:     594:2  
TASSEL_2             #define, value: (2*0x100u), line:     595:2  
TASSEL_3             #define, value: (3*0x100u), line:     596:2  
TIMER0_A0_VECTOR     #define, value: (9 * 2u), line:     969:2  
TIMER0_A1_VECTOR     #define, value: (8 * 2u), line:     968:2  
TIMER1_A0_VECTOR     #define, value: (13 * 2u), line:     973:2  
TIMER1_A1_VECTOR     #define, value: (12 * 2u), line:     972:2  
TOS                  #define, value: R7, line:      43:3         53       54       61       62
                                                                      105      106      115      116
                                                                      126      127      128      155
                                                                      156      176      181      187
                                                                      193      194      201      202
                                                                      208      209      220      221
                                                                      227      228      234      235
                                                                      241      242      247      248
                                                                      254      255      260      261
                                                                      273      273      278      279
                                                                      284      284      290      291
                                                                      302      304      336      344
                                                                      346      349      351      354
                                                                      356      367      371      377
                                                                      380      382      385      387
                                                                      398      424      432      442
                                                                      450      452      460      465
                                                                      466      471      473      479
                                                                      480      485      490      495
                                                                      500      505      506      511
                                                                      516      521      526      526
                                                                      531      537      540      542
                                                                      548      552      554      562
                                                                      563      563      568      568
                                                                      569      569      570      576
                                                                      578      588      590      600
                                                                      619      620      638      640
                                                                      660      661      672      673
                                                                      674      680      681      682
                                                                      706      717      731      733
                                                                      741      748      760      764
                                                                      775      779      781      789
                                                                      791      792      796      798
                                                                      815      821      830      836
                                                                      844      849      854      854
                                                                      855      855      856      873
                                                                      874      883      884      891
                                                                     57:4   1566:5   1567:5   1663:5
                                                                   1665:5   1670:5   1672:5   1677:5
                                                                   1679:5   1684:5   1686:5   1691:5
                                                                   1693:5   1698:5   1700:5   1702:5
UC0IE                #define, value: IE2, line:     144:2  
UC0IFG               #define, value: IFG2, line:     152:2  
UC7BIT               #define, value: (0x10), line:     726:2  
UCA0ABCTL_           #define, value: (0x005Du), line:     692:2      693:2
UCA0BR0_             #define, value: (0x0062u), line:     680:2      681:2
UCA0BR1_             #define, value: (0x0063u), line:     682:2      683:2
UCA0CTL0_            #define, value: (0x0060u), line:     676:2      677:2
UCA0CTL1_            #define, value: (0x0061u), line:     678:2      679:2
UCA0IRRCTL_          #define, value: (0x005Fu), line:     696:2      697:2
UCA0IRTCTL_          #define, value: (0x005Eu), line:     694:2      695:2
UCA0MCTL_            #define, value: (0x0064u), line:     684:2      685:2
UCA0RXBUF_           #define, value: (0x0066u), line:     688:2      689:2
UCA0RXIE             #define, value: (0x01), line:     145:2  
UCA0RXIFG            #define, value: (0x01), line:     153:2        880      892
UCA0STAT_            #define, value: (0x0065u), line:     686:2      687:2
UCA0TXBUF_           #define, value: (0x0067u), line:     690:2      691:2
UCA0TXIE             #define, value: (0x02), line:     146:2  
UCA0TXIFG            #define, value: (0x02), line:     154:2        871
UCA10                #define, value: (0x80), line:     738:2  
UCABDEN              #define, value: (0x01), line:     862:2  
UCADDR               #define, value: (0x02), line:     816:2  
UCALIE               #define, value: (0x01), line:     827:2  
UCALIFG              #define, value: (0x01), line:     835:2  
UCB0BR0_             #define, value: (0x006Au), line:     705:2      706:2
UCB0BR1_             #define, value: (0x006Bu), line:     707:2      708:2
UCB0CTL0_            #define, value: (0x0068u), line:     701:2      702:2
UCB0CTL1_            #define, value: (0x0069u), line:     703:2      704:2
UCB0I2CIE_           #define, value: (0x006Cu), line:     709:2      710:2
UCB0I2COA_           #define, value: (0x0118u), line:     717:2      718:2
UCB0I2CSA_           #define, value: (0x011Au), line:     719:2      720:2
UCB0RXBUF_           #define, value: (0x006Eu), line:     713:2      714:2
UCB0RXIE             #define, value: (0x04), line:     147:2  
UCB0RXIFG            #define, value: (0x04), line:     155:2  
UCB0STAT_            #define, value: (0x006Du), line:     711:2      712:2
UCB0TXBUF_           #define, value: (0x006Fu), line:     715:2      716:2
UCB0TXIE             #define, value: (0x08), line:     148:2  
UCB0TXIFG            #define, value: (0x08), line:     156:2  
UCBBUSY              #define, value: (0x10), line:     831:2  
UCBRF0               #define, value: (0x10), line:     778:2  
UCBRF1               #define, value: (0x20), line:     777:2  
UCBRF2               #define, value: (0x40), line:     776:2  
UCBRF3               #define, value: (0x80), line:     775:2  
UCBRF_0              #define, value: (0x00), line:     784:2  
UCBRF_1              #define, value: (0x10), line:     785:2  
UCBRF_10             #define, value: (0xA0), line:     794:2  
UCBRF_11             #define, value: (0xB0), line:     795:2  
UCBRF_12             #define, value: (0xC0), line:     796:2  
UCBRF_13             #define, value: (0xD0), line:     797:2  
UCBRF_14             #define, value: (0xE0), line:     798:2  
UCBRF_15             #define, value: (0xF0), line:     799:2  
UCBRF_2              #define, value: (0x20), line:     786:2  
UCBRF_3              #define, value: (0x30), line:     787:2  
UCBRF_4              #define, value: (0x40), line:     788:2  
UCBRF_5              #define, value: (0x50), line:     789:2  
UCBRF_6              #define, value: (0x60), line:     790:2  
UCBRF_7              #define, value: (0x70), line:     791:2  
UCBRF_8              #define, value: (0x80), line:     792:2  
UCBRF_9              #define, value: (0x90), line:     793:2  
UCBRK                #define, value: (0x08), line:     814:2  
UCBRKIE              #define, value: (0x10), line:     751:2  
UCBRS0               #define, value: (0x02), line:     781:2  
UCBRS1               #define, value: (0x04), line:     780:2  
UCBRS2               #define, value: (0x08), line:     779:2  
UCBRS_0              #define, value: (0x00), line:     801:2  
UCBRS_1              #define, value: (0x02), line:     802:2  
UCBRS_2              #define, value: (0x04), line:     803:2  
UCBRS_3              #define, value: (0x06), line:     804:2  
UCBRS_4              #define, value: (0x08), line:     805:2  
UCBRS_5              #define, value: (0x0A), line:     806:2  
UCBRS_6              #define, value: (0x0C), line:     807:2  
UCBRS_7              #define, value: (0x0E), line:     808:2  
UCBTOE               #define, value: (0x04), line:     860:2  
UCBUSY               #define, value: (0x01), line:     817:2  
UCCKPH               #define, value: (0x80), line:     733:2  
UCCKPL               #define, value: (0x40), line:     734:2  
UCDELIM0             #define, value: (0x10), line:     858:2  
UCDELIM1             #define, value: (0x20), line:     857:2  
UCDORM               #define, value: (0x08), line:     752:2  
UCFE                 #define, value: (0x40), line:     811:2  
UCGC                 #define, value: (0x20), line:     830:2  
UCGCEN               #define, value: (0x8000u), line:     864:2  
UCIDLE               #define, value: (0x02), line:     818:2  
UCIREN               #define, value: (0x01), line:     844:2  
UCIRRXFE             #define, value: (0x01), line:     853:2  
UCIRRXFL0            #define, value: (0x04), line:     851:2  
UCIRRXFL1            #define, value: (0x08), line:     850:2  
UCIRRXFL2            #define, value: (0x10), line:     849:2  
UCIRRXFL3            #define, value: (0x20), line:     848:2  
UCIRRXFL4            #define, value: (0x40), line:     847:2  
UCIRRXFL5            #define, value: (0x80), line:     846:2  
UCIRRXPL             #define, value: (0x02), line:     852:2  
UCIRTXCLK            #define, value: (0x02), line:     843:2  
UCIRTXPL0            #define, value: (0x04), line:     842:2  
UCIRTXPL1            #define, value: (0x08), line:     841:2  
UCIRTXPL2            #define, value: (0x10), line:     840:2  
UCIRTXPL3            #define, value: (0x20), line:     839:2  
UCIRTXPL4            #define, value: (0x40), line:     838:2  
UCIRTXPL5            #define, value: (0x80), line:     837:2  
UCLISTEN             #define, value: (0x80), line:     810:2  
UCMM                 #define, value: (0x20), line:     740:2  
UCMODE0              #define, value: (0x02), line:     729:2  
UCMODE1              #define, value: (0x04), line:     728:2  
UCMODE_0             #define, value: (0x00), line:     742:2  
UCMODE_1             #define, value: (0x02), line:     743:2  
UCMODE_2             #define, value: (0x04), line:     744:2  
UCMODE_3             #define, value: (0x06), line:     745:2  
UCMSB                #define, value: (0x20), line:     725:2  
UCMST                #define, value: (0x08), line:     735:2  
UCNACKIE             #define, value: (0x08), line:     824:2  
UCNACKIFG            #define, value: (0x08), line:     832:2  
UCOA0                #define, value: (0x0001u), line:     874:2  
UCOA1                #define, value: (0x0002u), line:     873:2  
UCOA2                #define, value: (0x0004u), line:     872:2  
UCOA3                #define, value: (0x0008u), line:     871:2  
UCOA4                #define, value: (0x0010u), line:     870:2  
UCOA5                #define, value: (0x0020u), line:     869:2  
UCOA6                #define, value: (0x0040u), line:     868:2  
UCOA7                #define, value: (0x0080u), line:     867:2  
UCOA8                #define, value: (0x0100u), line:     866:2  
UCOA9                #define, value: (0x0200u), line:     865:2  
UCOE                 #define, value: (0x20), line:     812:2  
UCOS16               #define, value: (0x01), line:     782:2  
UCPAR                #define, value: (0x40), line:     724:2  
UCPE                 #define, value: (0x10), line:     813:2  
UCPEN                #define, value: (0x80), line:     723:2  
UCRXEIE              #define, value: (0x20), line:     750:2  
UCRXERR              #define, value: (0x04), line:     815:2  
UCSA0                #define, value: (0x0001u), line:     885:2  
UCSA1                #define, value: (0x0002u), line:     884:2  
UCSA2                #define, value: (0x0004u), line:     883:2  
UCSA3                #define, value: (0x0008u), line:     882:2  
UCSA4                #define, value: (0x0010u), line:     881:2  
UCSA5                #define, value: (0x0020u), line:     880:2  
UCSA6                #define, value: (0x0040u), line:     879:2  
UCSA7                #define, value: (0x0080u), line:     878:2  
UCSA8                #define, value: (0x0100u), line:     877:2  
UCSA9                #define, value: (0x0200u), line:     876:2  
UCSCLLOW             #define, value: (0x40), line:     829:2  
UCSLA10              #define, value: (0x40), line:     739:2  
UCSPB                #define, value: (0x08), line:     727:2  
UCSSEL0              #define, value: (0x40), line:     749:2  
UCSSEL1              #define, value: (0x80), line:     748:2  
UCSSEL_0             #define, value: (0x00), line:     770:2  
UCSSEL_1             #define, value: (0x40), line:     771:2  
UCSSEL_2             #define, value: (0x80), line:     772:2  
UCSSEL_3             #define, value: (0xC0), line:     773:2  
UCSTOE               #define, value: (0x08), line:     859:2  
UCSTPIE              #define, value: (0x04), line:     825:2  
UCSTPIFG             #define, value: (0x04), line:     833:2  
UCSTTIE              #define, value: (0x02), line:     826:2  
UCSTTIFG             #define, value: (0x02), line:     834:2  
UCSWRST              #define, value: (0x01), line:     755:2  
UCSYNC               #define, value: (0x01), line:     730:2  
UCTR                 #define, value: (0x10), line:     766:2  
UCTXADDR             #define, value: (0x04), line:     753:2  
UCTXBRK              #define, value: (0x02), line:     754:2  
UCTXNACK             #define, value: (0x08), line:     767:2  
UCTXSTP              #define, value: (0x04), line:     768:2  
UCTXSTT              #define, value: (0x02), line:     769:2  
USCIAB0RX_VECTOR     #define, value: (7 * 2u), line:     967:2  
USCIAB0TX_VECTOR     #define, value: (6 * 2u), line:     966:2  
V                    #define, value: (0x0100u), line:      81:2  
W                    #define, value: R6, line:      42:3         53       55       63       63
                                                                       68       68       78       79
                                                                       79      106      107      107
                                                                      116      117      117      127
                                                                      129      129      137      137
                                                                      138      156      158      160
                                                                      160      177      177      183
                                                                      183      188      188      192
                                                                      194      195      195      199
                                                                      202      203      203      207
                                                                      210      211      211      216
                                                                      216      222      222      229
                                                                      229      236      236      243
                                                                      243      249      249      256
                                                                      256      262      262      274
                                                                      274      280      280      285
                                                                      285      289      290      292
                                                                      292      301      302      304
                                                                      307      309      312      314
                                                                      323      329      331      333
                                                                      334      337      337      343
                                                                      346      367      372      372
                                                                      376      377      398      422
                                                                      434      440      441      444
                                                                      445      453      453      461
                                                                      461      467      467      474
                                                                      474      478      479      480
                                                                      481      481      486      486
                                                                      491      491      496      496
                                                                      501      501      507      507
                                                                      512      512      517      517
                                                                      522      522      527      527
                                                                      532      532      536      539
                                                                      539      542      543      543
                                                                      547      551      554      555
                                                                      555      564      564      571
                                                                      571      575      576      579
                                                                      579      587      588      591
                                                                      591      599      600      615
                                                                      615      623      623      641
                                                                      641      654      654      667
                                                                      667      675      675      683
                                                                      683      689      689      705
                                                                      706      713      718      718
                                                                      730      736      749      749
                                                                      757      760      761      765
                                                                      765      773      777      778
                                                                      782      782      787      791
                                                                      794      795      799      799
                                                                      812      815      817      820
                                                                      822      822      827      830
                                                                      832      835      837      837
                                                                      842      846      857      857
                                                                      875      875      886      886
                                                                   1567:5   1568:5   1569:5   1569:5
                                                                   1666:5   1666:5   1673:5   1673:5
                                                                   1680:5   1680:5   1687:5   1687:5
                                                                   1694:5   1694:5   1704:5   1704:5
WAIT                 #define, value: (0x0008u), line:     449:2  
WDTCNTCL             #define, value: (0x0008u), line:     898:2  
WDTCTL_              #define, value: (0x0120u), line:     892:2      893:2
WDTHOLD              #define, value: (0x0080u), line:     902:2  
WDTIE                #define, value: (0x01), line:     129:2  
WDTIFG               #define, value: (0x01), line:     136:2  
WDTIS0               #define, value: (0x0001u), line:     895:2  
WDTIS1               #define, value: (0x0002u), line:     896:2  
WDTNMI               #define, value: (0x0020u), line:     900:2  
WDTNMIES             #define, value: (0x0040u), line:     901:2  
WDTPW                #define, value: (0x5A00u), line:     904:2  
WDTSSEL              #define, value: (0x0004u), line:     897:2  
WDTTMSEL             #define, value: (0x0010u), line:     899:2  
WDT_ADLY_1000        #define, value: (WDTPW+WDTTMSEL+WDTCNTCL+WDTSSEL), line:     913:2  
WDT_ADLY_16          #define, value: (WDTPW+WDTTMSEL+WDTCNTCL+WDTSSEL+WDTIS1), line:     915:2  
WDT_ADLY_1_9         #define, value: (WDTPW+WDTTMSEL+WDTCNTCL+WDTSSEL+WDTIS1+WDTIS0), line:     916:2  
WDT_ADLY_250         #define, value: (WDTPW+WDTTMSEL+WDTCNTCL+WDTSSEL+WDTIS0), line:     914:2  
WDT_ARST_1000        #define, value: (WDTPW+WDTCNTCL+WDTSSEL), line:     924:2  
WDT_ARST_16          #define, value: (WDTPW+WDTCNTCL+WDTSSEL+WDTIS1), line:     926:2  
WDT_ARST_1_9         #define, value: (WDTPW+WDTCNTCL+WDTSSEL+WDTIS1+WDTIS0), line:     927:2  
WDT_ARST_250         #define, value: (WDTPW+WDTCNTCL+WDTSSEL+WDTIS0), line:     925:2  
WDT_MDLY_0_064       #define, value: (WDTPW+WDTTMSEL+WDTCNTCL+WDTIS1+WDTIS0), line:     911:2  
WDT_MDLY_0_5         #define, value: (WDTPW+WDTTMSEL+WDTCNTCL+WDTIS1), line:     910:2  
WDT_MDLY_32          #define, value: (WDTPW+WDTTMSEL+WDTCNTCL), line:     908:2  
WDT_MDLY_8           #define, value: (WDTPW+WDTTMSEL+WDTCNTCL+WDTIS0), line:     909:2  
WDT_MRST_0_064       #define, value: (WDTPW+WDTCNTCL+WDTIS1+WDTIS0), line:     922:2  
WDT_MRST_0_5         #define, value: (WDTPW+WDTCNTCL+WDTIS1), line:     921:2  
WDT_MRST_32          #define, value: (WDTPW+WDTCNTCL), line:     919:2  
WDT_MRST_8           #define, value: (WDTPW+WDTCNTCL+WDTIS0), line:     920:2  
WDT_VECTOR           #define, value: (10 * 2u), line:     970:2  
WRT                  #define, value: (0x0040u), line:     422:2        365      396      429
X                    #define, value: R10, line:      50:3        423      436      437      444
                                                                      756      758      762      774
                                                                      777      788      792      793
                                                                      795      811      813      818
                                                                      821      826      828      833
                                                                      836      843      846      848
XCAP0                #define, value: (0x04), line:     338:2  
XCAP1                #define, value: (0x08), line:     339:2  
XCAP_0               #define, value: (0x00), line:     345:2  
XCAP_1               #define, value: (0x04), line:     346:2  
XCAP_2               #define, value: (0x08), line:     347:2  
XCAP_3               #define, value: (0x0C), line:     348:2  
XT2OF                #define, value: (0x02), line:     337:2  
XT2OFF               #define, value: (0x80), line:     306:2  
XT2S0                #define, value: (0x40), line:     342:2  
XT2S1                #define, value: (0x80), line:     343:2  
XT2S_0               #define, value: (0x00), line:     355:2  
XT2S_1               #define, value: (0x40), line:     356:2  
XT2S_2               #define, value: (0x80), line:     357:2  
XT2S_3               #define, value: (0xC0), line:     358:2  
XTS                  #define, value: (0x40), line:     305:2  
Y                    #define, value: R11, line:      51:3        436      439      440
Z                    #define, value: (0x0002u), line:      79:2  
__430X_CORE__        #define, value: 1, line:         0  
__430_CORE__         #define, value: 0, line:         0  
__A430__             #define, value: 1, line:         0  
__BUILD_NUMBER__     #define,            line:         0  
__CORE__             #define, value: 0, line:         0  
__DATE__             #define,            line:         0         41
__FILE__             #define,            line:         0  
__IAR_SYSTEMS_ASM    #define,            line:         0  
__IAR_SYSTEMS_ASM__  #define,            line:         0  
__LINE__             #define,            line:         0  
__MSP430G2553        #define, value: , line:      16:2  
__MSP430G2553__      #define, value: 1, line:         0  
__MSP430_HAS_ADC10__ #define, value: , line:     161:2  
__MSP430_HAS_BC2__   #define, value: , line:     279:2  
__MSP430_HAS_CAPLUS__ #define, value: , line:     363:2  
__MSP430_HAS_FLASH2__ #define, value: , line:     407:2  
__MSP430_HAS_PORT1_R__ #define, value: , line:     458:2  
__MSP430_HAS_PORT2_R__ #define, value: , line:     459:2  
__MSP430_HAS_PORT3_R__ #define, value: , line:     502:2  
__MSP430_HAS_T1A3__  #define, value: , line:     642:2  
__MSP430_HAS_TA3__   #define, value: , line:     520:2  
__MSP430_HAS_USCI__  #define, value: , line:     674:2  
__MSP430_HAS_WDT__   #define, value: , line:     890:2  
__SUBVERSION__       #define,            line:         0  
__TID__              #define,            line:         0       24:2
__TIME__             #define,            line:         0  
__VER__              #define,            line:         0  
__msp430             #define, value: , line:       9:1  

Segment             Type 	Mode
----------------------------------------
CODE                UNTYPED  	REL 

Label               Mode   Type                   Segment    Value/Offset
------------------------------------------------------------------------------
ABBS                REL    CONST PUB UNTYP.       CODE       AA6 
ABORT               REL    CONST PUB UNTYP.       CODE       1398 
ABORTQUOTE          REL    CONST PUB UNTYP.       CODE       13C4 
ACC1                REL    CONST UNTYP.           CODE       D24 
ACC3                REL    CONST UNTYP.           CODE       D5A 
ACC4                REL    CONST UNTYP.           CODE       D64 
ACC5                REL    CONST UNTYP.           CODE       D68 
ACCEPT              REL    CONST PUB UNTYP.       CODE       D1A 
ADC10AE0            ABS    CONST UNTYP.           ASEG       4A 
ADC10CTL0           ABS    CONST UNTYP.           ASEG       1B0 
ADC10CTL1           ABS    CONST UNTYP.           ASEG       1B2 
ADC10DTC0           ABS    CONST UNTYP.           ASEG       48 
ADC10DTC1           ABS    CONST UNTYP.           ASEG       49 
ADC10MEM            ABS    CONST UNTYP.           ASEG       1B4 
ADC10SA             ABS    CONST UNTYP.           ASEG       1BC 
AGAIN               REL    CONST PUB UNTYP.       CODE       1628 
ALIGNED             REL    CONST PUB UNTYP.       CODE       7F6 
ALIGNN              REL    CONST PUB UNTYP.       CODE       7DC 
ALLOT               REL    CONST PUB UNTYP.       CODE       F9A 
ANDD                REL    CONST PUB UNTYP.       CODE       3EC 
APP                 REL    CONST PUB UNTYP.       CODE       9B4 
APPCRC              REL    CONST PUB UNTYP.       CODE       19B2 
APPU0               REL    CONST PUB UNTYP.       CODE       A72 
ATXY                REL    CONST PUB UNTYP.       CODE       1B6A 
AppU0               ABS    CONST EXT [012] UNTYP. __EXTERNS  Solved Extern 
BACKSLASH           REL    CONST PUB UNTYP.       CODE       1AEE 
BASE                REL    CONST PUB UNTYP.       CODE       944 
BCSCTL1             ABS    CONST UNTYP.           ASEG       57 
BCSCTL2             ABS    CONST UNTYP.           ASEG       58 
BCSCTL3             ABS    CONST UNTYP.           ASEG       53 
BEGIN               REL    CONST PUB UNTYP.       CODE       1602 
BELL                REL    CONST PUB UNTYP.       CODE       1B26 
BIN                 REL    CONST PUB UNTYP.       CODE       1BA6 
BLANK               REL    CONST PUB UNTYP.       CODE       A10 
BOOT                REL    CONST PUB UNTYP.       CODE       1A10 
BOOTIP              REL    CONST PUB UNTYP.       CODE       1A12 
BRACCHAR            REL    CONST PUB UNTYP.       CODE       1408 
BRACTICK            REL    CONST PUB UNTYP.       CODE       1570 
BUILDS              REL    CONST PUB UNTYP.       CODE       1460 
CACTL1              ABS    CONST UNTYP.           ASEG       59 
CACTL2              ABS    CONST UNTYP.           ASEG       5A 
CALBC1_12MHZ        ABS    CONST UNTYP.           ASEG       10FB 
CALBC1_16MHZ        ABS    CONST UNTYP.           ASEG       10F9 
CALBC1_1MHZ         ABS    CONST UNTYP.           ASEG       10FF 
CALBC1_8MHZ         ABS    CONST UNTYP.           ASEG       10FD 
CALDCO_12MHZ        ABS    CONST UNTYP.           ASEG       10FA 
CALDCO_16MHZ        ABS    CONST UNTYP.           ASEG       10F8 
CALDCO_1MHZ         ABS    CONST UNTYP.           ASEG       10FE 
CALDCO_8MHZ         ABS    CONST UNTYP.           ASEG       10FC 
CAPD                ABS    CONST UNTYP.           ASEG       5B 
CAPITALIZE          REL    CONST PUB UNTYP.       CODE       116A 
CAPS                REL    CONST PUB UNTYP.       CODE       9C0 
CAPS1               REL    CONST UNTYP.           CODE       1180 
CAPS2               REL    CONST UNTYP.           CODE       118E 
CCOMMA              REL    CONST PUB UNTYP.       CODE       FBE 
CCRC                REL    CONST PUB UNTYP.       CODE       190A 
CELL                REL    CONST PUB UNTYP.       CODE       80C 
CELLPLUS            REL    CONST PUB UNTYP.       CODE       81A 
CELLS               REL    CONST PUB UNTYP.       CODE       82A 
CEXIT               REL    CONST PUB UNTYP.       CODE       8D0 
CF430FRend          REL    CONST UNTYP.           CODE       1D18 
CFETCH              REL    CONST PUB UNTYP.       CODE       224 
CHARPLUS            REL    CONST PUB UNTYP.       CODE       836 
CHARR               REL    CONST PUB UNTYP.       CODE       13F2 
CHARS               REL    CONST PUB UNTYP.       CODE       842 
CMOVE               REL    CONST PUB UNTYP.       CODE       6AC 
CMOVEUP             REL    CONST PUB UNTYP.       CODE       6D0 
CMOVE_1             REL    CONST UNTYP.           CODE       6B6 
CMOVE_X             REL    CONST UNTYP.           CODE       6C0 
CMOVU_1             REL    CONST UNTYP.           CODE       6DE 
CMOVU_X             REL    CONST UNTYP.           CODE       6EA 
COLD                REL    CONST PUB UNTYP.       CODE       1A72 
COLON               REL    CONST PUB UNTYP.       CODE       154C 
COMMA               REL    CONST PUB UNTYP.       CODE       FA8 
COMMABRANCH         REL    CONST PUB UNTYP.       CODE       8E6 
COMMACALL           REL    CONST PUB UNTYP.       CODE       88C 
COMMACF             REL    CONST PUB UNTYP.       CODE       874 
COMMADEST           REL    CONST PUB UNTYP.       CODE       8F4 
COMMAJMP            REL    CONST PUB UNTYP.       CODE       8A0 
COMMANONE           REL    CONST PUB UNTYP.       CODE       91E 
COMMAXT             REL    CONST PUB UNTYP.       CODE       85C 
CONSTANT            REL    CONST PUB UNTYP.       CODE       7E 
COR                 REL    CONST PUB UNTYP.       CODE       A56 
CORPOWERON          ABS    CONST UNTYP.           CODE       186 
CORREST             ABS    CONST UNTYP.           CODE       18E 
COUNT               REL    CONST PUB UNTYP.       CODE       C8E 
CR                  REL    CONST PUB UNTYP.       CODE       CA0 
CRC                 REL    CONST PUB UNTYP.       CODE       1970 
CREATE              REL    CONST PUB UNTYP.       CODE       1476 
CSTORE              REL    CONST PUB UNTYP.       CODE       232 
DABS                REL    CONST PUB UNTYP.       CODE       AEC 
DCOCTL              ABS    CONST UNTYP.           ASEG       56 
DDP                 REL    CONST PUB UNTYP.       CODE       95C 
DECIMAL             REL    CONST PUB UNTYP.       CODE       F60 
DEPTH               REL    CONST PUB UNTYP.       CODE       1752 
DIGITQ              REL    CONST PUB UNTYP.       CODE       11BA 
DIV1                REL    CONST UNTYP.           CODE       65A 
DIV2                REL    CONST UNTYP.           CODE       660 
DIV3                REL    CONST UNTYP.           CODE       674 
DIV4                REL    CONST UNTYP.           CODE       676 
DIVIDE              REL    CONST UNTYP.           CODE       654 
DNEG1               REL    CONST UNTYP.           CODE       AE2 
DNEGATE             REL    CONST PUB UNTYP.       CODE       ABA 
DO                  REL    CONST PUB UNTYP.       CODE       168C 
DOALIAS             REL    CONST PUB UNTYP.       CODE       BE 
DOCODE              REL    CONST UNTYP.           CODE       Not solved 
DOCOLON             REL    CONST PUB UNTYP.       CODE       54 
DOCON               REL    CONST PUB UNTYP.       CODE       86 
DOES                REL    CONST PUB UNTYP.       CODE       14AA 
DOROM               REL    CONST PUB UNTYP.       CODE       92 
DOT                 REL    CONST PUB UNTYP.       CODE       F3C 
DOTCOLD             REL    CONST PUB UNTYP.       CODE       1A5C 
DOTQUOTE            REL    CONST PUB UNTYP.       CODE       E08 
DOTS                REL    CONST PUB UNTYP.       CODE       18C2 
DOTS1               REL    CONST UNTYP.           CODE       18F2 
DOTS2               REL    CONST UNTYP.           CODE       1900 
DOTSTATUS           REL    CONST PUB UNTYP.       CODE       133E 
DOTVER              REL    CONST PUB UNTYP.       CODE       1B02 
DOTWOCON            REL    CONST PUB UNTYP.       CODE       1AD8 
DOUSER              REL    CONST PUB UNTYP.       CODE       AE 
DOVAR               REL    CONST PUB UNTYP.       CODE       86 
DROP                REL    CONST PUB UNTYP.       CODE       104 
DTOI                REL    CONST PUB UNTYP.       CODE       34C 
DTOI_BYTE           REL    CONST UNTYP.           CODE       37E 
DTOI_END            REL    CONST UNTYP.           CODE       384 
DTOI_LOOP           REL    CONST UNTYP.           CODE       356 
DTOI_WORD           REL    CONST UNTYP.           CODE       36C 
DTOI_X              REL    CONST UNTYP.           CODE       396 
DUMP                REL    CONST PUB UNTYP.       CODE       1856 
DUP                 REL    CONST PUB UNTYP.       CODE       DE 
ELSS                REL    CONST PUB UNTYP.       CODE       15E6 
EMIT                REL    CONST PUB UNTYP.       CODE       77E 
EMITLOOP            REL    CONST UNTYP.           CODE       780 
ENDLOOP             REL    CONST PUB UNTYP.       CODE       16A8 
ENVIRONMENTQ        REL    CONST PUB UNTYP.       CODE       1770 
EQUAL               REL    CONST PUB UNTYP.       CODE       4E8 
ESC0                REL    CONST UNTYP.           CODE       1B91 
ESC1                REL    CONST UNTYP.           CODE       1B94 
ESCPAR              REL    CONST PUB UNTYP.       CODE       1B30 
EVALUATE            REL    CONST PUB UNTYP.       CODE       131C 
EXECUTE             REL    CONST PUB UNTYP.       CODE       26 
EXIT                REL    CONST PUB UNTYP.       CODE       4C 
FACTORY             REL    CONST PUB UNTYP.       CODE       1A90 
FACTORYIP           REL    CONST PUB UNTYP.       CODE       1A92 
FCTL1               ABS    CONST UNTYP.           ASEG       128 
FCTL2               ABS    CONST UNTYP.           ASEG       12A 
FCTL3               ABS    CONST UNTYP.           ASEG       12C 
FETCH               REL    CONST PUB UNTYP.       CODE       204 
FILL                REL    CONST PUB UNTYP.       CODE       688 
FILL_1              REL    CONST UNTYP.           CODE       692 
FILL_X              REL    CONST UNTYP.           CODE       69C 
FIND                REL    CONST PUB UNTYP.       CODE       110A 
FIND1               REL    CONST UNTYP.           CODE       1110 
FIND2               REL    CONST UNTYP.           CODE       1128 
FIND3               REL    CONST UNTYP.           CODE       1146 
FLALIGNED           REL    CONST PUB UNTYP.       CODE       1792 
FLERASE             REL    CONST PUB UNTYP.       CODE       24C 
FLE_1               REL    CONST UNTYP.           CODE       252 
FLE_INFO            REL    CONST UNTYP.           CODE       262 
FLE_OK              REL    CONST UNTYP.           CODE       26E 
FLE_X               REL    CONST UNTYP.           CODE       2A4 
FL_INFO             REL    CONST UNTYP.           CODE       29E 
FMMOD1              REL    CONST UNTYP.           CODE       B70 
FMSLASHMOD          REL    CONST PUB UNTYP.       CODE       B4A 
GREATER             REL    CONST PUB UNTYP.       CODE       51E 
HEADR               REL    CONST PUB UNTYP.       CODE       1432 
HERE                REL    CONST PUB UNTYP.       CODE       F88 
HEX                 REL    CONST PUB UNTYP.       CODE       F74 
HIDE                REL    CONST PUB UNTYP.       CODE       14FC 
HOLD                REL    CONST PUB UNTYP.       CODE       E80 
HP                  REL    CONST PUB UNTYP.       CODE       984 
IALLOT              REL    CONST PUB UNTYP.       CODE       FEA 
ICCOMMA             REL    CONST PUB UNTYP.       CODE       1010 
ICOMMA              REL    CONST PUB UNTYP.       CODE       FF8 
ICSTORE             REL    CONST PUB UNTYP.       CODE       302 
ICST_INFO           REL    CONST UNTYP.           CODE       316 
ICST_OK             REL    CONST UNTYP.           CODE       322 
ICST_RAM            REL    CONST UNTYP.           CODE       330 
IDP                 REL    CONST PUB UNTYP.       CODE       99A 
IE1                 ABS    CONST UNTYP.           ASEG       0 
IE2                 ABS    CONST UNTYP.           ASEG       1 
IFF                 REL    CONST PUB UNTYP.       CODE       15BE 
IFG1                ABS    CONST UNTYP.           ASEG       2 
IFG2                ABS    CONST UNTYP.           ASEG       3 
IHERE               REL    CONST PUB UNTYP.       CODE       FD8 
II                  REL    CONST PUB UNTYP.       CODE       5DA 
IMMEDIATE           REL    CONST PUB UNTYP.       CODE       1536 
IMMEDQ              REL    CONST PUB UNTYP.       CODE       10F2 
INFOB               REL    CONST PUB UNTYP.       CODE       A64 
INTER1              REL    CONST UNTYP.           CODE       12BE 
INTER2              REL    CONST UNTYP.           CODE       12E8 
INTER3              REL    CONST UNTYP.           CODE       12EA 
INTER4              REL    CONST UNTYP.           CODE       12EE 
INTER5              REL    CONST UNTYP.           CODE       12FA 
INTER6              REL    CONST UNTYP.           CODE       1308 
INTER8              REL    CONST UNTYP.           CODE       1308 
INTER9              REL    CONST UNTYP.           CODE       130C 
INTERPRET           REL    CONST PUB UNTYP.       CODE       12B2 
INVERT              REL    CONST PUB UNTYP.       CODE       41C 
ISQUOTE             REL    CONST PUB UNTYP.       CODE       DEA 
ISTORE              REL    CONST PUB UNTYP.       CODE       2B0 
IST_INFO            REL    CONST UNTYP.           CODE       2C8 
IST_OK              REL    CONST UNTYP.           CODE       2D4 
IST_RAM             REL    CONST UNTYP.           CODE       2E2 
IST_X               REL    CONST UNTYP.           CODE       2F4 
ITHERE              REL    CONST PUB UNTYP.       CODE       1986 
ITOD                REL    CONST PUB UNTYP.       CODE       6F8 
IWORD               REL    CONST PUB UNTYP.       CODE       E1E 
IWORD1              REL    CONST UNTYP.           CODE       E22 
IWORDC              REL    CONST PUB UNTYP.       CODE       E30 
JJ                  REL    CONST PUB UNTYP.       CODE       5F0 
KEY                 REL    CONST PUB UNTYP.       CODE       798 
KEYLOOP             REL    CONST UNTYP.           CODE       79A 
KEYQ                REL    CONST PUB UNTYP.       CODE       7B6 
L$002               REL    CONST UNTYP.           CODE       62A 
L$01                REL    CONST UNTYP.           CODE       632 
L0                  REL    CONST PUB UNTYP.       CODE       9D6 
LATEST              REL    CONST PUB UNTYP.       CODE       97A 
LDUMP1              REL    CONST UNTYP.           CODE       1860 
LDUMP2              REL    CONST UNTYP.           CODE       187A 
LDUMP3              REL    CONST UNTYP.           CODE       1898 
LEAV                REL    CONST PUB UNTYP.       CODE       16EE 
LEFTBRACKET         REL    CONST PUB UNTYP.       CODE       14D8 
LESS                REL    CONST PUB UNTYP.       CODE       50A 
LESSNUM             REL    CONST PUB UNTYP.       CODE       E98 
LFROM               REL    CONST PUB UNTYP.       CODE       1674 
LITER1              REL    CONST UNTYP.           CODE       11AE 
LITERAL             REL    CONST PUB UNTYP.       CODE       119C 
LOO                 REL    CONST PUB UNTYP.       CODE       16C6 
LOOP1               REL    CONST UNTYP.           CODE       16AE 
LOOP2               REL    CONST UNTYP.           CODE       16BC 
LP                  REL    CONST PUB UNTYP.       CODE       98E 
LSHIFT              REL    CONST PUB UNTYP.       CODE       488 
LSH_1               REL    CONST UNTYP.           CODE       492 
LSH_X               REL    CONST UNTYP.           CODE       498 
LSTACK              ABS    CONST EXT [003] UNTYP. __EXTERNS  Solved Extern 
MACU                REL    CONST UNTYP.           CODE       626 
MARKER              REL    CONST PUB UNTYP.       CODE       17B0 
MAX                 REL    CONST PUB UNTYP.       CODE       BE2 
MAX1                REL    CONST UNTYP.           CODE       BEE 
MEM                 REL    CONST PUB UNTYP.       CODE       1C9C 
MEMBOT              REL    CONST PUB UNTYP.       CODE       1C82 
MEMTOP              REL    CONST PUB UNTYP.       CODE       1C90 
MIN                 REL    CONST PUB UNTYP.       CODE       BFA 
MIN1                REL    CONST UNTYP.           CODE       C06 
MINUS               REL    CONST PUB UNTYP.       CODE       3D8 
MODD                REL    CONST PUB UNTYP.       CODE       BAE 
MOVE                REL    CONST PUB UNTYP.       CODE       1726 
MOVE1               REL    CONST UNTYP.           CODE       1742 
MOVE2               REL    CONST UNTYP.           CODE       1746 
MPLUS               REL    CONST PUB UNTYP.       CODE       3C2 
MPYU                REL    CONST UNTYP.           CODE       622 
MS                  REL    CONST PUB UNTYP.       CODE       1BDC 
MSTAR               REL    CONST PUB UNTYP.       CODE       AFA 
NEGATE              REL    CONST PUB UNTYP.       CODE       42E 
NEQUAL              REL    CONST PUB UNTYP.       CODE       774 
NEWEST              REL    CONST PUB UNTYP.       CODE       9A8 
NFATOCFA            REL    CONST PUB UNTYP.       CODE       10D8 
NFATOLFA            REL    CONST PUB UNTYP.       CODE       10C2 
NINIT               REL    CONST PUB UNTYP.       CODE       A4A 
NIP                 REL    CONST PUB UNTYP.       CODE       15E 
NODUP               REL    CONST UNTYP.           CODE       F8 
NOOP                REL    CONST PUB UNTYP.       CODE       1780 
NOTEQUAL            REL    CONST PUB UNTYP.       CODE       4FC 
NUM                 REL    CONST PUB UNTYP.       CODE       ECC 
NUMGREATER          REL    CONST PUB UNTYP.       CODE       EF8 
NUMS                REL    CONST PUB UNTYP.       CODE       EE2 
NUMS1               REL    CONST UNTYP.           CODE       EE4 
ONEMINUS            REL    CONST PUB UNTYP.       CODE       44C 
ONEMS               REL    CONST PUB UNTYP.       CODE       1BBA 
ONEPLUS             REL    CONST PUB UNTYP.       CODE       43E 
ORR                 REL    CONST PUB UNTYP.       CODE       3FA 
OVER                REL    CONST PUB UNTYP.       CODE       12A 
P1                  REL    CONST PUB UNTYP.       CODE       1CC4 
P1DIR               ABS    CONST UNTYP.           ASEG       22 
P1IE                ABS    CONST UNTYP.           ASEG       25 
P1IES               ABS    CONST UNTYP.           ASEG       24 
P1IFG               ABS    CONST UNTYP.           ASEG       23 
P1IN                ABS    CONST UNTYP.           ASEG       20 
P1OUT               ABS    CONST UNTYP.           ASEG       21 
P1REN               ABS    CONST UNTYP.           ASEG       27 
P1SEL               ABS    CONST UNTYP.           ASEG       26 
P1SEL2              ABS    CONST UNTYP.           ASEG       41 
P2                  REL    CONST PUB UNTYP.       CODE       1CCE 
P2DIR               ABS    CONST UNTYP.           ASEG       2A 
P2IE                ABS    CONST UNTYP.           ASEG       2D 
P2IES               ABS    CONST UNTYP.           ASEG       2C 
P2IFG               ABS    CONST UNTYP.           ASEG       2B 
P2IN                ABS    CONST UNTYP.           ASEG       28 
P2OUT               ABS    CONST UNTYP.           ASEG       29 
P2REN               ABS    CONST UNTYP.           ASEG       2F 
P2SEL               ABS    CONST UNTYP.           ASEG       2E 
P2SEL2              ABS    CONST UNTYP.           ASEG       42 
P3                  REL    CONST PUB UNTYP.       CODE       1CD8 
P3DIR               ABS    CONST UNTYP.           ASEG       1A 
P3IN                ABS    CONST UNTYP.           ASEG       18 
P3OUT               ABS    CONST UNTYP.           ASEG       19 
P3REN               ABS    CONST UNTYP.           ASEG       10 
P3SEL               ABS    CONST UNTYP.           ASEG       1B 
P3SEL2              ABS    CONST UNTYP.           ASEG       43 
PAD                 REL    CONST PUB UNTYP.       CODE       9CC 
PADAREA             ABS    CONST EXT [002] UNTYP. __EXTERNS  Solved Extern 
PAGEE               REL    CONST PUB UNTYP.       CODE       1B8A 
PAREN               REL    CONST PUB UNTYP.       CODE       141C 
PCRC                REL    CONST PUB UNTYP.       CODE       1946 
PLUS                REL    CONST PUB UNTYP.       CODE       3A2 
PLUSLOOP            REL    CONST PUB UNTYP.       CODE       16DA 
PLUSSTORE           REL    CONST PUB UNTYP.       CODE       3B0 
PN                  REL    CONST PUB UNTYP.       CODE       1B40 
POST1               REL    CONST UNTYP.           CODE       15B4 
POST2               REL    CONST UNTYP.           CODE       15B6 
POSTPONE            REL    CONST PUB UNTYP.       CODE       158A 
PROMPT              REL    CONST PUB UNTYP.       CODE       134A 
PROMPT1             REL    CONST UNTYP.           CODE       135E 
PSTACK              ABS    CONST EXT [004] UNTYP. __EXTERNS  Solved Extern 
PUSHTOS             REL    CONST UNTYP.           CODE       E0 
QABO1               REL    CONST UNTYP.           CODE       13B6 
QABORT              REL    CONST PUB UNTYP.       CODE       13AA 
QDNEGATE            REL    CONST PUB UNTYP.       CODE       AD8 
QDUP                REL    CONST PUB UNTYP.       CODE       F2 
QNEG1               REL    CONST UNTYP.           CODE       A9C 
QNEGATE             REL    CONST PUB UNTYP.       CODE       A92 
QNUM1               REL    CONST UNTYP.           CODE       1292 
QNUM2               REL    CONST UNTYP.           CODE       129E 
QNUM3               REL    CONST UNTYP.           CODE       12A2 
QNUMBER             REL    CONST PUB UNTYP.       CODE       126E 
QSIGN               REL    CONST PUB UNTYP.       CODE       11F6 
QSIGN1              REL    CONST UNTYP.           CODE       1220 
QUIT                REL    CONST PUB UNTYP.       CODE       1368 
QUIT1               REL    CONST UNTYP.           CODE       137A 
QUITIP              REL    CONST PUB UNTYP.       CODE       136A 
RAMDICT             ABS    CONST EXT [007] UNTYP. __EXTERNS  Solved Extern 
RECURSE             REL    CONST PUB UNTYP.       CODE       14C6 
REPEAT              REL    CONST PUB UNTYP.       CODE       1650 
REVEAL              REL    CONST PUB UNTYP.       CODE       151C 
RFETCH              REL    CONST PUB UNTYP.       CODE       190 
RFROM               REL    CONST PUB UNTYP.       CODE       17C 
RIGHTBRACKET        REL    CONST PUB UNTYP.       CODE       14E8 
ROMDICT             ABS    CONST EXT [-001] UNTYP. __EXTERNS  Solved Extern 
ROT                 REL    CONST PUB UNTYP.       CODE       142 
RPFETCH             REL    CONST PUB UNTYP.       CODE       1CE 
RPSTORE             REL    CONST PUB UNTYP.       CODE       1E4 
RSHIFT              REL    CONST PUB UNTYP.       CODE       4A8 
RSH_1               REL    CONST UNTYP.           CODE       4B2 
RSH_X               REL    CONST UNTYP.           CODE       4BA 
RSTACK              ABS    CONST EXT [005] UNTYP. __EXTERNS  Solved Extern 
RZERO               REL    CONST PUB UNTYP.       CODE       9E0 
S0                  REL    CONST PUB UNTYP.       CODE       9EA 
S2                  REL    CONST PUB UNTYP.       CODE       1D00 
SAVE                REL    CONST PUB UNTYP.       CODE       19EC 
SCAN                REL    CONST PUB UNTYP.       CODE       728 
SCAN_1              REL    CONST UNTYP.           CODE       732 
SCAN_X              REL    CONST UNTYP.           CODE       73C 
SEMICOLON           REL    CONST PUB UNTYP.       CODE       155E 
SEMIPN              REL    CONST PUB UNTYP.       CODE       1B54 
SEQUAL              REL    CONST PUB UNTYP.       CODE       74C 
SEQU_1              REL    CONST UNTYP.           CODE       756 
SEQU_X              REL    CONST UNTYP.           CODE       76A 
SIGN                REL    CONST PUB UNTYP.       CODE       F10 
SIGN1               REL    CONST UNTYP.           CODE       F1E 
SKIP                REL    CONST PUB UNTYP.       CODE       702 
SKIP_1              REL    CONST UNTYP.           CODE       70C 
SKIP_X              REL    CONST UNTYP.           CODE       716 
SLASH               REL    CONST PUB UNTYP.       CODE       B9E 
SLASHMOD            REL    CONST PUB UNTYP.       CODE       B8C 
SLASHSTRING         REL    CONST PUB UNTYP.       CODE       103E 
SMISMATCH           REL    CONST UNTYP.           CODE       764 
SMSLASHREM          REL    CONST PUB UNTYP.       CODE       B1C 
SOURCE              REL    CONST PUB UNTYP.       CODE       102A 
SPACE               REL    CONST PUB UNTYP.       CODE       CBA 
SPACES              REL    CONST PUB UNTYP.       CODE       CCC 
SPCS1               REL    CONST UNTYP.           CODE       CCE 
SPCS2               REL    CONST UNTYP.           CODE       CDC 
SPFETCH             REL    CONST PUB UNTYP.       CODE       1A6 
SPSTORE             REL    CONST PUB UNTYP.       CODE       1BC 
SQEST               REL    CONST PUB UNTYP.       CODE       1D0E 
SSMOD               REL    CONST PUB UNTYP.       CODE       BC0 
STAR                REL    CONST PUB UNTYP.       CODE       B7C 
STARSLASH           REL    CONST PUB UNTYP.       CODE       BD2 
STATE               REL    CONST PUB UNTYP.       CODE       952 
STOD                REL    CONST PUB UNTYP.       CODE       A7E 
STORCOLON           REL    CONST PUB UNTYP.       CODE       8B6 
STORE               REL    CONST PUB UNTYP.       CODE       212 
STORECF             REL    CONST PUB UNTYP.       CODE       868 
STOREDEST           REL    CONST PUB UNTYP.       CODE       908 
SWAP                REL    CONST PUB UNTYP.       CODE       114 
SWAPBYTES           REL    CONST PUB UNTYP.       CODE       45A 
TA0CCR0             ABS    CONST UNTYP.           ASEG       172 
TA0CCR1             ABS    CONST UNTYP.           ASEG       174 
TA0CCR2             ABS    CONST UNTYP.           ASEG       176 
TA0CCTL0            ABS    CONST UNTYP.           ASEG       162 
TA0CCTL1            ABS    CONST UNTYP.           ASEG       164 
TA0CCTL2            ABS    CONST UNTYP.           ASEG       166 
TA0CTL              ABS    CONST UNTYP.           ASEG       160 
TA0IV               ABS    CONST UNTYP.           ASEG       12E 
TA0R                ABS    CONST UNTYP.           ASEG       170 
TA1CCR0             ABS    CONST UNTYP.           ASEG       192 
TA1CCR1             ABS    CONST UNTYP.           ASEG       194 
TA1CCR2             ABS    CONST UNTYP.           ASEG       196 
TA1CCTL0            ABS    CONST UNTYP.           ASEG       182 
TA1CCTL1            ABS    CONST UNTYP.           ASEG       184 
TA1CCTL2            ABS    CONST UNTYP.           ASEG       186 
TA1CTL              ABS    CONST UNTYP.           ASEG       180 
TA1IV               ABS    CONST UNTYP.           ASEG       11E 
TA1R                ABS    CONST UNTYP.           ASEG       190 
THEN                REL    CONST PUB UNTYP.       CODE       15D4 
TIB                 REL    CONST PUB UNTYP.       CODE       9F6 
TIBAREA             ABS    CONST EXT [006] UNTYP. __EXTERNS  Solved Extern 
TIBSIZE             REL    CONST PUB UNTYP.       CODE       A06 
TIB_SIZE            ABS    CONST EXT [008] UNTYP. __EXTERNS  Solved Extern 
TICK                REL    CONST PUB UNTYP.       CODE       13D6 
TICKSOURCE          REL    CONST PUB UNTYP.       CODE       96C 
TOBODY              REL    CONST PUB UNTYP.       CODE       84E 
TOCOUNTED           REL    CONST PUB UNTYP.       CODE       105A 
TODIGIT             REL    CONST PUB UNTYP.       CODE       EAC 
TOIN                REL    CONST PUB UNTYP.       CODE       938 
TOL                 REL    CONST PUB UNTYP.       CODE       165E 
TONUM1              REL    CONST UNTYP.           CODE       1230 
TONUM2              REL    CONST UNTYP.           CODE       1246 
TONUM3              REL    CONST UNTYP.           CODE       1260 
TONUMBER            REL    CONST PUB UNTYP.       CODE       122E 
TOR                 REL    CONST PUB UNTYP.       CODE       16C 
TOSFALSE            REL    CONST UNTYP.           CODE       4F0 
TOSTRUE             REL    CONST UNTYP.           CODE       512 
TUCK                REL    CONST PUB UNTYP.       CODE       1F6 
TWOCONSTANT         REL    CONST PUB UNTYP.       CODE       1ACE 
TWODROP             REL    CONST PUB UNTYP.       CODE       C3C 
TWODUP              REL    CONST PUB UNTYP.       CODE       C4C 
TWOFETCH            REL    CONST PUB UNTYP.       CODE       C10 
TWOOVER             REL    CONST PUB UNTYP.       CODE       C74 
TWOSLASH            REL    CONST PUB UNTYP.       CODE       476 
TWOSTAR             REL    CONST PUB UNTYP.       CODE       468 
TWOSTORE            REL    CONST PUB UNTYP.       CODE       C24 
TWOSWAP             REL    CONST PUB UNTYP.       CODE       C5E 
TYP                 REL    CONST PUB UNTYP.       CODE       D7A 
TYP3                REL    CONST UNTYP.           CODE       D8A 
TYP4                REL    CONST UNTYP.           CODE       D98 
TYP5                REL    CONST UNTYP.           CODE       D9A 
U0                  REL    CONST PUB UNTYP.       CODE       92C 
UAREA               ABS    CONST EXT [001] UNTYP. __EXTERNS  Solved Extern 
UAREA_SIZE          ABS    CONST EXT [009] UNTYP. __EXTERNS  Solved Extern 
UCA0ABCTL           ABS    CONST UNTYP.           ASEG       5D 
UCA0BR0             ABS    CONST UNTYP.           ASEG       62 
UCA0BR1             ABS    CONST UNTYP.           ASEG       63 
UCA0CTL0            ABS    CONST UNTYP.           ASEG       60 
UCA0CTL1            ABS    CONST UNTYP.           ASEG       61 
UCA0IRRCTL          ABS    CONST UNTYP.           ASEG       5F 
UCA0IRTCTL          ABS    CONST UNTYP.           ASEG       5E 
UCA0MCTL            ABS    CONST UNTYP.           ASEG       64 
UCA0RXBUF           ABS    CONST UNTYP.           ASEG       66 
UCA0STAT            ABS    CONST UNTYP.           ASEG       65 
UCA0TXBUF           ABS    CONST UNTYP.           ASEG       67 
UCB0BR0             ABS    CONST UNTYP.           ASEG       6A 
UCB0BR1             ABS    CONST UNTYP.           ASEG       6B 
UCB0CTL0            ABS    CONST UNTYP.           ASEG       68 
UCB0CTL1            ABS    CONST UNTYP.           ASEG       69 
UCB0I2CIE           ABS    CONST UNTYP.           ASEG       6C 
UCB0I2COA           ABS    CONST UNTYP.           ASEG       118 
UCB0I2CSA           ABS    CONST UNTYP.           ASEG       11A 
UCB0RXBUF           ABS    CONST UNTYP.           ASEG       6E 
UCB0STAT            ABS    CONST UNTYP.           ASEG       6D 
UCB0TXBUF           ABS    CONST UNTYP.           ASEG       6F 
UDOT                REL    CONST PUB UNTYP.       CODE       F26 
UDOTR               REL    CONST PUB UNTYP.       CODE       1832 
UDSLASHMOD          REL    CONST PUB UNTYP.       CODE       E44 
UDSTAR              REL    CONST PUB UNTYP.       CODE       E62 
UGREATER            REL    CONST PUB UNTYP.       CODE       53C 
UINIT               REL    CONST PUB UNTYP.       CODE       A1E 
ULESS               REL    CONST PUB UNTYP.       CODE       52C 
UMAX                REL    CONST PUB UNTYP.       CODE       D00 
UMAX1               REL    CONST UNTYP.           CODE       D0C 
UMIN                REL    CONST PUB UNTYP.       CODE       CE8 
UMIN1               REL    CONST UNTYP.           CODE       CF4 
UMSLASHMOD          REL    CONST PUB UNTYP.       CODE       64E 
UMSTAR              REL    CONST PUB UNTYP.       CODE       61E 
UNLOOP              REL    CONST PUB UNTYP.       CODE       60C 
UNTIL               REL    CONST PUB UNTYP.       CODE       1612 
UNUSED              REL    CONST PUB UNTYP.       CODE       1CB2 
UP                  ABS    CONST EXT [000] UNTYP. __EXTERNS  Solved Extern 
UPC                 REL    CONST PUB UNTYP.       CODE       1148 
UPC1                REL    CONST UNTYP.           CODE       1162 
USER                REL    CONST PUB UNTYP.       CODE       A6 
VALIDQ              REL    CONST PUB UNTYP.       CODE       19D6 
VARIABLE            REL    CONST PUB UNTYP.       CODE       68 
WARM                REL    CONST PUB UNTYP.       CODE       1A4E 
WDS1                REL    CONST UNTYP.           CODE       180C 
WDTCTL              ABS    CONST UNTYP.           ASEG       120 
WHILE               REL    CONST PUB UNTYP.       CODE       163E 
WIPE                REL    CONST PUB UNTYP.       CODE       1AA6 
WITHIN              REL    CONST PUB UNTYP.       CODE       170E 
WORD1               REL    CONST UNTYP.           CODE       1094 
WORDD               REL    CONST PUB UNTYP.       CODE       1070 
WORDS               REL    CONST PUB UNTYP.       CODE       1806 
XDOES               REL    CONST PUB UNTYP.       CODE       1492 
XISQUOTE            REL    CONST PUB UNTYP.       CODE       DA6 
XORR                REL    CONST PUB UNTYP.       CODE       40A 
XSQUOTE             REL    CONST PUB UNTYP.       CODE       DBE 
ZERO                REL    CONST PUB UNTYP.       CODE       7CE 
ZEROEQUAL           REL    CONST PUB UNTYP.       CODE       4C6 
ZEROLESS            REL    CONST PUB UNTYP.       CODE       4D6 
__MSP430G2203__     ABS    CONST UNTYP.           ASEG       Not solved 
boot1               REL    CONST UNTYP.           CODE       1A44 
bran                REL    CONST PUB UNTYP.       CODE       54E 
cclr                REL    CONST PUB UNTYP.       CODE       1C34 
ccrc1               REL    CONST UNTYP.           CODE       191C 
cget                REL    CONST PUB UNTYP.       CODE       1C64 
cget1               REL    CONST UNTYP.           CODE       1C70 
cget2               REL    CONST UNTYP.           CODE       1C72 
cor                 ABS    CONST EXT [010] UNTYP. __EXTERNS  Solved Extern 
crcval              ABS    CONST EXT [013] UNTYP. __EXTERNS  Solved Extern 
cset                REL    CONST PUB UNTYP.       CODE       1C08 
ctoggle             REL    CONST PUB UNTYP.       CODE       1C4E 
dobran              REL    CONST UNTYP.           CODE       550 
docreate            REL    CONST PUB UNTYP.       CODE       86 
dodoes              REL    CONST PUB UNTYP.       CODE       C2 
donext              REL    CONST UNTYP.           CODE       7AA 
donoop              REL    CONST UNTYP.           CODE       7AA 
dotcold0            REL    CONST UNTYP.           CODE       1A61 
dotcold1            REL    CONST UNTYP.           CODE       1A66 
green               REL    CONST PUB UNTYP.       CODE       1CF4 
ih1                 REL    CONST UNTYP.           CODE       198A 
infoB               ABS    CONST EXT [011] UNTYP. __EXTERNS  Solved Extern 
invalid             REL    CONST UNTYP.           CODE       1A24 
lastword            REL    CONST PUB UNTYP.       CODE       1D09 
link                REL    VAR UNTYP.             CODE       1D09 
lit                 REL    CONST PUB UNTYP.       CODE       36 
ms1                 REL    CONST UNTYP.           CODE       1BE2 
nullirq             ABS    CONST EXT [-001] UNTYP. __EXTERNS  Solved Extern 
onems1              REL    CONST UNTYP.           CODE       1BC4 
onems2              REL    CONST UNTYP.           CODE       1BCC 
pcrc1               REL    CONST UNTYP.           CODE       1956 
pcrc2               REL    CONST UNTYP.           CODE       1964 
pcrc3               REL    CONST UNTYP.           CODE       1966 
qbran               REL    CONST PUB UNTYP.       CODE       562 
red                 REL    CONST PUB UNTYP.       CODE       1CE4 
reset               REL    CONST UNTYP.           CODE       1A32 
valid               REL    CONST UNTYP.           CODE       1A22 
ver0                REL    CONST UNTYP.           CODE       1 
verend              REL    CONST UNTYP.           CODE       1A 
version             REL    CONST UNTYP.           CODE       0 
warm0               REL    CONST UNTYP.           CODE       1A53 
warm1               REL    CONST UNTYP.           CODE       1A58 
wclr                REL    CONST PUB UNTYP.       CODE       1C1E 
wipmsg0             REL    CONST UNTYP.           CODE       1AAB 
wipmsg1             REL    CONST UNTYP.           CODE       1AB2 
wset                REL    CONST PUB UNTYP.       CODE       1BF2 
xdo                 REL    CONST PUB UNTYP.       CODE       578 
xloop               REL    CONST PUB UNTYP.       CODE       59E 
xplusloop           REL    CONST PUB UNTYP.       CODE       5BE 


##############################
#          CRC:8287          #
#        Errors:   0         #
#        Warnings: 0         #
#        Bytes: 7448         #
##############################



